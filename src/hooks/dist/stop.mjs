// OrchestKit Hooks - stop bundle
// Generated: 2026-01-24T17:31:36.191Z

var A=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});function kn(t){return typeof t.command=="string"}function Sn(t){return typeof t.file_path=="string"&&typeof t.content=="string"}function _n(t){return typeof t.file_path=="string"&&typeof t.old_string=="string"&&typeof t.new_string=="string"}function bn(t){return typeof t.file_path=="string"&&t.content===void 0}import{appendFileSync as et,existsSync as nt,statSync as qt,renameSync as Wt,mkdirSync as Gt}from"node:fs";function st(){return process.env.CLAUDE_PLUGIN_ROOT?`${process.env.HOME}/.claude/logs/ork`:`${p()}/.claude/logs`}function p(){return process.env.CLAUDE_PROJECT_DIR||"."}function it(){return process.env.CLAUDE_PLUGIN_ROOT||process.env.CLAUDE_PROJECT_DIR||"."}function f(){return process.env.CLAUDE_SESSION_ID||`fallback-${process.pid}-${Date.now()}`}function vn(t){if(process.env.ORCHESTKIT_BRANCH)return process.env.ORCHESTKIT_BRANCH;let{execSync:e}=A("node:child_process");try{let n=e("git branch --show-current",{cwd:t||p(),encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim();return process.env.ORCHESTKIT_BRANCH=n,n}catch{return"unknown"}}function Kt(){return process.env.ORCHESTKIT_LOG_LEVEL||"warn"}function zt(t){let e=["debug","info","warn","error"];return e.indexOf(t)>=e.indexOf(Kt())}function u(){return{continue:!0,suppressOutput:!0}}function In(){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{permissionDecision:"allow"}}}function wn(t){return{continue:!1,stopReason:t,hookSpecificOutput:{permissionDecision:"deny",permissionDecisionReason:t}}}function Rn(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PostToolUse",additionalContext:t}}}function On(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:t}}}function Tn(t,e){let n={continue:!0,hookSpecificOutput:{hookEventName:"PreToolUse",additionalContext:t,permissionDecision:"allow"}};return e?n.systemMessage=e:n.suppressOutput=!0,n}function jn(t){return{continue:!0,systemMessage:t}}function An(t){return{continue:!0,systemMessage:`\u26A0 ${t}`}}function Dn(t){return{continue:!1,stopReason:t,hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"deny",permissionDecisionReason:t}}}var Vt=200*1024,Xt=100*1024;function ot(t,e){if(nt(t))try{if(qt(t).size>e){let s=`${t}.old.${Date.now()}`;Wt(t,s)}}catch{}}function rt(t){nt(t)||Gt(t,{recursive:!0})}function i(t,e,n="debug"){if(!zt(n))return;let s=st(),o=`${s}/hooks.log`;try{rt(s),ot(o,Vt);let r=new Date().toISOString().replace("T"," ").slice(0,19);et(o,`[${r}] [${n.toUpperCase()}] [${t}] ${e}
`)}catch{}}function Cn(t,e,n){let s=st(),o=`${s}/permission-feedback.log`;try{rt(s),ot(o,Xt);let r=new Date().toISOString(),c=n?.tool_name||process.env.HOOK_TOOL_NAME||"unknown",a=n?.session_id||f();et(o,`${r} | ${t} | ${e} | tool=${c} | session=${a}
`)}catch{}}function Hn(){try{let t=[],n=Buffer.allocUnsafe(256),s,o=0,{readSync:r}=A("node:fs");for(;;)try{if(s=r(o,n,0,256,null),s===0)break;t.push(Buffer.from(n.subarray(0,s)))}catch{break}let c=Buffer.concat(t).toString("utf8").trim();return c?JSON.parse(c):{tool_name:"",session_id:f(),tool_input:{}}}catch{return{tool_name:"",session_id:f(),tool_input:{}}}}function En(t,e){let n=e.replace(/^\./,"").split("."),s=t;for(let o of n){if(s==null)return;s=s[o]}return s}function Nn(t){return t.replace(/\\\s*[\r\n]+/g," ").replace(/\n/g," ").replace(/\s+/g," ").trim()}function Pn(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}import{existsSync as pt,readFileSync as Yt,writeFileSync as Zt,mkdirSync as Qt}from"node:fs";import{createHash as te}from"node:crypto";var ct=500,L=3,at=15,ut=3,ee=.9;function lt(){return`${p()}/.claude/feedback/calibration-data.json`}function ne(){let t=`${p()}/.claude/feedback`;if(!pt(t))try{Qt(t,{recursive:!0})}catch{}}function _(){let t=lt();if(pt(t))try{return JSON.parse(Yt(t,"utf8"))}catch{i("calibration-engine","Failed to load calibration data, using defaults")}return{schemaVersion:"1.0.0",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),records:[],adjustments:[],stats:{totalDispatches:0,successRate:0,avgConfidence:0,topAgents:[]}}}function B(t){ne();let e=lt();t.updatedAt=new Date().toISOString();try{Zt(e,JSON.stringify(t,null,2)),i("calibration-engine","Saved calibration data")}catch(n){i("calibration-engine",`Failed to save calibration data: ${n}`)}}function se(t){return te("sha256").update(t.toLowerCase().trim()).digest("hex").slice(0,16)}function Ln(t,e,n,s,o,r,c){let a=_(),d={timestamp:new Date().toISOString(),sessionId:f(),agent:e,promptHash:se(t),matchedKeywords:n,dispatchConfidence:s,outcome:o,durationMs:r,feedback:c};a.records.push(d),a.records.length>ct&&(a.records=a.records.slice(-ct)),ie(a,d),oe(a),B(a),i("calibration-engine",`Recorded outcome: ${e} -> ${o} (conf: ${s})`)}function ie(t,e){let n=e.outcome==="success",s=e.outcome==="failure"||e.outcome==="rejected";if(!n&&!s)return;let o=n?ut:-ut;for(let r of e.matchedKeywords){let c=t.adjustments.find(a=>a.keyword===r&&a.agent===e.agent);c?(c.adjustment=Math.max(-at,Math.min(at,c.adjustment+o)),c.sampleCount++,c.lastUpdated=new Date().toISOString()):t.adjustments.push({keyword:r,agent:e.agent,adjustment:o,sampleCount:1,lastUpdated:new Date().toISOString()})}}function dt(t){let e=Date.now(),n=1440*60*1e3;for(let s of t.adjustments){let o=e-new Date(s.lastUpdated).getTime();Math.floor(o/n)>7&&(s.adjustment=Math.round(s.adjustment*ee),Math.abs(s.adjustment)<1&&(s.adjustment=0))}t.adjustments=t.adjustments.filter(s=>s.adjustment!==0)}function oe(t){let e=t.records;if(e.length===0)return;t.stats.totalDispatches=e.length;let n=e.filter(r=>r.outcome==="success").length;t.stats.successRate=n/e.length;let s=e.reduce((r,c)=>r+c.dispatchConfidence,0)/e.length;t.stats.avgConfidence=Math.round(s);let o=new Map;for(let r of e){let c=o.get(r.agent)||{count:0,success:0};c.count++,r.outcome==="success"&&c.success++,o.set(r.agent,c)}t.stats.topAgents=Array.from(o.entries()).map(([r,c])=>({agent:r,count:c.count,successRate:c.success/c.count})).sort((r,c)=>c.count-r.count).slice(0,10)}function Bn(){return _().adjustments.filter(e=>e.sampleCount>=L)}function qn(t){let n=_().records.filter(o=>o.agent===t);return n.length<L?null:n.filter(o=>o.outcome==="success").length/n.length}function Wn(){return _().stats}function Gn(){return _().records.length>=L}function gt(t){i("auto-remember-continuity","Hook triggered");let n=(t.project_dir||p()).split("/").pop()||"project",o=!!process.env.MEM0_API_KEY?"\n   [Optional] Also sync to mem0 cloud with `--mem0` flag for semantic search":"",r=`Before ending this session, consider preserving important context in the knowledge graph:

1. **Session Continuity** - If there's unfinished work or next steps:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "session-${n}",
     "entityType": "Session",
     "observations": ["What was done: [...]", "Next steps: [...]"]
   }]}
   \`\`\`${o}

2. **Important Decisions** - If architectural/design decisions were made:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "decision-[topic]",
     "entityType": "Decision",
     "observations": ["Decided: [...]", "Rationale: [...]"]
   }]}
   \`\`\`

3. **Patterns Learned** - If something worked well or failed:
   - Use \`/remember --success "pattern that worked"\`
   - Use \`/remember --failed "pattern that caused issues"\`

Skip if this was just a quick question/answer session.`;return i("auto-remember-continuity","Outputting memory prompt for session end"),{continue:!0,suppressOutput:!0}}import{existsSync as mt,mkdirSync as re,readFileSync as ce,writeFileSync as ft}from"node:fs";function yt(t){i("auto-save-context","Stop hook - auto-saving context (Protocol 2.0)");let n=`${t.project_dir||p()}/.claude/context/session`,s=`${n}/state.json`;try{mt(n)||re(n,{recursive:!0})}catch{}let o=new Date().toISOString();try{if(mt(s)){let r=ce(s,"utf-8"),c=JSON.parse(r),a={$schema:c.$schema||"context://session/v1",_meta:c._meta||{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:c.session_id||null,started:c.started||null,last_activity:o,current_task:c.current_task||{description:"No active task",status:"pending"},next_steps:c.next_steps||[],blockers:c.blockers||[]};ft(s,JSON.stringify(a,null,2)),i("auto-save-context","Updated session state timestamp")}else ft(s,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:null,started:o,last_activity:o,current_task:{description:"No active task",status:"pending"},next_steps:[],blockers:[]},null,2)),i("auto-save-context","Created new session state (Protocol 2.0 compliant)")}catch(r){i("auto-save-context",`Error saving context: ${r}`)}return u()}import{existsSync as ht,readFileSync as ae}from"node:fs";import{execSync as W}from"node:child_process";function ue(t){let e=`${t}/.instance/id.json`;try{return ht(e)&&JSON.parse(ae(e,"utf-8")).instance_id||null}catch{return null}}function q(t,e){try{W(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function kt(t){let e=t.project_dir||p(),n=`${e}/.claude/coordination/.claude.db`;if(!ht(n))return i("cleanup-instance","No coordination database, skipping cleanup"),u();let s=ue(e);if(!s)return i("cleanup-instance","No instance ID to clean up"),u();i("cleanup-instance",`Cleaning up instance: ${s}`),i("cleanup-instance","Releasing all locks..."),q(n,`DELETE FROM file_locks WHERE instance_id = '${s}';`),i("cleanup-instance","All locks released");try{W(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='work_claims';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(q(n,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${s}' AND status = 'active';`),i("cleanup-instance","Work claims handled"))}catch{}try{W(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='instances';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(q(n,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${s}';`),i("cleanup-instance","Instance status updated to terminated"))}catch{}return i("cleanup-instance","Multi-instance cleanup completed"),u()}import{existsSync as St,mkdirSync as _t,readFileSync as bt,writeFileSync as D}from"node:fs";var G=10;function pe(t){let e=`${t}/session/state.json`;if(!St(e)){i("context-compressor","No session state to archive");return}try{let n=bt(e,"utf-8"),s=JSON.parse(n),o=s.session_id||`session-${new Date().toISOString().replace(/[:.]/g,"-")}`,r=`${t}/archive/sessions`;_t(r,{recursive:!0});let c=`${r}/${o}.json`,a={...s,ended:new Date().toISOString(),archived:!0};D(c,JSON.stringify(a,null,2)),i("context-compressor",`Archived session to ${c}`),D(e,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always"},session_id:null,started:null,current_task:null,files_touched:[],decisions_this_session:[],blockers:[],next_steps:[],scratchpad:{notes:[]}},null,2)),i("context-compressor","Reset session state")}catch(n){i("context-compressor",`Error archiving session: ${n}`)}}function le(t){let e=`${t}/knowledge/decisions/active.json`;if(St(e))try{let n=bt(e,"utf-8"),s=JSON.parse(n),o=s.decisions||[];if(o.length<=G)return;let r=`${t}/archive/decisions`;_t(r,{recursive:!0});let c=new Date,a=`${r}/${c.getFullYear()}-${String(c.getMonth()+1).padStart(2,"0")}.json`,d=o.slice(0,-G);D(a,JSON.stringify(d,null,2)),s.decisions=o.slice(-G),D(e,JSON.stringify(s,null,2)),i("context-compressor",`Archived ${d.length} old decisions`)}catch(n){i("context-compressor",`Error compressing decisions: ${n}`)}}function $t(t){i("context-compressor","Starting end-of-session compression...");let n=`${t.project_dir||p()}/context`;return pe(n),le(n),i("context-compressor","End-of-session compression complete"),u()}import{existsSync as k,readFileSync as de,writeFileSync as ge,mkdirSync as me}from"node:fs";import{execSync as b}from"node:child_process";function fe(t){let e=`${t}/.claude/hooks/logs/.last-test-run`;if(!k(e))return!0;try{let n=b("git diff --name-only HEAD",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]});if(/\.(py|js|ts|go|rs)$/.test(n))return!0}catch{return!0}return i("full-test-suite","No code changes detected, skipping tests"),!1}function ye(t,e){let n=0;if(k(`${t}/pytest.ini`)||k(`${t}/pyproject.toml`)||k(`${t}/tests`)&&k(`${t}/requirements.txt`)){i("full-test-suite","Detected Python project, running pytest...");try{b("pytest --tb=short --timeout=300 -q",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if(k(`${t}/package.json`)){i("full-test-suite","Detected Node.js project...");try{if(JSON.parse(de(`${t}/package.json`,"utf-8")).scripts?.test){i("full-test-suite","Running npm test...");let o="npm test -- --passWithNoTests --watchAll=false";try{b("which pnpm",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),o="pnpm test --passWithNoTests"}catch{try{b("which yarn",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),o="yarn test --passWithNoTests"}catch{}}b(o,{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}}catch{n=1}}if(k(`${t}/go.mod`)){i("full-test-suite","Detected Go project, running go test...");try{b("go test -v -timeout 5m ./...",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if(k(`${t}/Cargo.toml`)){i("full-test-suite","Detected Rust project, running cargo test...");try{b("cargo test",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}return n===0}function xt(t){i("full-test-suite","=== Full Test Suite Started ===");let e=t.project_dir||p(),n=`${e}/.claude/hooks/logs`;try{me(n,{recursive:!0})}catch{}let s=`${n}/full-test-suite.log`;if(!fe(e))return u();if(ye(e,s)){i("full-test-suite","=== All tests passed ===");try{ge(`${n}/.last-test-run`,String(Date.now()))}catch{}}else i("full-test-suite","=== Some tests failed ===");return u()}import{existsSync as he,readFileSync as ke,unlinkSync as Se,rmdirSync as _e}from"node:fs";import{execSync as I}from"node:child_process";function be(){try{return I("which gh",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),I("gh auth status",{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function $e(t){try{return I("git remote get-url origin",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).includes("github")}catch{return!1}}function xe(t,e,n){let s=e.commits||[];if(s.length===0)return"";let o=s.map(c=>`- \`${c.sha}\`: ${c.message}`).join(`
`),r=e.tasks_completed?.length>0?`### Sub-tasks Completed
${e.tasks_completed.map(c=>`- [x] ${c}`).join(`
`)}`:"";return`## Claude Code Progress Update

**Session**: \`${n.slice(0,8)}...\`
**Branch**: \`${e.branch||"unknown"}\`

### Commits (${s.length})
${o}

${r}
---
*Automated by [OrchestKit](https://github.com/yonatangross/orchestkit)*`}function ve(t,e){try{return I(`gh issue comment ${t} --body "${e.replace(/"/g,'\\"')}"`,{encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function vt(t){i("issue-work-summary","Session ending, checking for issue progress to post...");let e=t.project_dir||p(),n=t.session_id||f(),o=`/tmp/claude-session-${n.replace(/[^a-zA-Z0-9_-]/g,"")}`,r=`${o}/issue-progress.json`;if(!he(r))return i("issue-work-summary",`No progress file found at ${r}`),u();if(!be())return i("issue-work-summary","gh CLI not available or not authenticated, skipping"),u();if(!$e(e))return i("issue-work-summary","Not a GitHub repository, skipping"),u();let c;try{c=JSON.parse(ke(r,"utf-8"))}catch{return i("issue-work-summary","Failed to read progress file"),u()}let a=c.issues?Object.keys(c.issues):[];if(a.length===0)return i("issue-work-summary","No issues to process"),u();let d=0;for(let l of a){let m=c.issues[l];if((m.commits||[]).length===0){i("issue-work-summary",`No commits for issue #${l}, skipping`);continue}try{I(`gh issue view ${l} --json number`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{i("issue-work-summary",`Issue #${l} not found or not accessible, skipping`);continue}let h=xe(l,m,n);h&&ve(l,h)&&(d++,i("issue-work-summary",`Successfully posted comment to issue #${l}`))}i("issue-work-summary",`Posted progress comments to ${d} issue(s)`);try{Se(r);try{_e(o)}catch{}i("issue-work-summary","Cleaned up progress file")}catch{}return u()}import{existsSync as $,readFileSync as v,mkdirSync as Ie,appendFileSync as we,writeFileSync as Re}from"node:fs";import{spawn as Oe}from"node:child_process";function Te(t,e){if(!$(t))return 0;try{let s=JSON.parse(v(t,"utf-8")).decisions||[];if($(e)){let r=JSON.parse(v(e,"utf-8")).synced_decisions||[];return s.filter(c=>!r.includes(c.decision_id)).length}return s.length}catch{return 0}}function je(t){if(!$(t))return{count:0,patterns:[]};try{let e=v(t,"utf-8"),n;try{n=e.split(`
`).filter(o=>o.trim()).map(o=>JSON.parse(o))}catch{n=[JSON.parse(e)]}let s=n.filter(o=>o.pending_sync===!0);return{count:s.length,patterns:s}}catch{return{count:0,patterns:[]}}}function Ae(t){return t.split("/").pop()||"project"}function De(t){let e="",n="",s="",o=`${t}/.claude/context/session/state.json`;if($(o))try{let c=JSON.parse(v(o,"utf-8"));e=c.current_task||c.task||""}catch{}let r=`${t}/.claude/logs/blockers.jsonl`;if($(r))try{n=v(r,"utf-8").split(`
`).filter(l=>l.trim()).map(l=>JSON.parse(l)).filter(l=>!l.resolved).slice(-5).map(l=>l.description||"").join("; ")}catch{}return{currentTask:e,blockers:n,nextSteps:s}}function It(t){let e=t.project_dir||p(),n=it(),s=`${n}/.claude/coordination/decision-log.json`,o=`${e}/.claude/logs/agent-patterns.jsonl`,r=`${n}/.claude/coordination/.decision-sync-state.json`,c=Te(s,r),{count:a,patterns:d}=je(o),{currentTask:l,blockers:m,nextSteps:y}=De(e);if(c===0&&a===0&&!l)return u();let h=Ae(e),N=`${e}/.claude/logs/mem0-sync.log`;try{Ie(`${e}/.claude/logs`,{recursive:!0})}catch{}let g=[];if(c>0&&g.push(`${c} decisions to sync`),a>0){g.push(`${a} agent patterns pending`);let M=new Set(d.map(J=>J.agent_id||J.agent).filter(Boolean)),j=Array.from(M).slice(0,5);j.length>0&&g.push(`agents: ${j.join(", ")}`)}let Z=g.length>0?g.join("; "):"No pending items",P=l||"Session work";c>0&&(P+=` (${c} decisions made)`),a>0&&(P+=` (${a} patterns learned)`);let F=`Session Summary: ${P}`;m&&(F+=` | Blockers: ${m}`),y&&(F+=` | Next: ${y}`);let Q=`${n}/skills/mem0-memory/scripts/crud/add-memory.py`,Lt=process.env.MEM0_API_KEY,T;if($(Q)&&Lt){let M=new Date().toISOString();try{we(N,`[${M}] Auto-sync triggered for session summary
`)}catch{}let j=JSON.stringify({type:"session_summary",status:"in_progress",project:h,has_blockers:!!m,has_next_steps:!!y,source:"orchestkit-plugin"});if(Oe("python3",[Q,"--text",F,"--user-id",`${h}-continuity`,"--metadata",j,"--enable-graph"],{detached:!0,stdio:"ignore"}).unref(),a>0&&$(o))try{let Bt=v(o,"utf-8").split(`
`).filter(U=>U.trim()).map(U=>{let tt=JSON.parse(U);return tt.pending_sync=!1,JSON.stringify(tt)}).join(`
`);Re(o,Bt)}catch{}T=`[Mem0 Sync] Auto-synced: ${Z}`}else T=`[Mem0 Sync] ${Z} - Execute /mem0-sync to persist session context`;return i("mem0-pre-compaction-sync",T),{continue:!0,systemMessage:T}}import{existsSync as C,readFileSync as wt,unlinkSync as Rt}from"node:fs";import{execSync as Ot}from"node:child_process";function H(t,e){try{Ot(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function K(t,e){try{return Ot(`sqlite3 "${t}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='${e}';"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()==="1"}catch{return!1}}function Ce(t){let e=`${t}/heartbeat.pid`;if(C(e))try{let n=parseInt(wt(e,"utf-8").trim(),10);try{process.kill(n,0),process.kill(n),i("multi-instance-cleanup",`Stopped heartbeat process (PID: ${n})`)}catch{}Rt(e)}catch{}}function He(t,e){i("multi-instance-cleanup","Releasing all locks..."),H(t,`DELETE FROM file_locks WHERE instance_id = '${e}';`),i("multi-instance-cleanup","All locks released")}function Ee(t,e){i("multi-instance-cleanup","Handling work claims..."),K(t,"work_claims")?(H(t,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${e}' AND status = 'active';`),i("multi-instance-cleanup","Work claims handled")):i("multi-instance-cleanup","No work_claims table, skipping")}function Ne(t,e){K(t,"instances")?(H(t,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${e}';`),i("multi-instance-cleanup","Instance status updated to terminated")):i("multi-instance-cleanup","No instances table, skipping status update")}function Pe(t,e){if(!K(t,"messages")){i("multi-instance-cleanup","No messages table, skipping broadcast");return}let n=`msg-${Math.random().toString(36).slice(2,18)}`,s=new Date().toISOString(),o=JSON.stringify({instance_id:e,timestamp:s}).replace(/'/g,"''");H(t,`INSERT INTO messages (message_id, from_instance, to_instance, message_type, payload, expires_at) VALUES ('${n}', '${e}', NULL, 'shutdown', '${o}', datetime('now', '+1 hour'));`),i("multi-instance-cleanup","Shutdown broadcast sent")}function Fe(t){let e=["knowledge_cache.json","claims.json","session_discoveries.json"];for(let n of e){let s=`${t}/${n}`;try{C(s)&&Rt(s)}catch{}}i("multi-instance-cleanup","Instance files cleaned up")}function Tt(t){let e=t.project_dir||p(),n=`${e}/.instance`,s=`${e}/.claude/coordination/.claude.db`;if(!C(s))return i("multi-instance-cleanup","No coordination database, skipping cleanup"),u();let o=`${n}/id.json`;if(!C(o))return i("multi-instance-cleanup","No instance identity, skipping cleanup"),u();let r;try{r=JSON.parse(wt(o,"utf-8")).instance_id}catch{return i("multi-instance-cleanup","Failed to read instance ID"),u()}return i("multi-instance-cleanup",`Starting multi-instance cleanup for ${r}...`),Ce(n),He(s,r),Ee(s,r),Pe(s,r),Ne(s,r),Fe(n),i("multi-instance-cleanup","=== Cleanup Summary ==="),i("multi-instance-cleanup",`Instance: ${r}`),i("multi-instance-cleanup","Status: terminated"),i("multi-instance-cleanup","Multi-instance cleanup completed"),u()}import{existsSync as x,mkdirSync as Me,readFileSync as Je,writeFileSync as w,readdirSync as jt}from"node:fs";import{execSync as S}from"node:child_process";function Ue(t,e){if(!x(`${t}/package.json`)||!x(`${t}/package-lock.json`)&&!x(`${t}/yarn.lock`)&&!x(`${t}/pnpm-lock.yaml`))return null;i("security-scan","Running npm audit...");try{S("npm audit --json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]})}catch(n){if(n.stdout){w(`${e}/npm-audit.json`,n.stdout);try{let s=JSON.parse(n.stdout);return{critical:s.metadata?.vulnerabilities?.critical||0,high:s.metadata?.vulnerabilities?.high||0}}catch{}}}return i("security-scan","npm audit complete"),{critical:0,high:0}}function Le(t,e){if(!x(`${t}/requirements.txt`)&&!x(`${t}/pyproject.toml`))return null;try{S("which pip-audit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","pip-audit not installed, skipping"),null}i("security-scan","Running pip-audit...");try{let n=S("pip-audit --format json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]});w(`${e}/pip-audit.json`,n);let s=JSON.parse(n);return i("security-scan","pip-audit complete"),Array.isArray(s)?s.length:0}catch{return 0}}function Be(t,e){try{S("which semgrep",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","semgrep not installed, skipping"),null}i("security-scan","Running semgrep...");try{let n=S("semgrep --config auto --json --quiet",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]});w(`${e}/semgrep.json`,n);let o=(JSON.parse(n).results||[]).filter(r=>r.extra?.severity==="ERROR").length;return i("security-scan","semgrep complete"),o}catch{return 0}}function qe(t,e){try{if(!S('find . -name "*.py" -maxdepth 2 | head -1',{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()&&!x(`${t}/backend`))return null}catch{return null}try{S("which bandit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","bandit not installed, skipping"),null}i("security-scan","Running bandit...");try{return S(`bandit -r . -f json -o ${e}/bandit.json`,{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]}),i("security-scan","bandit complete"),0}catch{return 0}}function We(t,e){i("security-scan","Running secret detection...");let n=/(api[_-]?key|secret[_-]?key|password|token)\s*[=:]\s*["'][^"']{8,}/i,s=0,o=[],r=[".py",".js",".ts",".env"];function c(a){try{let d=jt(a,{withFileTypes:!0});for(let l of d){let m=`${a}/${l.name}`;if(l.isDirectory()){["node_modules",".git","dist","build"].includes(l.name)||c(m);continue}if(r.some(y=>l.name.endsWith(y)))try{let y=Je(m,"utf-8");n.test(y)&&(o.push({file:m,type:"potential_secret"}),s++)}catch{}}}catch{}}return c(t),w(`${e}/secrets.json`,JSON.stringify({findings:o,count:s},null,2)),i("security-scan",`Secret detection complete: ${s} potential issues`),s}function Ge(t,e){i("security-scan","Aggregating results...");let n=0,s=0;e.npmAudit&&(n+=e.npmAudit.critical,s+=e.npmAudit.high),e.pipAudit!==null&&(s+=e.pipAudit),e.semgrep!==null&&(s+=e.semgrep);let o=jt(t).filter(c=>c.endsWith(".json")&&!c.includes("aggregated")).map(c=>c.replace(".json","")),r={timestamp:new Date().toISOString(),summary:{critical:n,high:s,medium:0},scans_completed:o};w(`${t}/aggregated-report.json`,JSON.stringify(r,null,2)),i("security-scan","=== Security Scan Complete ==="),i("security-scan",`Critical: ${n}, High: ${s}`),n>0&&console.error(`Security: ${n} critical, ${s} high vulnerabilities found`)}function At(t){i("security-scan","=== Security Scan Started ===");let e=t.project_dir||p(),n=`${e}/.claude/hooks/logs/security`;Me(n,{recursive:!0});let s={npmAudit:null,pipAudit:null,semgrep:null,bandit:null,secrets:0};return s.npmAudit=Ue(e,n),s.pipAudit=Le(e,n),s.semgrep=Be(e,n),s.bandit=qe(e,n),s.secrets=We(e,n),Ge(n,s),u()}import{existsSync as R,mkdirSync as E,readFileSync as O,writeFileSync as z}from"node:fs";function Ke(t){if(!R(t))return"";try{let n=JSON.parse(O(t,"utf-8")).tools||{};return Object.entries(n).sort(([,o],[,r])=>r-o).slice(0,10).map(([o])=>o).join(",")}catch{return""}}function ze(t){if(!R(t))return 0;try{let n=JSON.parse(O(t,"utf-8")).tools||{};return Object.values(n).reduce((s,o)=>s+o,0)}catch{return 0}}function Ve(t){return t.includes("Write")&&t.includes("Bash")&&/test|pytest|jest|vitest/i.test(t)?"test-driven-development":t.includes("Read")&&t.includes("Grep")?"code-exploration":t.includes("Edit")&&!t.includes("Write")?"refactoring":t.includes("Write")&&t.includes("Read")?"feature-development":t.includes("Bash")&&/git|gh/i.test(t)?"git-operations":"general"}function Xe(t){return"unknown"}function Ye(t){if(R(t))try{return JSON.parse(O(t,"utf-8"))}catch{}return{version:"1.0.0",last_updated:null,sessions_count:0,workflow_types:{"test-driven-development":0,"code-exploration":0,refactoring:0,"feature-development":0,"git-operations":0,general:0},common_tool_sequences:[],dominant_languages:{python:0,typescript:0,javascript:0,go:0,rust:0,unknown:0},average_tools_per_session:0,average_session_duration_seconds:0,tool_frequency:{}}}function Ze(t,e,n,s,o){let r=Ye(t),c=new Date().toISOString();if(r.last_updated=c,r.sessions_count+=1,r.workflow_types[e]=(r.workflow_types[e]||0)+1,r.dominant_languages[n]=(r.dominant_languages[n]||0)+1,r.average_tools_per_session=(r.average_tools_per_session*(r.sessions_count-1)+s)/r.sessions_count,o.split(",").filter(Boolean).length>2){let d=new Set([o,...r.common_tool_sequences]);r.common_tool_sequences=Array.from(d).slice(0,20)}E(t.replace(/\/[^/]+$/,""),{recursive:!0}),z(t,JSON.stringify(r,null,2))}function Qe(t){if(R(t))try{return JSON.parse(O(t,"utf-8"))}catch{}return{version:"1.0",updated:"",patterns:[],categories:{},stats:{total:0,successes:0,failures:0}}}function tn(t){let e=`${t}/.claude/feedback/patterns-queue.json`,n=`${t}/.claude/feedback/learned-patterns.json`;if(!R(e)){i("session-patterns","No patterns queue found");return}let s;try{s=JSON.parse(O(e,"utf-8"))}catch{i("session-patterns","Failed to parse patterns queue");return}let o=s.patterns?.length||0;if(o===0){i("session-patterns","Patterns queue is empty");return}i("session-patterns",`Processing ${o} queued patterns...`);let r=Qe(n),c=new Date().toISOString(),a=[...r.patterns,...s.patterns],d=new Map;for(let g of a)d.set(g.text,g);let l=Array.from(d.values()),m=l.filter(g=>g.outcome==="success").length,y=l.filter(g=>g.outcome==="failed").length,h={};for(let g of l)h[g.category]=(h[g.category]||0)+1;let N={version:"1.0",updated:c,patterns:l,categories:h,stats:{total:l.length,successes:m,failures:y}};E(n.replace(/\/[^/]+$/,""),{recursive:!0}),z(n,JSON.stringify(N,null,2)),i("session-patterns","Merged patterns successfully"),z(e,JSON.stringify({patterns:[]}))}function Dt(t){i("session-patterns","Session ending, processing patterns...");let e=t.project_dir||p(),n="/tmp/claude-session-metrics.json",s=`${e}/.claude/feedback/workflow-patterns.json`;E(`${e}/.claude/feedback`,{recursive:!0}),E(`${e}/.claude/logs`,{recursive:!0});let o=ze(n);if(o>=5){let r=Ke(n),c=Ve(r),a=Xe(r);Ze(s,c,a,o,r),i("session-patterns",`Workflow analyzed: type=${c} lang=${a} tools=${o}`)}else i("session-patterns",`Session too short for workflow analysis (tools: ${o})`);return tn(e),i("session-patterns","Pattern processing complete"),u()}import{existsSync as en,readFileSync as nn}from"node:fs";function Ct(t){i("task-completion-check","Stop hook - checking task completion");let e="/tmp/claude-active-todos.json";if(!en(e))return u();try{let s=JSON.parse(nn(e,"utf-8")).filter(o=>o.status==="in_progress");if(s.length>0){i("task-completion-check",`WARNING: ${s.length} tasks in progress at stop`);for(let o of s)o.description&&i("task-completion-check",`  - ${o.description}`);return{continue:!0,suppressOutput:!0}}}catch(n){i("task-completion-check",`Error reading todos: ${n}`)}return u()}import{existsSync as V,readFileSync as sn,writeFileSync as Js,mkdirSync as Us}from"node:fs";function Et(){return`${p()}/.claude/orchestration`}function on(){let t=f();return`${Et()}/session-${t}.json`}function rn(){return`${p()}/.claude/orchestration/config.json`}var Ht={enableAutoDispatch:!0,enableSkillInjection:!0,maxSkillInjectionTokens:800,enableCalibration:!0,enablePipelines:!0,maxRetries:3,retryDelayBaseMs:1e3};function Nt(){let t=rn();if(V(t))try{let e=sn(t,"utf8");return{...Ht,...JSON.parse(e)}}catch{}return Ht}function X(){let t=on();try{if(V(t)){let{unlinkSync:e}=A("node:fs");e(t),i("orchestration-state","Cleared session state")}}catch{}}function Y(){let t=Et();if(V(t))try{let{readdirSync:e,statSync:n,unlinkSync:s}=A("node:fs"),o=e(t).filter(r=>r.startsWith("session-")&&r.endsWith(".json")).map(r=>({name:r,path:`${t}/${r}`,mtime:n(`${t}/${r}`).mtime.getTime()})).sort((r,c)=>c.mtime-r.mtime);for(let r of o.slice(5))try{s(r.path),i("orchestration-state",`Cleaned up old state: ${r.name}`)}catch{}}catch{}}import{existsSync as Pt,readFileSync as cn,writeFileSync as an,mkdirSync as un}from"node:fs";function Ft(){let t=f();return`${p()}/.claude/orchestration/task-registry-${t}.json`}function pn(){let t=`${p()}/.claude/orchestration`;if(!Pt(t))try{un(t,{recursive:!0})}catch{}}function ln(){let t=Ft();if(Pt(t))try{return JSON.parse(cn(t,"utf8"))}catch{}return{schemaVersion:"1.0.0",sessionId:f(),tasks:[],pipelines:[],updatedAt:new Date().toISOString()}}function dn(t){pn();let e=Ft();t.updatedAt=new Date().toISOString();try{an(e,JSON.stringify(t,null,2))}catch(n){i("task-integration",`Failed to save registry: ${n}`)}}function Mt(t=1440*60*1e3){let e=ln(),n=Date.now()-t;e.tasks=e.tasks.filter(s=>s.status==="pending"||s.status==="in_progress"?!0:new Date(s.createdAt).getTime()>n),e.pipelines=e.pipelines.filter(s=>s.status==="running"?!0:new Date(s.startedAt).getTime()>n),dn(e)}var gn=720*60*60*1e3;function mn(t){let e=Date.now()-gn,n=t.records.length;t.records=t.records.filter(o=>new Date(o.timestamp).getTime()>e);let s=t.records.length;n!==s&&i("calibration-persist",`Cleaned up ${n-s} old records`)}function fn(t){let e=t.stats,n=e.topAgents.slice(0,3).map(s=>`${s.agent}(${Math.round(s.successRate*100)}%)`).join(", ");return`Calibration summary: ${e.totalDispatches} dispatches, ${Math.round(e.successRate*100)}% success rate, ${t.adjustments.length} adjustments active. Top agents: ${n||"none"}`}function Jt(t){if(!Nt().enableCalibration)return X(),Y(),u();i("calibration-persist","Running end-of-session calibration persistence...");try{let n=_();dt(n),mn(n),B(n);let s=fn(n);i("calibration-persist",s)}catch(n){i("calibration-persist",`Error during calibration persist: ${n}`)}try{X(),Y(),Mt(),i("calibration-persist","Cleaned up session state")}catch(n){i("calibration-persist",`Error during state cleanup: ${n}`)}return u()}var Ut={"stop/auto-remember-continuity":gt,"stop/auto-save-context":yt,"stop/cleanup-instance":kt,"stop/context-compressor":$t,"stop/full-test-suite":xt,"stop/issue-work-summary":vt,"stop/mem0-pre-compaction-sync":It,"stop/multi-instance-cleanup":Tt,"stop/security-scan-aggregator":At,"stop/session-patterns":Dt,"stop/task-completion-check":Ct,"stop/calibration-persist":Jt};function pi(t){return Ut[t]}function li(){return Object.keys(Ut)}export{dt as applyDecay,Pn as escapeRegex,Bn as getAdjustments,qn as getAgentSuccessRate,vn as getCachedBranch,Wn as getCalibrationStats,En as getField,pi as getHook,st as getLogDir,Kt as getLogLevel,it as getPluginRoot,p as getProjectDir,f as getSessionId,Gn as hasMinimalCalibrationData,se as hashPrompt,Ut as hooks,kn as isBashInput,_n as isEditInput,bn as isReadInput,Sn as isWriteInput,li as listHooks,_ as loadCalibrationData,i as logHook,Cn as logPermissionFeedback,Nn as normalizeCommand,Tn as outputAllowWithContext,wn as outputBlock,Dn as outputDeny,jn as outputError,On as outputPromptContext,In as outputSilentAllow,u as outputSilentSuccess,An as outputWarning,Rn as outputWithContext,Hn as readHookInput,Ln as recordOutcome,B as saveCalibrationData,zt as shouldLog};
//# sourceMappingURL=stop.mjs.map
