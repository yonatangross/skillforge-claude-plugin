// OrchestKit Hooks - stop bundle
// Generated: 2026-01-28T11:51:28.711Z

var pt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});function Rn(t){return typeof t.command=="string"}function On(t){return typeof t.file_path=="string"&&typeof t.content=="string"}function Dn(t){return typeof t.file_path=="string"&&typeof t.old_string=="string"&&typeof t.new_string=="string"}function Hn(t){return typeof t.file_path=="string"&&t.content===void 0}import{appendFileSync as lt,existsSync as dt,statSync as te,renameSync as ee,mkdirSync as ne,readSync as se}from"node:fs";import{execSync as oe}from"node:child_process";function gt(){return process.env.CLAUDE_PLUGIN_ROOT?`${process.env.HOME||process.env.USERPROFILE||"/tmp"}/.claude/logs/ork`:`${l()}/.claude/logs`}function l(){return process.env.CLAUDE_PROJECT_DIR||"."}function mt(){return process.env.CLAUDE_PLUGIN_ROOT||process.env.CLAUDE_PROJECT_DIR||"."}function f(){return process.env.CLAUDE_SESSION_ID||`fallback-${process.pid}-${Date.now()}`}function En(t){if(process.env.ORCHESTKIT_BRANCH)return process.env.ORCHESTKIT_BRANCH;try{let e=oe("git branch --show-current",{cwd:t||l(),encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim();return process.env.ORCHESTKIT_BRANCH=e,e}catch{return"unknown"}}function ie(){return process.env.ORCHESTKIT_LOG_LEVEL||"warn"}function re(t){let e=["debug","info","warn","error"];return e.indexOf(t)>=e.indexOf(ie())}function p(){return{continue:!0,suppressOutput:!0}}function Pn(){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{permissionDecision:"allow"}}}function Nn(t){return{continue:!1,stopReason:t,hookSpecificOutput:{permissionDecision:"deny",permissionDecisionReason:t}}}function ft(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PostToolUse",additionalContext:t}}}function ae(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:t}}}function Fn(t,e){let n={continue:!0,hookSpecificOutput:{hookEventName:"PreToolUse",additionalContext:t,permissionDecision:"allow"}};return e?n.systemMessage=e:n.suppressOutput=!0,n}function Mn(t){return{continue:!0,systemMessage:t}}function Jn(t){return{continue:!0,systemMessage:`\u26A0 ${t}`}}function Un(t){return{continue:!1,stopReason:t,hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"deny",permissionDecisionReason:t}}}var ce=200*1024,ue=100*1024;function yt(t,e){if(dt(t))try{if(te(t).size>e){let s=`${t}.old.${Date.now()}`;ee(t,s)}}catch{}}function kt(t){dt(t)||ne(t,{recursive:!0})}function o(t,e,n="debug"){if(!re(n))return;let s=gt(),i=`${s}/hooks.log`;try{kt(s),yt(i,ce);let r=new Date().toISOString().replace("T"," ").slice(0,19);lt(i,`[${r}] [${n.toUpperCase()}] [${t}] ${e}
`)}catch{}}function Bn(t,e,n){let s=gt(),i=`${s}/permission-feedback.log`;try{kt(s),yt(i,ue);let r=new Date().toISOString(),a=n?.tool_name||process.env.HOOK_TOOL_NAME||"unknown",c=n?.session_id||f();lt(i,`${r} | ${t} | ${e} | tool=${a} | session=${c}
`)}catch{}}function pe(t){if(!t)return 0;let s=(t.match(/[{};()=><]/g)||[]).length/t.length>.03?2.8:3.5;return Math.ceil(t.length/s)}function Ln(t,e,n,s,i){let r=pe(t);return s&&s.isOverBudget(n)?(o(e,`Budget exhausted for ${n}, suppressing ${r}t`),p()):(i&&i.trackTokenUsage(e,n,r),ae(t))}function Wn(){try{let t=[],n=Buffer.allocUnsafe(256),s,i=0;for(;;)try{if(s=se(i,n,0,256,null),s===0)break;t.push(Buffer.from(n.subarray(0,s)))}catch{break}let r=Buffer.concat(t).toString("utf8").trim();return r?JSON.parse(r):{tool_name:"",session_id:f(),tool_input:{}}}catch{return{tool_name:"",session_id:f(),tool_input:{}}}}function qn(t,e){let n=e.replace(/^\./,"").split("."),s=t;for(let i of n){if(s==null)return;s=s[i]}return s}function Gn(t){return t.replace(/\\\s*[\r\n]+/g," ").replace(/\n/g," ").replace(/\s+/g," ").trim()}function Kn(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}import{existsSync as $t,readFileSync as le,writeFileSync as de,mkdirSync as ge}from"node:fs";import{createHash as me}from"node:crypto";var ht=500,z=3,St=15,bt=3,fe=.9;function _t(){return`${l()}/.claude/feedback/calibration-data.json`}function ye(){let t=`${l()}/.claude/feedback`;if(!$t(t))try{ge(t,{recursive:!0})}catch{}}function v(){let t=_t();if($t(t))try{return JSON.parse(le(t,"utf8"))}catch{o("calibration-engine","Failed to load calibration data, using defaults")}return{schemaVersion:"1.0.0",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),records:[],adjustments:[],stats:{totalDispatches:0,successRate:0,avgConfidence:0,topAgents:[]}}}function Y(t){ye();let e=_t();t.updatedAt=new Date().toISOString();try{de(e,JSON.stringify(t,null,2)),o("calibration-engine","Saved calibration data")}catch(n){o("calibration-engine",`Failed to save calibration data: ${n}`)}}function ke(t){return me("sha256").update(t.toLowerCase().trim()).digest("hex").slice(0,16)}function Zn(t,e,n,s,i,r,a){let c=v(),d={timestamp:new Date().toISOString(),sessionId:f(),agent:e,promptHash:ke(t),matchedKeywords:n,dispatchConfidence:s,outcome:i,durationMs:r,feedback:a};c.records.push(d),c.records.length>ht&&(c.records=c.records.slice(-ht)),he(c,d),Se(c),Y(c),o("calibration-engine",`Recorded outcome: ${e} -> ${i} (conf: ${s})`)}function he(t,e){let n=e.outcome==="success",s=e.outcome==="failure"||e.outcome==="rejected";if(!n&&!s)return;let i=n?bt:-bt;for(let r of e.matchedKeywords){let a=t.adjustments.find(c=>c.keyword===r&&c.agent===e.agent);a?(a.adjustment=Math.max(-St,Math.min(St,a.adjustment+i)),a.sampleCount++,a.lastUpdated=new Date().toISOString()):t.adjustments.push({keyword:r,agent:e.agent,adjustment:i,sampleCount:1,lastUpdated:new Date().toISOString()})}}function xt(t){let e=Date.now(),n=1440*60*1e3;for(let s of t.adjustments){let i=e-new Date(s.lastUpdated).getTime();Math.floor(i/n)>7&&(s.adjustment=Math.round(s.adjustment*fe),Math.abs(s.adjustment)<1&&(s.adjustment=0))}t.adjustments=t.adjustments.filter(s=>s.adjustment!==0)}function Se(t){let e=t.records;if(e.length===0)return;t.stats.totalDispatches=e.length;let n=e.filter(r=>r.outcome==="success").length;t.stats.successRate=n/e.length;let s=e.reduce((r,a)=>r+a.dispatchConfidence,0)/e.length;t.stats.avgConfidence=Math.round(s);let i=new Map;for(let r of e){let a=i.get(r.agent)||{count:0,success:0};a.count++,r.outcome==="success"&&a.success++,i.set(r.agent,a)}t.stats.topAgents=Array.from(i.entries()).map(([r,a])=>({agent:r,count:a.count,successRate:a.success/a.count})).sort((r,a)=>a.count-r.count).slice(0,10)}function Qn(){return v().adjustments.filter(e=>e.sampleCount>=z)}function ts(t){let n=v().records.filter(i=>i.agent===t);return n.length<z?null:n.filter(i=>i.outcome==="success").length/n.length}function es(){return v().stats}function ns(){return v().records.length>=z}function vt(t){o("auto-remember-continuity","Hook triggered");let n=(t.project_dir||l()).split("/").pop()||"project",i=!!process.env.MEM0_API_KEY?"\n   [Optional] Also sync to mem0 cloud with `--mem0` flag for semantic search":"",r=`Before ending this session, consider preserving important context in the knowledge graph:

1. **Session Continuity** - If there's unfinished work or next steps:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "session-${n}",
     "entityType": "Session",
     "observations": ["What was done: [...]", "Next steps: [...]"]
   }]}
   \`\`\`${i}

2. **Important Decisions** - If architectural/design decisions were made:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "decision-[topic]",
     "entityType": "Decision",
     "observations": ["Decided: [...]", "Rationale: [...]"]
   }]}
   \`\`\`

3. **Patterns Learned** - If something worked well or failed:
   - Use \`/remember --success "pattern that worked"\`
   - Use \`/remember --failed "pattern that caused issues"\`

Skip if this was just a quick question/answer session.`;return o("auto-remember-continuity","Outputting memory prompt for session end"),{continue:!0,suppressOutput:!0}}import{existsSync as It,mkdirSync as be,readFileSync as $e,writeFileSync as wt}from"node:fs";function N(t){o("auto-save-context","Stop hook - auto-saving context (Protocol 2.0)");let n=`${t.project_dir||l()}/.claude/context/session`,s=`${n}/state.json`;try{It(n)||be(n,{recursive:!0})}catch{}let i=new Date().toISOString();try{if(It(s)){let r=$e(s,"utf-8"),a=JSON.parse(r),c={$schema:a.$schema||"context://session/v1",_meta:a._meta||{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:a.session_id||null,started:a.started||null,last_activity:i,current_task:a.current_task||{description:"No active task",status:"pending"},next_steps:a.next_steps||[],blockers:a.blockers||[]};wt(s,JSON.stringify(c,null,2)),o("auto-save-context","Updated session state timestamp")}else wt(s,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:null,started:i,last_activity:i,current_task:{description:"No active task",status:"pending"},next_steps:[],blockers:[]},null,2)),o("auto-save-context","Created new session state (Protocol 2.0 compliant)")}catch(r){o("auto-save-context",`Error saving context: ${r}`)}return p()}import{existsSync as Tt,readFileSync as _e}from"node:fs";import{execSync as X}from"node:child_process";function xe(t){let e=`${t}/.instance/id.json`;try{return Tt(e)&&JSON.parse(_e(e,"utf-8")).instance_id||null}catch{return null}}function V(t,e){try{X(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function Rt(t){let e=t.project_dir||l(),n=`${e}/.claude/coordination/.claude.db`;if(!Tt(n))return o("cleanup-instance","No coordination database, skipping cleanup"),p();let s=xe(e);if(!s)return o("cleanup-instance","No instance ID to clean up"),p();o("cleanup-instance",`Cleaning up instance: ${s}`),o("cleanup-instance","Releasing all locks..."),V(n,`DELETE FROM file_locks WHERE instance_id = '${s}';`),o("cleanup-instance","All locks released");try{X(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='work_claims';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(V(n,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${s}' AND status = 'active';`),o("cleanup-instance","Work claims handled"))}catch{}try{X(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='instances';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(V(n,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${s}';`),o("cleanup-instance","Instance status updated to terminated"))}catch{}return o("cleanup-instance","Multi-instance cleanup completed"),p()}import{existsSync as Q,mkdirSync as tt,readFileSync as et,writeFileSync as O}from"node:fs";var Z=10;function ve(t){let e=`${t}/session/state.json`;if(!Q(e)){o("context-compressor","No session state to archive");return}try{let n=et(e,"utf-8"),s=JSON.parse(n),i=s.session_id||`session-${new Date().toISOString().replace(/[:.]/g,"-")}`,r=`${t}/archive/sessions`;tt(r,{recursive:!0});let a=`${r}/${i}.json`,c={...s,ended:new Date().toISOString(),archived:!0};O(a,JSON.stringify(c,null,2)),o("context-compressor",`Archived session to ${a}`),O(e,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always"},session_id:null,started:null,current_task:null,files_touched:[],decisions_this_session:[],blockers:[],next_steps:[],scratchpad:{notes:[]}},null,2)),o("context-compressor","Reset session state")}catch(n){o("context-compressor",`Error archiving session: ${n}`)}}function Ie(t){let e=`${t}/knowledge/decisions/active.json`;if(Q(e))try{let n=et(e,"utf-8"),s=JSON.parse(n),i=s.decisions||[];if(i.length<=Z)return;let r=`${t}/archive/decisions`;tt(r,{recursive:!0});let a=new Date,c=`${r}/${a.getFullYear()}-${String(a.getMonth()+1).padStart(2,"0")}.json`,d=i.slice(0,-Z);O(c,JSON.stringify(d,null,2)),s.decisions=i.slice(-Z),O(e,JSON.stringify(s,null,2)),o("context-compressor",`Archived ${d.length} old decisions`)}catch(n){o("context-compressor",`Error compressing decisions: ${n}`)}}function we(t){let e=`${t}/session/state.json`;if(Q(e))try{let n=et(e,"utf-8"),s=JSON.parse(n),i={sessionId:s.session_id||"unknown",compactedAt:new Date().toISOString(),keyDecisions:(s.decisions_this_session||[]).slice(-5),filesTouched:(s.files_touched||[]).slice(-20),blockers:s.blockers||[],nextSteps:s.next_steps||[]},r=`${t}/session`;tt(r,{recursive:!0}),O(`${r}/compaction-manifest.json`,JSON.stringify(i,null,2)),o("context-compressor",`Wrote compaction manifest for session ${i.sessionId}`)}catch(n){o("context-compressor",`Error writing compaction manifest: ${n}`)}}function Ot(t){o("context-compressor","Starting end-of-session compression...");let n=`${t.project_dir||l()}/context`;return we(n),ve(n),Ie(n),o("context-compressor","End-of-session compression complete"),p()}import{existsSync as $,readFileSync as Te,writeFileSync as Re,mkdirSync as Oe}from"node:fs";import{execSync as I}from"node:child_process";function De(t){let e=`${t}/.claude/hooks/logs/.last-test-run`;if(!$(e))return!0;try{let n=I("git diff --name-only HEAD",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]});if(/\.(py|js|ts|go|rs)$/.test(n))return!0}catch{return!0}return o("full-test-suite","No code changes detected, skipping tests"),!1}function He(t,e){let n=0;if($(`${t}/pytest.ini`)||$(`${t}/pyproject.toml`)||$(`${t}/tests`)&&$(`${t}/requirements.txt`)){o("full-test-suite","Detected Python project, running pytest...");try{I("pytest --tb=short --timeout=300 -q",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if($(`${t}/package.json`)){o("full-test-suite","Detected Node.js project...");try{if(JSON.parse(Te(`${t}/package.json`,"utf-8")).scripts?.test){o("full-test-suite","Running npm test...");let i="npm test -- --passWithNoTests --watchAll=false";try{I("which pnpm",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),i="pnpm test --passWithNoTests"}catch{try{I("which yarn",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),i="yarn test --passWithNoTests"}catch{}}I(i,{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}}catch{n=1}}if($(`${t}/go.mod`)){o("full-test-suite","Detected Go project, running go test...");try{I("go test -v -timeout 5m ./...",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if($(`${t}/Cargo.toml`)){o("full-test-suite","Detected Rust project, running cargo test...");try{I("cargo test",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}return n===0}function Dt(t){o("full-test-suite","=== Full Test Suite Started ===");let e=t.project_dir||l(),n=`${e}/.claude/hooks/logs`;try{Oe(n,{recursive:!0})}catch{}let s=`${n}/full-test-suite.log`;if(!De(e))return p();if(He(e,s)){o("full-test-suite","=== All tests passed ===");try{Re(`${n}/.last-test-run`,String(Date.now()))}catch{}}else o("full-test-suite","=== Some tests failed ===");return p()}import{existsSync as je,readFileSync as Ce,unlinkSync as Ae,rmdirSync as Ee}from"node:fs";import{execSync as D}from"node:child_process";function Pe(){try{return D("which gh",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),D("gh auth status",{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function Ne(t){try{return D("git remote get-url origin",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).includes("github")}catch{return!1}}function Fe(t,e,n){let s=e.commits||[];if(s.length===0)return"";let i=s.map(a=>`- \`${a.sha}\`: ${a.message}`).join(`
`),r=e.tasks_completed?.length>0?`### Sub-tasks Completed
${e.tasks_completed.map(a=>`- [x] ${a}`).join(`
`)}`:"";return`## Claude Code Progress Update

**Session**: \`${n.slice(0,8)}...\`
**Branch**: \`${e.branch||"unknown"}\`

### Commits (${s.length})
${i}

${r}
---
*Automated by [OrchestKit](https://github.com/yonatangross/orchestkit)*`}function Me(t,e){try{return D(`gh issue comment ${t} --body "${e.replace(/"/g,'\\"')}"`,{encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function F(t){o("issue-work-summary","Session ending, checking for issue progress to post...");let e=t.project_dir||l(),n=t.session_id||f(),i=`/tmp/claude-session-${n.replace(/[^a-zA-Z0-9_-]/g,"")}`,r=`${i}/issue-progress.json`;if(!je(r))return o("issue-work-summary",`No progress file found at ${r}`),p();if(!Pe())return o("issue-work-summary","gh CLI not available or not authenticated, skipping"),p();if(!Ne(e))return o("issue-work-summary","Not a GitHub repository, skipping"),p();let a;try{a=JSON.parse(Ce(r,"utf-8"))}catch{return o("issue-work-summary","Failed to read progress file"),p()}let c=a.issues?Object.keys(a.issues):[];if(c.length===0)return o("issue-work-summary","No issues to process"),p();let d=0;for(let u of c){let g=a.issues[u];if((g.commits||[]).length===0){o("issue-work-summary",`No commits for issue #${u}, skipping`);continue}try{D(`gh issue view ${u} --json number`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{o("issue-work-summary",`Issue #${u} not found or not accessible, skipping`);continue}let h=Fe(u,g,n);h&&Me(u,h)&&(d++,o("issue-work-summary",`Successfully posted comment to issue #${u}`))}o("issue-work-summary",`Posted progress comments to ${d} issue(s)`);try{Ae(r);try{Ee(i)}catch{}o("issue-work-summary","Cleaned up progress file")}catch{}return p()}import{existsSync as w,readFileSync as R,mkdirSync as Je,appendFileSync as H,writeFileSync as Ue}from"node:fs";import{spawn as Be}from"node:child_process";function Le(t,e){if(!w(t))return 0;try{let s=JSON.parse(R(t,"utf-8")).decisions||[];if(w(e)){let r=JSON.parse(R(e,"utf-8")).synced_decisions||[];return s.filter(a=>!r.includes(a.decision_id)).length}return s.length}catch{return 0}}function We(t){if(!w(t))return{count:0,patterns:[]};try{let e=R(t,"utf-8"),n;try{n=e.split(`
`).filter(i=>i.trim()).map(i=>JSON.parse(i))}catch{n=[JSON.parse(e)]}let s=n.filter(i=>i.pending_sync===!0);return{count:s.length,patterns:s}}catch{return{count:0,patterns:[]}}}function qe(t){return t.split("/").pop()||"project"}function Ge(t){let e="",n="",s="",i=`${t}/.claude/context/session/state.json`;if(w(i))try{let a=JSON.parse(R(i,"utf-8"));e=a.current_task||a.task||""}catch{}let r=`${t}/.claude/logs/blockers.jsonl`;if(w(r))try{n=R(r,"utf-8").split(`
`).filter(u=>u.trim()).map(u=>JSON.parse(u)).filter(u=>!u.resolved).slice(-5).map(u=>u.description||"").join("; ")}catch{}return{currentTask:e,blockers:n,nextSteps:s}}function Ht(t){if(!process.env.MEM0_API_KEY)return o("mem0-pre-compaction-sync","Mem0 not configured (no MEM0_API_KEY), skipping"),p();let e=t.project_dir||l(),n=mt(),s=`${n}/.claude/coordination/decision-log.json`,i=`${e}/.claude/logs/agent-patterns.jsonl`,r=`${n}/.claude/coordination/.decision-sync-state.json`,a=Le(s,r),{count:c,patterns:d}=We(i),{currentTask:u,blockers:g,nextSteps:y}=Ge(e);if(a===0&&c===0&&!u)return p();let h=qe(e),x=`${e}/.claude/logs/mem0-sync.log`;try{Je(`${e}/.claude/logs`,{recursive:!0})}catch{}let m=[];if(a>0&&m.push(`${a} decisions to sync`),c>0){m.push(`${c} agent patterns pending`);let G=new Set(d.map(S=>S.agent_id||S.agent).filter(Boolean)),P=Array.from(G).slice(0,5);P.length>0&&m.push(`agents: ${P.join(", ")}`)}let at=m.length>0?m.join("; "):"No pending items",W=u||"Session work";a>0&&(W+=` (${a} decisions made)`),c>0&&(W+=` (${c} patterns learned)`);let q=`Session Summary: ${W}`;g&&(q+=` | Blockers: ${g}`),y&&(q+=` | Next: ${y}`);let ct=`${n}/skills/mem0-memory/scripts/crud/add-memory.py`,Qt=process.env.MEM0_API_KEY,E;if(w(ct)&&Qt){let G=new Date().toISOString();try{H(x,`[${G}] Auto-sync triggered for session summary
`)}catch{}let P=JSON.stringify({type:"session_summary",status:"in_progress",project:h,has_blockers:!!g,has_next_steps:!!y,source:"orchestkit-plugin"}),S=Be("python3",[ct,"--text",q,"--user-id",`${h}-continuity`,"--metadata",P,"--enable-graph"],{detached:!0,stdio:["ignore","pipe","pipe"]});if(S.on("error",b=>{let k=new Date().toISOString();try{H(x,`[${k}] Sync child process error: ${b.message}
`)}catch{}}),S.on("close",b=>{let k=new Date().toISOString();try{b===0?H(x,`[${k}] Sync completed successfully
`):H(x,`[${k}] Sync exited with code ${b}
`)}catch{}}),S.stderr){let b="";S.stderr.on("data",k=>{b+=k.toString()}),S.stderr.on("end",()=>{if(b.trim()){let k=new Date().toISOString();try{H(x,`[${k}] Sync stderr: ${b.trim()}
`)}catch{}}})}if(S.unref(),c>0&&w(i))try{let k=R(i,"utf-8").split(`
`).filter(K=>K.trim()).map(K=>{let ut=JSON.parse(K);return ut.pending_sync=!1,JSON.stringify(ut)}).join(`
`);Ue(i,k)}catch{}E=`[Mem0 Sync] Auto-synced: ${at}`}else E=`[Mem0 Sync] ${at} - Execute /mem0-sync to persist session context`;return o("mem0-pre-compaction-sync",E),{continue:!0,systemMessage:E}}import{existsSync as M,readFileSync as jt,unlinkSync as Ct}from"node:fs";import{execSync as At}from"node:child_process";function J(t,e){try{At(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function nt(t,e){try{return At(`sqlite3 "${t}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='${e}';"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()==="1"}catch{return!1}}function Ke(t){let e=`${t}/heartbeat.pid`;if(M(e))try{let n=parseInt(jt(e,"utf-8").trim(),10);try{process.kill(n,0),process.kill(n),o("multi-instance-cleanup",`Stopped heartbeat process (PID: ${n})`)}catch{}Ct(e)}catch{}}function ze(t,e){o("multi-instance-cleanup","Releasing all locks..."),J(t,`DELETE FROM file_locks WHERE instance_id = '${e}';`),o("multi-instance-cleanup","All locks released")}function Ye(t,e){o("multi-instance-cleanup","Handling work claims..."),nt(t,"work_claims")?(J(t,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${e}' AND status = 'active';`),o("multi-instance-cleanup","Work claims handled")):o("multi-instance-cleanup","No work_claims table, skipping")}function Ve(t,e){nt(t,"instances")?(J(t,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${e}';`),o("multi-instance-cleanup","Instance status updated to terminated")):o("multi-instance-cleanup","No instances table, skipping status update")}function Xe(t,e){if(!nt(t,"messages")){o("multi-instance-cleanup","No messages table, skipping broadcast");return}let n=`msg-${Math.random().toString(36).slice(2,18)}`,s=new Date().toISOString(),i=JSON.stringify({instance_id:e,timestamp:s}).replace(/'/g,"''");J(t,`INSERT INTO messages (message_id, from_instance, to_instance, message_type, payload, expires_at) VALUES ('${n}', '${e}', NULL, 'shutdown', '${i}', datetime('now', '+1 hour'));`),o("multi-instance-cleanup","Shutdown broadcast sent")}function Ze(t){let e=["knowledge_cache.json","claims.json","session_discoveries.json"];for(let n of e){let s=`${t}/${n}`;try{M(s)&&Ct(s)}catch{}}o("multi-instance-cleanup","Instance files cleaned up")}function Et(t){let e=t.project_dir||l(),n=`${e}/.instance`,s=`${e}/.claude/coordination/.claude.db`;if(!M(s))return o("multi-instance-cleanup","No coordination database, skipping cleanup"),p();let i=`${n}/id.json`;if(!M(i))return o("multi-instance-cleanup","No instance identity, skipping cleanup"),p();let r;try{r=JSON.parse(jt(i,"utf-8")).instance_id}catch{return o("multi-instance-cleanup","Failed to read instance ID"),p()}return o("multi-instance-cleanup",`Starting multi-instance cleanup for ${r}...`),Ke(n),ze(s,r),Ye(s,r),Xe(s,r),Ve(s,r),Ze(n),o("multi-instance-cleanup","=== Cleanup Summary ==="),o("multi-instance-cleanup",`Instance: ${r}`),o("multi-instance-cleanup","Status: terminated"),o("multi-instance-cleanup","Multi-instance cleanup completed"),p()}import{existsSync as T,mkdirSync as Qe,readFileSync as tn,writeFileSync as j,readdirSync as Pt}from"node:fs";import{execSync as _}from"node:child_process";function en(t,e){if(!T(`${t}/package.json`)||!T(`${t}/package-lock.json`)&&!T(`${t}/yarn.lock`)&&!T(`${t}/pnpm-lock.yaml`))return null;o("security-scan","Running npm audit...");try{_("npm audit --json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]})}catch(n){if(n.stdout){j(`${e}/npm-audit.json`,n.stdout);try{let s=JSON.parse(n.stdout);return{critical:s.metadata?.vulnerabilities?.critical||0,high:s.metadata?.vulnerabilities?.high||0}}catch{}}}return o("security-scan","npm audit complete"),{critical:0,high:0}}function nn(t,e){if(!T(`${t}/requirements.txt`)&&!T(`${t}/pyproject.toml`))return null;try{_("which pip-audit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return o("security-scan","pip-audit not installed, skipping"),null}o("security-scan","Running pip-audit...");try{let n=_("pip-audit --format json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]});j(`${e}/pip-audit.json`,n);let s=JSON.parse(n);return o("security-scan","pip-audit complete"),Array.isArray(s)?s.length:0}catch{return 0}}function sn(t,e){try{_("which semgrep",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return o("security-scan","semgrep not installed, skipping"),null}o("security-scan","Running semgrep...");try{let n=_("semgrep --config auto --json --quiet",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]});j(`${e}/semgrep.json`,n);let i=(JSON.parse(n).results||[]).filter(r=>r.extra?.severity==="ERROR").length;return o("security-scan","semgrep complete"),i}catch{return 0}}function on(t,e){try{if(!_('find . -name "*.py" -maxdepth 2 | head -1',{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()&&!T(`${t}/backend`))return null}catch{return null}try{_("which bandit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return o("security-scan","bandit not installed, skipping"),null}o("security-scan","Running bandit...");try{return _(`bandit -r . -f json -o ${e}/bandit.json`,{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]}),o("security-scan","bandit complete"),0}catch{return 0}}function rn(t,e){o("security-scan","Running secret detection...");let n=/(api[_-]?key|secret[_-]?key|password|token)\s*[=:]\s*["'][^"']{8,}/i,s=0,i=[],r=[".py",".js",".ts",".env"];function a(c){try{let d=Pt(c,{withFileTypes:!0});for(let u of d){let g=`${c}/${u.name}`;if(u.isDirectory()){["node_modules",".git","dist","build"].includes(u.name)||a(g);continue}if(r.some(y=>u.name.endsWith(y)))try{let y=tn(g,"utf-8");n.test(y)&&(i.push({file:g,type:"potential_secret"}),s++)}catch{}}}catch{}}return a(t),j(`${e}/secrets.json`,JSON.stringify({findings:i,count:s},null,2)),o("security-scan",`Secret detection complete: ${s} potential issues`),s}function an(t,e){o("security-scan","Aggregating results...");let n=0,s=0;e.npmAudit&&(n+=e.npmAudit.critical,s+=e.npmAudit.high),e.pipAudit!==null&&(s+=e.pipAudit),e.semgrep!==null&&(s+=e.semgrep);let i=Pt(t).filter(a=>a.endsWith(".json")&&!a.includes("aggregated")).map(a=>a.replace(".json","")),r={timestamp:new Date().toISOString(),summary:{critical:n,high:s,medium:0},scans_completed:i};j(`${t}/aggregated-report.json`,JSON.stringify(r,null,2)),o("security-scan","=== Security Scan Complete ==="),o("security-scan",`Critical: ${n}, High: ${s}`),n>0&&console.error(`Security: ${n} critical, ${s} high vulnerabilities found`)}function Nt(t){o("security-scan","=== Security Scan Started ===");let e=t.project_dir||l(),n=`${e}/.claude/hooks/logs/security`;Qe(n,{recursive:!0});let s={npmAudit:null,pipAudit:null,semgrep:null,bandit:null,secrets:0};return s.npmAudit=en(e,n),s.pipAudit=nn(e,n),s.semgrep=sn(e,n),s.bandit=on(e,n),s.secrets=rn(e,n),an(n,s),p()}import{existsSync as C,mkdirSync as U,readFileSync as A,writeFileSync as st}from"node:fs";function cn(t){if(!C(t))return"";try{let n=JSON.parse(A(t,"utf-8")).tools||{};return Object.entries(n).sort(([,i],[,r])=>r-i).slice(0,10).map(([i])=>i).join(",")}catch{return""}}function un(t){if(!C(t))return 0;try{let n=JSON.parse(A(t,"utf-8")).tools||{};return Object.values(n).reduce((s,i)=>s+i,0)}catch{return 0}}function pn(t){return t.includes("Write")&&t.includes("Bash")&&/test|pytest|jest|vitest/i.test(t)?"test-driven-development":t.includes("Read")&&t.includes("Grep")?"code-exploration":t.includes("Edit")&&!t.includes("Write")?"refactoring":t.includes("Write")&&t.includes("Read")?"feature-development":t.includes("Bash")&&/git|gh/i.test(t)?"git-operations":"general"}function ln(t){return"unknown"}function dn(t){if(C(t))try{return JSON.parse(A(t,"utf-8"))}catch{}return{version:"1.0.0",last_updated:null,sessions_count:0,workflow_types:{"test-driven-development":0,"code-exploration":0,refactoring:0,"feature-development":0,"git-operations":0,general:0},common_tool_sequences:[],dominant_languages:{python:0,typescript:0,javascript:0,go:0,rust:0,unknown:0},average_tools_per_session:0,average_session_duration_seconds:0,tool_frequency:{}}}function gn(t,e,n,s,i){let r=dn(t),a=new Date().toISOString();if(r.last_updated=a,r.sessions_count+=1,r.workflow_types[e]=(r.workflow_types[e]||0)+1,r.dominant_languages[n]=(r.dominant_languages[n]||0)+1,r.average_tools_per_session=(r.average_tools_per_session*(r.sessions_count-1)+s)/r.sessions_count,i.split(",").filter(Boolean).length>2){let d=new Set([i,...r.common_tool_sequences]);r.common_tool_sequences=Array.from(d).slice(0,20)}U(t.replace(/\/[^/]+$/,""),{recursive:!0}),st(t,JSON.stringify(r,null,2))}function mn(t){if(C(t))try{return JSON.parse(A(t,"utf-8"))}catch{}return{version:"1.0",updated:"",patterns:[],categories:{},stats:{total:0,successes:0,failures:0}}}function fn(t){let e=`${t}/.claude/feedback/patterns-queue.json`,n=`${t}/.claude/feedback/learned-patterns.json`;if(!C(e)){o("session-patterns","No patterns queue found");return}let s;try{s=JSON.parse(A(e,"utf-8"))}catch{o("session-patterns","Failed to parse patterns queue");return}let i=s.patterns?.length||0;if(i===0){o("session-patterns","Patterns queue is empty");return}o("session-patterns",`Processing ${i} queued patterns...`);let r=mn(n),a=new Date().toISOString(),c=[...r.patterns,...s.patterns],d=new Map;for(let m of c)d.set(m.text,m);let u=Array.from(d.values()),g=u.filter(m=>m.outcome==="success").length,y=u.filter(m=>m.outcome==="failed").length,h={};for(let m of u)h[m.category]=(h[m.category]||0)+1;let x={version:"1.0",updated:a,patterns:u,categories:h,stats:{total:u.length,successes:g,failures:y}};U(n.replace(/\/[^/]+$/,""),{recursive:!0}),st(n,JSON.stringify(x,null,2)),o("session-patterns","Merged patterns successfully"),st(e,JSON.stringify({patterns:[]}))}function B(t){o("session-patterns","Session ending, processing patterns...");let e=t.project_dir||l(),n="/tmp/claude-session-metrics.json",s=`${e}/.claude/feedback/workflow-patterns.json`;U(`${e}/.claude/feedback`,{recursive:!0}),U(`${e}/.claude/logs`,{recursive:!0});let i=un(n);if(i>=5){let r=cn(n),a=pn(r),c=ln(r);gn(s,a,c,i,r),o("session-patterns",`Workflow analyzed: type=${a} lang=${c} tools=${i}`)}else o("session-patterns",`Session too short for workflow analysis (tools: ${i})`);return fn(e),o("session-patterns","Pattern processing complete"),p()}import{existsSync as Wt,readFileSync as qt}from"node:fs";import{existsSync as Ft,readFileSync as yn,writeFileSync as kn,mkdirSync as hn}from"node:fs";function Mt(){let t=f();return`${l()}/.claude/orchestration/task-registry-${t}.json`}function Sn(){let t=`${l()}/.claude/orchestration`;if(!Ft(t))try{hn(t,{recursive:!0})}catch{}}function Jt(){let t=Mt();if(Ft(t))try{return JSON.parse(yn(t,"utf8"))}catch{}return{schemaVersion:"1.0.0",sessionId:f(),tasks:[],pipelines:[],updatedAt:new Date().toISOString()}}function bn(t){Sn();let e=Mt();t.updatedAt=new Date().toISOString();try{kn(e,JSON.stringify(t,null,2))}catch(n){o("task-integration",`Failed to save registry: ${n}`)}}function Ut(t,e){return`### Delete Orphaned Task

\`\`\`
TaskUpdate:
  taskId: "${t}"
  status: "deleted"
\`\`\`

**Reason**: ${e}`}function Bt(){let t=Jt(),e=new Set(t.tasks.filter(n=>n.status==="failed").map(n=>n.taskId));return e.size===0?[]:t.tasks.filter(n=>n.status!=="pending"||!n.blockedBy||n.blockedBy.length===0?!1:n.blockedBy.every(s=>e.has(s)))}function Lt(t=1440*60*1e3){let e=Jt(),n=Date.now()-t;e.tasks=e.tasks.filter(s=>s.status==="pending"||s.status==="in_progress"?!0:new Date(s.createdAt).getTime()>n),e.pipelines=e.pipelines.filter(s=>s.status==="running"?!0:new Date(s.startedAt).getTime()>n),bn(e)}function Gt(t){o("task-completion-check","Stop hook - checking task completion");let e=[],n=t.project_dir||l(),s=t.session_id||f(),i=`${n}/.claude/orchestration/task-registry-${s}.json`;if(Wt(i))try{let u=(JSON.parse(qt(i,"utf-8")).tasks||[]).filter(g=>g.status==="in_progress");u.length>0&&(o("task-completion-check",`WARNING: ${u.length} orchestration tasks still in progress`),e.push(`${u.length} orchestration task(s) still in progress at session stop`))}catch(d){o("task-completion-check",`Error reading registry: ${d}`)}let r=Bt(),a="";if(r.length>0){o("task-completion-check",`Found ${r.length} orphaned tasks`),a=`

## Orphaned Tasks

The following tasks are orphaned (all blockers failed) and should be deleted:
`;for(let d of r)a+=`
${Ut(d.taskId,"All blocking tasks have failed")}`}let c="/tmp/claude-active-todos.json";if(Wt(c))try{let u=JSON.parse(qt(c,"utf-8")).filter(g=>g.status==="in_progress");u.length>0&&(o("task-completion-check",`WARNING: ${u.length} legacy tasks in progress at stop`),e.push(`${u.length} legacy task(s) still in progress`))}catch(d){o("task-completion-check",`Error reading legacy todos: ${d}`)}if(e.length>0||a){let d=`## Task Completion Warning

${e.map(u=>`- ${u}`).join(`
`)}`;return a&&(d+=a),ft(d)}return p()}import{existsSync as ot,readFileSync as $n,writeFileSync as Qs,mkdirSync as to}from"node:fs";function zt(){return`${l()}/.claude/orchestration`}function _n(){let t=f();return`${zt()}/session-${t}.json`}function xn(){return`${l()}/.claude/orchestration/config.json`}var Kt={enableAutoDispatch:!0,enableSkillInjection:!0,maxSkillInjectionTokens:800,enableCalibration:!0,enablePipelines:!0,maxRetries:3,retryDelayBaseMs:1e3};function Yt(){let t=xn();if(ot(t))try{let e=$n(t,"utf8");return{...Kt,...JSON.parse(e)}}catch{}return Kt}function it(){let t=_n();try{if(ot(t)){let{unlinkSync:e}=pt("node:fs");e(t),o("orchestration-state","Cleared session state")}}catch{}}function rt(){let t=zt();if(ot(t))try{let{readdirSync:e,statSync:n,unlinkSync:s}=pt("node:fs"),i=e(t).filter(r=>r.startsWith("session-")&&r.endsWith(".json")).map(r=>({name:r,path:`${t}/${r}`,mtime:n(`${t}/${r}`).mtime.getTime()})).sort((r,a)=>a.mtime-r.mtime);for(let r of i.slice(5))try{s(r.path),o("orchestration-state",`Cleaned up old state: ${r.name}`)}catch{}}catch{}}var vn=720*60*60*1e3;function In(t){let e=Date.now()-vn,n=t.records.length;t.records=t.records.filter(i=>new Date(i.timestamp).getTime()>e);let s=t.records.length;n!==s&&o("calibration-persist",`Cleaned up ${n-s} old records`)}function wn(t){let e=t.stats,n=e.topAgents.slice(0,3).map(s=>`${s.agent}(${Math.round(s.successRate*100)}%)`).join(", ");return`Calibration summary: ${e.totalDispatches} dispatches, ${Math.round(e.successRate*100)}% success rate, ${t.adjustments.length} adjustments active. Top agents: ${n||"none"}`}function L(t){if(!Yt().enableCalibration)return it(),rt(),p();o("calibration-persist","Running end-of-session calibration persistence...");try{let n=v();xt(n),In(n),Y(n);let s=wn(n);o("calibration-persist",s)}catch(n){o("calibration-persist",`Error during calibration persist: ${n}`)}try{it(),rt(),Lt(),o("calibration-persist","Cleaned up session state")}catch(n){o("calibration-persist",`Error during state cleanup: ${n}`)}return p()}var Vt=[{name:"auto-save-context",fn:N},{name:"session-patterns",fn:B},{name:"issue-work-summary",fn:F},{name:"calibration-persist",fn:L}];async function Xt(t){let n=(await Promise.allSettled(Vt.map(async s=>{try{let i=s.fn(t);return i instanceof Promise&&await i,{hook:s.name,status:"success"}}catch(i){let r=i instanceof Error?i.message:String(i);return o("stop-dispatcher",`${s.name} failed: ${r}`),{hook:s.name,status:"error",message:r}}}))).filter(s=>s.status==="rejected"||s.status==="fulfilled"&&s.value.status==="error");return n.length>0&&o("stop-dispatcher",`${n.length}/${Vt.length} hooks had errors`),p()}var Zt={"stop/auto-remember-continuity":vt,"stop/auto-save-context":N,"stop/cleanup-instance":Rt,"stop/context-compressor":Ot,"stop/full-test-suite":Dt,"stop/issue-work-summary":F,"stop/mem0-pre-compaction-sync":Ht,"stop/multi-instance-cleanup":Et,"stop/security-scan-aggregator":Nt,"stop/session-patterns":B,"stop/task-completion-check":Gt,"stop/calibration-persist":L,"stop/unified-dispatcher":Xt};function Ro(t){return Zt[t]}function Oo(){return Object.keys(Zt)}export{xt as applyDecay,Kn as escapeRegex,pe as estimateTokenCount,Qn as getAdjustments,ts as getAgentSuccessRate,En as getCachedBranch,es as getCalibrationStats,qn as getField,Ro as getHook,gt as getLogDir,ie as getLogLevel,mt as getPluginRoot,l as getProjectDir,f as getSessionId,ns as hasMinimalCalibrationData,ke as hashPrompt,Zt as hooks,Rn as isBashInput,Dn as isEditInput,Hn as isReadInput,On as isWriteInput,Oo as listHooks,v as loadCalibrationData,o as logHook,Bn as logPermissionFeedback,Gn as normalizeCommand,Fn as outputAllowWithContext,Nn as outputBlock,Un as outputDeny,Mn as outputError,ae as outputPromptContext,Ln as outputPromptContextBudgeted,Pn as outputSilentAllow,p as outputSilentSuccess,Jn as outputWarning,ft as outputWithContext,Wn as readHookInput,Zn as recordOutcome,Y as saveCalibrationData,re as shouldLog};
//# sourceMappingURL=stop.mjs.map
