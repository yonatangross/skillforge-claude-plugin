"""
Distributed Lock Template
Generated by OrchestKit distributed-locks skill

Provides Redis and PostgreSQL lock implementations.

Requirements:
    pip install uuid-utils  # For UUIDv7 (recommended)
    # Or use uuid4 fallback (less optimal for time-ordering)
"""

from contextlib import asynccontextmanager
from dataclasses import dataclass
from datetime import timedelta
from typing import AsyncGenerator, Protocol
from uuid import uuid4
import asyncio
import hashlib

# UUIDv7 preferred for time-ordered IDs (better for indexes)
# Falls back to uuid4 if uuid-utils not installed
try:
    from uuid_utils import uuid7
except ImportError:
    # Fallback: uuid4 works but isn't time-ordered
    uuid7 = uuid4  # type: ignore[assignment,misc]


# =============================================================================
# Lock Protocol
# =============================================================================


class DistributedLock(Protocol):
    """Protocol for distributed locks."""

    async def acquire(self, timeout: timedelta | None = None) -> bool:
        """Acquire lock, optionally with timeout."""
        ...

    async def release(self) -> bool:
        """Release lock."""
        ...

    async def extend(self, ttl: timedelta) -> bool:
        """Extend lock TTL."""
        ...

    @property
    def is_acquired(self) -> bool:
        """Check if lock is currently held."""
        ...


# =============================================================================
# Lock Configuration
# =============================================================================


@dataclass
class LockConfig:
    """Configuration for distributed locks."""

    ttl: timedelta = timedelta(seconds=30)
    retry_count: int = 3
    retry_delay: timedelta = timedelta(milliseconds=100)
    extend_interval: timedelta | None = None  # Auto-extend if set

    def __post_init__(self):
        if self.extend_interval and self.extend_interval >= self.ttl:
            raise ValueError("extend_interval must be less than ttl")


# =============================================================================
# Redis Lock Implementation
# =============================================================================


class RedisDistributedLock(DistributedLock):
    """Redis-based distributed lock with Lua scripts.

    TODO: Replace `redis_client` type with your Redis client type.
    """

    ACQUIRE_SCRIPT = """
    if redis.call('set', KEYS[1], ARGV[1], 'NX', 'PX', ARGV[2]) then
        return 1
    end
    return 0
    """

    RELEASE_SCRIPT = """
    if redis.call('get', KEYS[1]) == ARGV[1] then
        return redis.call('del', KEYS[1])
    end
    return 0
    """

    EXTEND_SCRIPT = """
    if redis.call('get', KEYS[1]) == ARGV[1] then
        return redis.call('pexpire', KEYS[1], ARGV[2])
    end
    return 0
    """

    def __init__(
        self,
        redis_client,  # redis.asyncio.Redis
        name: str,
        config: LockConfig | None = None,
    ):
        self._client = redis_client
        self._name = f"lock:{name}"
        self._config = config or LockConfig()
        self._owner_id = str(uuid7())
        self._acquired = False
        self._extend_task: asyncio.Task | None = None

    async def acquire(self, timeout: timedelta | None = None) -> bool:
        """Acquire lock with retry logic."""
        ttl_ms = int(self._config.ttl.total_seconds() * 1000)
        deadline = (
            asyncio.get_event_loop().time() + timeout.total_seconds()
            if timeout
            else None
        )

        for attempt in range(self._config.retry_count):
            result = await self._client.eval(
                self.ACQUIRE_SCRIPT,
                1,
                self._name,
                self._owner_id,
                ttl_ms,
            )

            if result == 1:
                self._acquired = True
                self._start_auto_extend()
                return True

            if deadline and asyncio.get_event_loop().time() >= deadline:
                return False

            # Exponential backoff with jitter
            delay = self._config.retry_delay.total_seconds() * (2 ** attempt)
            jitter = delay * 0.1
            await asyncio.sleep(delay + jitter)

        return False

    async def release(self) -> bool:
        """Release lock if we own it."""
        self._stop_auto_extend()

        if not self._acquired:
            return False

        result = await self._client.eval(
            self.RELEASE_SCRIPT,
            1,
            self._name,
            self._owner_id,
        )

        if result == 1:
            self._acquired = False
            return True
        return False

    async def extend(self, ttl: timedelta | None = None) -> bool:
        """Extend lock TTL."""
        if not self._acquired:
            return False

        ttl_ms = int((ttl or self._config.ttl).total_seconds() * 1000)
        result = await self._client.eval(
            self.EXTEND_SCRIPT,
            1,
            self._name,
            self._owner_id,
            ttl_ms,
        )
        return result == 1

    @property
    def is_acquired(self) -> bool:
        return self._acquired

    def _start_auto_extend(self) -> None:
        """Start background task to auto-extend lock."""
        extend_interval = self._config.extend_interval
        if not extend_interval:
            return

        async def extend_loop():
            interval = extend_interval.total_seconds()
            while self._acquired:
                await asyncio.sleep(interval)
                if self._acquired:
                    await self.extend()

        self._extend_task = asyncio.create_task(extend_loop())

    def _stop_auto_extend(self) -> None:
        """Stop auto-extend background task."""
        if self._extend_task:
            self._extend_task.cancel()
            self._extend_task = None

    async def __aenter__(self) -> "RedisDistributedLock":
        acquired = await self.acquire(timeout=timedelta(seconds=10))
        if not acquired:
            raise LockError(f"Failed to acquire lock: {self._name}")
        return self

    async def __aexit__(self, _exc_type, _exc_val, _exc_tb) -> None:
        await self.release()


# =============================================================================
# PostgreSQL Advisory Lock Implementation
# =============================================================================


def string_to_lock_id(name: str) -> int:
    """Convert string to PostgreSQL bigint lock ID."""
    hash_bytes = hashlib.md5(name.encode()).digest()[:8]
    return int.from_bytes(hash_bytes, byteorder="big", signed=True)


class PostgresAdvisoryLock(DistributedLock):
    """PostgreSQL advisory lock.

    TODO: Replace session type with your SQLAlchemy AsyncSession.
    """

    def __init__(
        self,
        session,  # AsyncSession
        name: str,
        transaction_level: bool = False,
    ):
        self._session = session
        self._lock_id = string_to_lock_id(name)
        self._transaction_level = transaction_level
        self._acquired = False

    async def acquire(self, timeout: timedelta | None = None) -> bool:
        """Acquire advisory lock."""
        from sqlalchemy import text

        if self._transaction_level:
            func = "pg_advisory_xact_lock"
            try_func = "pg_try_advisory_xact_lock"
        else:
            func = "pg_advisory_lock"
            try_func = "pg_try_advisory_lock"

        if timeout is None:
            # Non-blocking attempt
            result = await self._session.execute(
                text(f"SELECT {try_func}(:lock_id)"),
                {"lock_id": self._lock_id},
            )
            self._acquired = bool(result.scalar())
        else:
            # Blocking with statement timeout
            timeout_ms = int(timeout.total_seconds() * 1000) if timeout else 10000
            await self._session.execute(
                text(f"SET LOCAL statement_timeout = {timeout_ms}")
            )
            try:
                await self._session.execute(
                    text(f"SELECT {func}(:lock_id)"),
                    {"lock_id": self._lock_id},
                )
                self._acquired = True
            except Exception:
                self._acquired = False
            finally:
                await self._session.execute(
                    text("SET LOCAL statement_timeout = 0")
                )

        return self._acquired

    async def release(self) -> bool:
        """Release advisory lock (session-level only)."""
        if self._transaction_level:
            # Transaction-level locks auto-release
            return True

        if not self._acquired:
            return False

        from sqlalchemy import text

        result = await self._session.execute(
            text("SELECT pg_advisory_unlock(:lock_id)"),
            {"lock_id": self._lock_id},
        )
        released = result.scalar()
        if released:
            self._acquired = False
        return released

    async def extend(self, _ttl: timedelta) -> bool:
        """Advisory locks don't expire - no-op."""
        return self._acquired

    @property
    def is_acquired(self) -> bool:
        return self._acquired

    async def __aenter__(self) -> "PostgresAdvisoryLock":
        acquired = await self.acquire(timeout=timedelta(seconds=10))
        if not acquired:
            raise LockError(f"Failed to acquire advisory lock: {self._lock_id}")
        return self

    async def __aexit__(self, _exc_type, _exc_val, _exc_tb) -> None:
        await self.release()


# =============================================================================
# Exceptions
# =============================================================================


class LockError(Exception):
    """Base exception for lock errors."""

    pass


class LockAcquisitionError(LockError):
    """Failed to acquire lock."""

    pass


class LockReleaseError(LockError):
    """Failed to release lock."""

    pass


# =============================================================================
# Factory Function
# =============================================================================


@asynccontextmanager
async def distributed_lock(
    backend: str,
    name: str,
    client,  # Redis client or SQLAlchemy session
    config: LockConfig | None = None,
) -> AsyncGenerator[DistributedLock, None]:
    """Factory for distributed locks.

    Args:
        backend: "redis" or "postgres"
        name: Lock name/resource identifier
        client: Redis client or SQLAlchemy AsyncSession
        config: Lock configuration

    Usage:
        async with distributed_lock("redis", "my-resource", redis_client) as lock:
            # Critical section
            ...
    """
    if backend == "redis":
        lock = RedisDistributedLock(client, name, config)
    elif backend == "postgres":
        lock = PostgresAdvisoryLock(client, name)
    else:
        raise ValueError(f"Unknown backend: {backend}")

    acquired = await lock.acquire(timeout=timedelta(seconds=10))
    if not acquired:
        raise LockAcquisitionError(f"Failed to acquire {backend} lock: {name}")

    try:
        yield lock
    finally:
        await lock.release()
