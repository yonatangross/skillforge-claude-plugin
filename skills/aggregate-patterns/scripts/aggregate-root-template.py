"""
Aggregate Root Template
Generated by OrchestKit aggregate-patterns skill

Aggregate roots enforce invariants and emit domain events.
Uses UUIDv7 for time-ordered IDs (PostgreSQL 18 compatible).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from decimal import Decimal
from typing import Protocol
from uuid import UUID

from uuid_utils import uuid7


# =============================================================================
# Domain Events
# =============================================================================


@dataclass(frozen=True)
class DomainEvent:
    """Base domain event with UUIDv7."""

    event_id: UUID = field(default_factory=uuid7)
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))


@dataclass(frozen=True)
class OrderCreated(DomainEvent):
    """Emitted when order is created."""

    order_id: UUID = field(default_factory=uuid7)
    customer_id: UUID = field(default_factory=uuid7)


@dataclass(frozen=True)
class OrderItemAdded(DomainEvent):
    """Emitted when item is added to order."""

    order_id: UUID = field(default_factory=uuid7)
    product_id: UUID = field(default_factory=uuid7)
    quantity: int = 0
    unit_price: Decimal = Decimal("0")


@dataclass(frozen=True)
class OrderPlaced(DomainEvent):
    """Emitted when order is placed."""

    order_id: UUID = field(default_factory=uuid7)
    customer_id: UUID = field(default_factory=uuid7)
    total: Decimal = Decimal("0")
    item_count: int = 0


# =============================================================================
# Value Objects
# =============================================================================


@dataclass(frozen=True)
class Money:
    """Immutable money value object."""

    amount: Decimal
    currency: str = "USD"

    def add(self, other: "Money") -> "Money":
        if self.currency != other.currency:
            raise ValueError("Currency mismatch")
        return Money(self.amount + other.amount, self.currency)

    def multiply(self, factor: int) -> "Money":
        return Money(self.amount * factor, self.currency)

    @classmethod
    def zero(cls, currency: str = "USD") -> "Money":
        return cls(Decimal("0"), currency)


# =============================================================================
# Child Entity (owned by aggregate)
# =============================================================================


@dataclass
class OrderItem:
    """Order item - owned by Order aggregate.

    Not an aggregate root - accessed only through Order.
    """

    id: UUID = field(default_factory=uuid7)
    product_id: UUID = field(default_factory=uuid7)
    product_name: str = ""  # Snapshot at order time
    unit_price: Money = field(default_factory=Money.zero)
    quantity: int = 1

    @property
    def subtotal(self) -> Money:
        """Calculate item subtotal."""
        return self.unit_price.multiply(self.quantity)

    def update_quantity(self, new_quantity: int) -> None:
        """Update quantity with validation."""
        if new_quantity < 1:
            raise ValueError("Quantity must be at least 1")
        if new_quantity > 100:
            raise ValueError("Quantity cannot exceed 100")
        self.quantity = new_quantity


# =============================================================================
# Aggregate Root
# =============================================================================


class InvariantViolationError(Exception):
    """Raised when aggregate invariant is violated."""

    pass


@dataclass
class Order:
    """Order aggregate root.

    Invariants:
    - Total must equal sum of item subtotals
    - Cannot place empty order
    - Cannot modify placed order
    - Maximum 50 items per order

    All modifications go through Order methods to enforce invariants.
    """

    # Identity (UUIDv7 for time-ordering)
    id: UUID = field(default_factory=uuid7)
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    # References to other aggregates (by ID only!)
    customer_id: UUID = field(default_factory=uuid7)

    # Owned entities
    items: list[OrderItem] = field(default_factory=list)

    # State
    status: str = "draft"
    _total: Money = field(default_factory=Money.zero, repr=False)

    # Domain events
    _events: list[DomainEvent] = field(default_factory=list, repr=False)

    # -------------------------------------------------------------------------
    # Factory Methods
    # -------------------------------------------------------------------------

    @classmethod
    def create(cls, customer_id: UUID) -> "Order":
        """Factory method to create order with proper initialization."""
        order = cls(customer_id=customer_id)
        order._events.append(OrderCreated(
            order_id=order.id,
            customer_id=customer_id,
        ))
        return order

    # -------------------------------------------------------------------------
    # Properties
    # -------------------------------------------------------------------------

    @property
    def total(self) -> Money:
        """Order total (calculated from items)."""
        return self._total

    @property
    def item_count(self) -> int:
        """Number of items in order."""
        return len(self.items)

    @property
    def is_draft(self) -> bool:
        return self.status == "draft"

    @property
    def is_placed(self) -> bool:
        return self.status == "placed"

    # -------------------------------------------------------------------------
    # Commands (state modifications through methods only)
    # -------------------------------------------------------------------------

    def add_item(
        self,
        product_id: UUID,
        product_name: str,
        unit_price: Money,
        quantity: int = 1,
    ) -> OrderItem:
        """Add item to order.

        Enforces invariants:
        - Cannot modify non-draft orders
        - Maximum 50 items
        - Recalculates total
        """
        self._ensure_draft()
        self._ensure_max_items()

        item = OrderItem(
            product_id=product_id,
            product_name=product_name,
            unit_price=unit_price,
            quantity=quantity,
        )
        self.items.append(item)
        self._recalculate_total()
        self._touch()

        self._events.append(OrderItemAdded(
            order_id=self.id,
            product_id=product_id,
            quantity=quantity,
            unit_price=unit_price.amount,
        ))

        return item

    def remove_item(self, item_id: UUID) -> None:
        """Remove item from order."""
        self._ensure_draft()

        self.items = [i for i in self.items if i.id != item_id]
        self._recalculate_total()
        self._touch()

    def update_item_quantity(self, item_id: UUID, quantity: int) -> None:
        """Update item quantity."""
        self._ensure_draft()

        for item in self.items:
            if item.id == item_id:
                item.update_quantity(quantity)
                self._recalculate_total()
                self._touch()
                return

        raise ValueError(f"Item {item_id} not found")

    def place(self) -> None:
        """Place the order.

        Enforces invariants:
        - Must be draft
        - Must have items
        - Emits OrderPlaced event for downstream processing
        """
        self._ensure_draft()

        if not self.items:
            raise InvariantViolationError("Cannot place empty order")

        self.status = "placed"
        self._touch()

        self._events.append(OrderPlaced(
            order_id=self.id,
            customer_id=self.customer_id,
            total=self._total.amount,
            item_count=len(self.items),
        ))

    # -------------------------------------------------------------------------
    # Event Collection
    # -------------------------------------------------------------------------

    def collect_events(self) -> list[DomainEvent]:
        """Collect and clear pending domain events."""
        events = self._events.copy()
        self._events.clear()
        return events

    # -------------------------------------------------------------------------
    # Invariant Enforcement (private)
    # -------------------------------------------------------------------------

    def _ensure_draft(self) -> None:
        """Ensure order is in draft status."""
        if not self.is_draft:
            raise InvariantViolationError(
                f"Cannot modify order in '{self.status}' status"
            )

    def _ensure_max_items(self) -> None:
        """Ensure order doesn't exceed max items."""
        if len(self.items) >= 50:
            raise InvariantViolationError("Order cannot have more than 50 items")

    def _recalculate_total(self) -> None:
        """Recalculate total from items (maintains total invariant)."""
        total = Money.zero(self._total.currency)
        for item in self.items:
            total = total.add(item.subtotal)
        self._total = total

    def _touch(self) -> None:
        """Update timestamp."""
        self.updated_at = datetime.now(UTC)


# =============================================================================
# Repository Protocol
# =============================================================================


class OrderRepository(Protocol):
    """Repository for Order aggregate."""

    async def get(self, order_id: UUID) -> Order | None: ...
    async def save(self, order: Order) -> None: ...
    async def delete(self, order_id: UUID) -> None: ...


# =============================================================================
# PostgreSQL 18 Migration
# =============================================================================

"""
-- Alembic migration for Order aggregate with UUIDv7

def upgrade():
    op.execute('''
        CREATE TABLE orders (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
            customer_id UUID NOT NULL,
            status TEXT NOT NULL DEFAULT 'draft',
            total_amount DECIMAL(12, 2) NOT NULL DEFAULT 0,
            total_currency TEXT NOT NULL DEFAULT 'USD',
            created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
        );

        CREATE TABLE order_items (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
            order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
            product_id UUID NOT NULL,
            product_name TEXT NOT NULL,
            unit_price_amount DECIMAL(12, 2) NOT NULL,
            unit_price_currency TEXT NOT NULL DEFAULT 'USD',
            quantity INTEGER NOT NULL DEFAULT 1
        );

        CREATE INDEX idx_orders_customer ON orders(customer_id);
        CREATE INDEX idx_orders_status ON orders(status);
        CREATE INDEX idx_order_items_order ON order_items(order_id);
    ''')
"""
