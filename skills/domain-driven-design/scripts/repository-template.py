"""
Repository Pattern Template
Generated by OrchestKit domain-driven-design skill

SQLAlchemy 2.0 async implementation with UUIDv7 support.
"""

from abc import abstractmethod
from typing import Protocol, TypeVar
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession


# =============================================================================
# Domain Entity (import from your domain layer)
# =============================================================================

# from app.domain.entities import MyEntity


class MyEntity:
    """Placeholder - replace with your actual entity."""

    id: UUID
    name: str
    status: str


# =============================================================================
# Repository Protocol (Domain Layer)
# =============================================================================

T = TypeVar("T")


class MyEntityRepository(Protocol):
    """Repository protocol for MyEntity.

    Define in domain layer - no infrastructure dependencies.
    """

    @abstractmethod
    async def get(self, id: UUID) -> MyEntity | None:
        """Get entity by ID, returns None if not found."""
        ...

    @abstractmethod
    async def get_or_raise(self, id: UUID) -> MyEntity:
        """Get entity by ID, raises NotFoundError if not found."""
        ...

    @abstractmethod
    async def add(self, entity: MyEntity) -> MyEntity:
        """Add new entity."""
        ...

    @abstractmethod
    async def update(self, entity: MyEntity) -> MyEntity:
        """Update existing entity."""
        ...

    @abstractmethod
    async def delete(self, id: UUID) -> None:
        """Delete entity by ID."""
        ...

    # Domain-specific queries
    @abstractmethod
    async def find_by_name(self, name: str) -> MyEntity | None:
        """Find entity by name."""
        ...

    @abstractmethod
    async def find_active(self, limit: int = 100) -> list[MyEntity]:
        """Find all active entities."""
        ...


# =============================================================================
# SQLAlchemy Model (Infrastructure Layer)
# =============================================================================

from sqlalchemy import String
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    """SQLAlchemy declarative base."""

    pass


class MyEntityModel(Base):
    """SQLAlchemy model for MyEntity.

    Uses PostgreSQL 18 gen_random_uuid_v7() for ID generation.
    """

    __tablename__ = "my_entities"

    # UUIDv7 generated by PostgreSQL 18
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        server_default="gen_random_uuid_v7()",
    )
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    status: Mapped[str] = mapped_column(String(50), nullable=False, default="pending")


# =============================================================================
# Repository Implementation (Infrastructure Layer)
# =============================================================================


class EntityNotFoundError(Exception):
    """Raised when entity is not found."""

    def __init__(self, entity_type: str, entity_id: UUID):
        self.entity_type = entity_type
        self.entity_id = entity_id
        super().__init__(f"{entity_type} with id {entity_id} not found")


class SQLAlchemyMyEntityRepository(MyEntityRepository):
    """SQLAlchemy implementation of MyEntityRepository.

    Handles mapping between domain entities and ORM models.
    """

    def __init__(self, session: AsyncSession):
        self._session = session

    async def get(self, id: UUID) -> MyEntity | None:
        """Get entity by ID."""
        model = await self._session.get(MyEntityModel, id)
        return self._to_entity(model) if model else None

    async def get_or_raise(self, id: UUID) -> MyEntity:
        """Get entity by ID, raises if not found."""
        entity = await self.get(id)
        if not entity:
            raise EntityNotFoundError("MyEntity", id)
        return entity

    async def add(self, entity: MyEntity) -> MyEntity:
        """Add new entity."""
        model = self._to_model(entity)
        self._session.add(model)
        await self._session.flush()  # Get DB-generated values
        return self._to_entity(model)

    async def update(self, entity: MyEntity) -> MyEntity:
        """Update existing entity."""
        model = await self._session.get(MyEntityModel, entity.id)
        if not model:
            raise EntityNotFoundError("MyEntity", entity.id)

        # Update fields
        model.name = entity.name
        model.status = entity.status

        await self._session.flush()
        return entity

    async def delete(self, id: UUID) -> None:
        """Delete entity by ID."""
        model = await self._session.get(MyEntityModel, id)
        if model:
            await self._session.delete(model)
            await self._session.flush()

    async def find_by_name(self, name: str) -> MyEntity | None:
        """Find entity by name."""
        stmt = select(MyEntityModel).where(MyEntityModel.name == name)
        result = await self._session.execute(stmt)
        model = result.scalar_one_or_none()
        return self._to_entity(model) if model else None

    async def find_active(self, limit: int = 100) -> list[MyEntity]:
        """Find all active entities."""
        stmt = (
            select(MyEntityModel)
            .where(MyEntityModel.status == "active")
            .order_by(MyEntityModel.id)  # UUIDv7 = time-ordered
            .limit(limit)
        )
        result = await self._session.execute(stmt)
        return [self._to_entity(m) for m in result.scalars()]

    # -------------------------------------------------------------------------
    # Mapping Methods
    # -------------------------------------------------------------------------

    def _to_entity(self, model: MyEntityModel) -> MyEntity:
        """Map ORM model to domain entity."""
        entity = MyEntity()
        entity.id = model.id
        entity.name = model.name
        entity.status = model.status
        return entity

    def _to_model(self, entity: MyEntity) -> MyEntityModel:
        """Map domain entity to ORM model."""
        return MyEntityModel(
            id=entity.id,
            name=entity.name,
            status=entity.status,
        )


# =============================================================================
# Unit of Work Pattern
# =============================================================================


class UnitOfWork:
    """Coordinates repositories and transactions.

    Usage:
        async with unit_of_work(session_factory) as uow:
            entity = await uow.my_entities.get(id)
            entity.activate()
            await uow.my_entities.update(entity)
            # Auto-commits on exit
    """

    def __init__(self, session: AsyncSession):
        self._session = session
        self.my_entities = SQLAlchemyMyEntityRepository(session)
        # Add more repositories as needed
        # self.orders = SQLAlchemyOrderRepository(session)

    async def commit(self) -> None:
        """Commit transaction."""
        await self._session.commit()

    async def rollback(self) -> None:
        """Rollback transaction."""
        await self._session.rollback()


# Context manager for UoW
from contextlib import asynccontextmanager
from typing import AsyncGenerator


@asynccontextmanager
async def unit_of_work(
    session_factory,
) -> AsyncGenerator[UnitOfWork, None]:
    """Create unit of work with automatic commit/rollback."""
    async with session_factory() as session:
        uow = UnitOfWork(session)
        try:
            yield uow
            await uow.commit()
        except Exception:
            await uow.rollback()
            raise
