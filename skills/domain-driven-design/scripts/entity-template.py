"""
Domain Entity Template
Generated by OrchestKit domain-driven-design skill

Uses UUIDv7 for time-ordered IDs (PostgreSQL 18 compatible).
"""

from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Self
from uuid import UUID

from uuid_utils import uuid7


# =============================================================================
# Domain Events (define for this entity)
# =============================================================================


@dataclass(frozen=True)
class DomainEvent:
    """Base domain event."""

    event_id: UUID = field(default_factory=uuid7)
    occurred_at: datetime = field(default_factory=lambda: datetime.now(UTC))


@dataclass(frozen=True)
class EntityCreated(DomainEvent):
    """Emitted when entity is created."""

    entity_id: UUID = field(default_factory=uuid7)


@dataclass(frozen=True)
class EntityUpdated(DomainEvent):
    """Emitted when entity is updated."""

    entity_id: UUID = field(default_factory=uuid7)
    field_name: str = ""
    old_value: str = ""
    new_value: str = ""


# =============================================================================
# Base Entity
# =============================================================================


@dataclass
class Entity:
    """Base entity with UUIDv7 identity and event collection.

    PostgreSQL 18: Use gen_random_uuid_v7() for DB-side ID generation.
    """

    id: UUID = field(default_factory=uuid7)
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    _domain_events: list[DomainEvent] = field(default_factory=list, repr=False)

    def __eq__(self, other: object) -> bool:
        """Entities are equal by identity (ID), not attributes."""
        if not isinstance(other, Entity):
            return NotImplemented
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)

    def add_event(self, event: DomainEvent) -> None:
        """Register domain event for later publishing."""
        self._domain_events.append(event)

    def collect_events(self) -> list[DomainEvent]:
        """Collect and clear pending domain events."""
        events = self._domain_events.copy()
        self._domain_events.clear()
        return events

    def _touch(self) -> None:
        """Update the updated_at timestamp."""
        self.updated_at = datetime.now(UTC)


# =============================================================================
# Your Entity (customize below)
# =============================================================================


@dataclass
class MyEntity(Entity):
    """TODO: Replace with your entity name and fields.

    Example: User, Order, Product, etc.
    """

    # TODO: Add your entity fields
    name: str = ""
    status: str = "active"
    # email: Email = field(default_factory=lambda: Email("default@example.com"))

    # -------------------------------------------------------------------------
    # Factory Methods
    # -------------------------------------------------------------------------

    @classmethod
    def create(cls, name: str) -> Self:
        """Factory method to create entity with proper initialization."""
        entity = cls(name=name, status="pending")
        entity.add_event(EntityCreated(entity_id=entity.id))
        return entity

    # -------------------------------------------------------------------------
    # Business Methods (encapsulate state changes)
    # -------------------------------------------------------------------------

    def activate(self) -> Self:
        """Activate this entity."""
        if self.status == "active":
            raise ValueError("Entity already active")

        old_status = self.status
        self.status = "active"
        self._touch()

        self.add_event(EntityUpdated(
            entity_id=self.id,
            field_name="status",
            old_value=old_status,
            new_value="active",
        ))
        return self

    def deactivate(self) -> Self:
        """Deactivate this entity."""
        if self.status == "inactive":
            raise ValueError("Entity already inactive")

        old_status = self.status
        self.status = "inactive"
        self._touch()

        self.add_event(EntityUpdated(
            entity_id=self.id,
            field_name="status",
            old_value=old_status,
            new_value="inactive",
        ))
        return self

    def rename(self, new_name: str) -> Self:
        """Change entity name."""
        if not new_name or not new_name.strip():
            raise ValueError("Name cannot be empty")

        old_name = self.name
        self.name = new_name.strip()
        self._touch()

        self.add_event(EntityUpdated(
            entity_id=self.id,
            field_name="name",
            old_value=old_name,
            new_value=self.name,
        ))
        return self

    # -------------------------------------------------------------------------
    # Query Methods (no side effects)
    # -------------------------------------------------------------------------

    @property
    def is_active(self) -> bool:
        """Check if entity is active."""
        return self.status == "active"


# =============================================================================
# PostgreSQL 18 Migration
# =============================================================================

"""
-- Alembic migration for PostgreSQL 18 with UUIDv7

def upgrade():
    op.execute('''
        CREATE TABLE my_entities (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid_v7(),
            name TEXT NOT NULL,
            status TEXT NOT NULL DEFAULT 'pending',
            created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
            updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
        );

        -- Index on status for filtering
        CREATE INDEX idx_my_entities_status ON my_entities(status);

        -- UUIDv7 is time-ordered, so id index is also ~created_at index
    ''')

def downgrade():
    op.drop_table('my_entities')
"""
