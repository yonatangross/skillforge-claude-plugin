"""
Value Object Templates
Generated by OrchestKit domain-driven-design skill

Value objects are immutable, compared by attributes, and self-validating.
"""

from dataclasses import dataclass
from decimal import Decimal
import re


# =============================================================================
# Email Value Object
# =============================================================================


@dataclass(frozen=True)  # frozen=True makes it immutable
class Email:
    """Email address value object with validation.

    Immutable: Changes create new instances.
    Equality: Compared by value, not identity.
    """

    value: str

    def __post_init__(self) -> None:
        """Validate on construction."""
        if not self._is_valid(self.value):
            raise ValueError(f"Invalid email format: {self.value}")

    @staticmethod
    def _is_valid(email: str) -> bool:
        """Validate email format."""
        pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
        return bool(re.match(pattern, email))

    @property
    def domain(self) -> str:
        """Extract email domain."""
        return self.value.split("@")[1]

    @property
    def local_part(self) -> str:
        """Extract local part (before @)."""
        return self.value.split("@")[0]

    def __str__(self) -> str:
        return self.value


# =============================================================================
# Money Value Object
# =============================================================================


@dataclass(frozen=True)
class Money:
    """Money value object with currency.

    Uses Decimal for precision. Immutable operations return new instances.
    """

    amount: Decimal
    currency: str = "USD"

    def __post_init__(self) -> None:
        """Validate on construction."""
        # Use object.__setattr__ for frozen dataclass validation
        if not isinstance(self.amount, Decimal):
            object.__setattr__(self, "amount", Decimal(str(self.amount)))
        if self.amount < 0:
            raise ValueError("Money amount cannot be negative")
        if len(self.currency) != 3:
            raise ValueError("Currency must be 3-letter ISO code")

    def add(self, other: "Money") -> "Money":
        """Add money amounts (same currency only)."""
        if self.currency != other.currency:
            raise ValueError(
                f"Cannot add {self.currency} and {other.currency}"
            )
        return Money(self.amount + other.amount, self.currency)

    def subtract(self, other: "Money") -> "Money":
        """Subtract money amounts (same currency only)."""
        if self.currency != other.currency:
            raise ValueError(
                f"Cannot subtract {self.currency} and {other.currency}"
            )
        result = self.amount - other.amount
        if result < 0:
            raise ValueError("Result would be negative")
        return Money(result, self.currency)

    def multiply(self, factor: int | float | Decimal) -> "Money":
        """Multiply by a factor."""
        return Money(self.amount * Decimal(str(factor)), self.currency)

    def is_zero(self) -> bool:
        """Check if amount is zero."""
        return self.amount == Decimal("0")

    def __str__(self) -> str:
        return f"{self.currency} {self.amount:.2f}"

    def __repr__(self) -> str:
        return f"Money({self.amount!r}, {self.currency!r})"


# =============================================================================
# Address Value Object
# =============================================================================


@dataclass(frozen=True)
class Address:
    """Postal address value object."""

    street: str
    city: str
    state: str
    postal_code: str
    country: str = "US"

    def __post_init__(self) -> None:
        """Validate all fields are provided."""
        required = ["street", "city", "state", "postal_code", "country"]
        for field_name in required:
            value = getattr(self, field_name)
            if not value or not value.strip():
                raise ValueError(f"Address {field_name} is required")

    def format_single_line(self) -> str:
        """Format as single line."""
        return f"{self.street}, {self.city}, {self.state} {self.postal_code}, {self.country}"

    def format_multiline(self) -> str:
        """Format as multiple lines."""
        return f"{self.street}\n{self.city}, {self.state} {self.postal_code}\n{self.country}"


# =============================================================================
# DateRange Value Object
# =============================================================================


@dataclass(frozen=True)
class DateRange:
    """Date range value object."""

    from datetime import date

    start: date
    end: date

    def __post_init__(self) -> None:
        """Validate start <= end."""
        if self.start > self.end:
            raise ValueError("Start date must be before or equal to end date")

    @property
    def days(self) -> int:
        """Number of days in range (inclusive)."""
        return (self.end - self.start).days + 1

    def contains(self, date: "DateRange.date") -> bool:
        """Check if date is within range."""
        return self.start <= date <= self.end

    def overlaps(self, other: "DateRange") -> bool:
        """Check if ranges overlap."""
        return self.start <= other.end and other.start <= self.end


# =============================================================================
# Percentage Value Object
# =============================================================================


@dataclass(frozen=True)
class Percentage:
    """Percentage value object (0-100)."""

    value: Decimal

    def __post_init__(self) -> None:
        """Validate 0-100 range."""
        if not isinstance(self.value, Decimal):
            object.__setattr__(self, "value", Decimal(str(self.value)))
        if not (0 <= self.value <= 100):
            raise ValueError("Percentage must be between 0 and 100")

    def of(self, amount: Money) -> Money:
        """Calculate percentage of money amount."""
        return amount.multiply(self.value / 100)

    def __str__(self) -> str:
        return f"{self.value}%"


# =============================================================================
# Custom Value Object Template
# =============================================================================


@dataclass(frozen=True)
class MyValueObject:
    """TODO: Replace with your value object.

    Guidelines:
    1. Use frozen=True for immutability
    2. Validate in __post_init__
    3. Operations return new instances (never mutate)
    4. Override __str__ for display
    """

    # TODO: Add your fields
    field1: str
    field2: int = 0

    def __post_init__(self) -> None:
        """Validate on construction."""
        if not self.field1:
            raise ValueError("field1 is required")
        # Add more validation...

    def with_field2(self, new_value: int) -> "MyValueObject":
        """Return new instance with updated field2."""
        return MyValueObject(field1=self.field1, field2=new_value)

    def __str__(self) -> str:
        return f"{self.field1}:{self.field2}"
