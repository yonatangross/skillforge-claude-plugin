{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/orchestration-types.ts", "../src/lib/intent-classifier.ts", "../src/lib/orchestration-state.ts", "../src/lib/task-integration.ts", "../src/lib/retry-manager.ts", "../src/lib/calibration-engine.ts", "../src/lib/multi-agent-coordinator.ts", "../src/prompt/antipattern-detector.ts", "../src/prompt/antipattern-warning.ts", "../src/prompt/context-injector.ts", "../src/prompt/context-pruning-advisor.ts", "../src/prompt/memory-context.ts", "../src/prompt/satisfaction-detector.ts", "../src/prompt/skill-auto-suggest.ts", "../src/prompt/todo-enforcer.ts", "../src/prompt/agent-auto-suggest.ts", "../src/prompt/agent-orchestrator.ts", "../src/prompt/skill-injector.ts", "../src/prompt/pipeline-detector.ts", "../src/entries/prompt.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME || '/tmp'}/.claude/logs/ork`;\n  }\n  return `${getProjectDir()}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n * Read dynamically to support testing\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory\n * Read dynamically to support testing\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability, but we add\n * a defensive fallback to prevent hook crashes during edge cases.\n * Read dynamically to support testing.\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}-${Date.now()}`;\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Orchestration Types - Shared type definitions for Agent Orchestration Layer\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * These types support:\n * - Intent classification with hybrid scoring\n * - Agent and skill matching\n * - CC 2.1.16 Task system integration\n * - Outcome-based calibration\n * - Multi-agent coordination\n */\n\n// -----------------------------------------------------------------------------\n// Confidence Thresholds\n// -----------------------------------------------------------------------------\n\nexport const THRESHOLDS = {\n  /** Auto-dispatch agent without confirmation */\n  AUTO_DISPATCH: 85,\n  /** Auto-inject skill content */\n  SKILL_INJECT: 80,\n  /** Strong recommendation shown to user */\n  STRONG_RECOMMEND: 70,\n  /** Suggestion shown to user */\n  SUGGEST: 50,\n  /** Minimum confidence to consider */\n  MINIMUM: 40,\n} as const;\n\n// -----------------------------------------------------------------------------\n// Intent Classification Types\n// -----------------------------------------------------------------------------\n\n/** Signal types used in intent classification */\nexport type SignalType =\n  | 'keyword'         // Direct keyword match\n  | 'phrase'          // Multi-word phrase match\n  | 'context'         // Context continuity from history\n  | 'cooccurrence'    // Learned keyword co-occurrence\n  | 'negation'        // Detected negation reducing confidence\n  | 'boost'           // Calibration boost from successful outcomes\n  | 'penalty';        // Calibration penalty from failures\n\n/** Individual signal contributing to classification */\nexport interface IntentSignal {\n  type: SignalType;\n  source: string;       // What triggered this signal\n  weight: number;       // Weight contribution (0-100)\n  matched: string;      // What was matched in the prompt\n}\n\n/** Match result for an agent */\nexport interface AgentMatch {\n  agent: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Match result for a skill */\nexport interface SkillMatch {\n  skill: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Result from intent classification */\nexport interface ClassificationResult {\n  /** Matching agents sorted by confidence */\n  agents: AgentMatch[];\n  /** Matching skills sorted by confidence */\n  skills: SkillMatch[];\n  /** Primary detected intent category */\n  intent: string;\n  /** Highest confidence score across all matches */\n  confidence: number;\n  /** All signals used in classification */\n  signals: IntentSignal[];\n  /** Whether this should trigger auto-dispatch */\n  shouldAutoDispatch: boolean;\n  /** Whether skills should be auto-injected */\n  shouldInjectSkills: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Orchestration State Types\n// -----------------------------------------------------------------------------\n\n/** Action to take based on classification */\nexport type OrchestrationAction =\n  | 'auto-dispatch'    // Immediately spawn agent\n  | 'inject-skill'     // Auto-load skill content\n  | 'strong-recommend' // Show strong recommendation\n  | 'suggest'          // Show suggestion\n  | 'none';            // No action needed\n\n/** State for a dispatched agent */\nexport interface DispatchedAgent {\n  agent: string;\n  taskId?: string;     // CC 2.1.16 task ID if created\n  confidence: number;\n  dispatchedAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'retrying';\n  retryCount: number;\n  maxRetries: number;\n}\n\n/** Current orchestration session state */\nexport interface OrchestrationState {\n  sessionId: string;\n  /** Active dispatched agents */\n  activeAgents: DispatchedAgent[];\n  /** Skills currently injected */\n  injectedSkills: string[];\n  /** Recent prompts for context continuity */\n  promptHistory: string[];\n  /** Max prompts to keep in history */\n  maxHistorySize: number;\n  /** Last classification result */\n  lastClassification?: ClassificationResult;\n  /** Timestamp of last update */\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// CC 2.1.16 Task Integration Types\n// -----------------------------------------------------------------------------\n\n/** Metadata attached to tasks for orchestration */\nexport interface TaskMetadata {\n  /** Source of task creation */\n  source: 'orchestration' | 'user' | 'pipeline';\n  /** Agent that was dispatched */\n  dispatchedAgent?: string;\n  /** Classification confidence at dispatch time */\n  dispatchConfidence?: number;\n  /** Pipeline this task belongs to */\n  pipelineId?: string;\n  /** Step in pipeline sequence */\n  pipelineStep?: number;\n  /** Related skill names */\n  relatedSkills?: string[];\n  /** Signals that triggered dispatch */\n  dispatchSignals?: IntentSignal[];\n}\n\n/** Instruction to create a CC 2.1.16 task */\nexport interface TaskCreateInstruction {\n  subject: string;\n  description: string;\n  activeForm: string;\n  metadata: TaskMetadata;\n  /** Tasks this one is blocked by */\n  blockedBy?: string[];\n}\n\n/** Instruction to update a CC 2.1.16 task */\nexport interface TaskUpdateInstruction {\n  taskId: string;\n  status?: 'pending' | 'in_progress' | 'completed' | 'deleted';\n  addBlockedBy?: string[];\n  addBlocks?: string[];\n}\n\n// -----------------------------------------------------------------------------\n// Retry and Error Handling Types\n// -----------------------------------------------------------------------------\n\n/** Outcome of an agent execution */\nexport type AgentOutcome = 'success' | 'partial' | 'failure' | 'rejected';\n\n/** Decision on what to do after failure */\nexport interface RetryDecision {\n  shouldRetry: boolean;\n  retryCount: number;\n  maxRetries: number;\n  /** Alternative agent to suggest if giving up */\n  alternativeAgent?: string;\n  /** Reason for decision */\n  reason: string;\n  /** Delay before retry in ms */\n  delayMs?: number;\n}\n\n/** Record of an agent execution attempt */\nexport interface ExecutionAttempt {\n  agent: string;\n  taskId?: string;\n  attemptNumber: number;\n  startedAt: string;\n  completedAt?: string;\n  outcome?: AgentOutcome;\n  error?: string;\n  durationMs?: number;\n}\n\n// -----------------------------------------------------------------------------\n// Calibration Types\n// -----------------------------------------------------------------------------\n\n/** Record of a dispatched agent outcome for calibration */\nexport interface CalibrationRecord {\n  timestamp: string;\n  sessionId: string;\n  agent: string;\n  promptHash: string;        // Hash of triggering prompt\n  matchedKeywords: string[];\n  dispatchConfidence: number;\n  outcome: AgentOutcome;\n  durationMs?: number;\n  /** User feedback if any */\n  feedback?: 'positive' | 'negative' | 'neutral';\n}\n\n/** Learned adjustment for keyword/agent pairs */\nexport interface CalibrationAdjustment {\n  keyword: string;\n  agent: string;\n  /** Positive = boost, negative = penalty */\n  adjustment: number;\n  sampleCount: number;\n  lastUpdated: string;\n}\n\n/** Calibration data store */\nexport interface CalibrationData {\n  schemaVersion: string;\n  createdAt: string;\n  updatedAt: string;\n  records: CalibrationRecord[];\n  adjustments: CalibrationAdjustment[];\n  /** Summary stats for monitoring */\n  stats: {\n    totalDispatches: number;\n    successRate: number;\n    avgConfidence: number;\n    topAgents: Array<{ agent: string; count: number; successRate: number }>;\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Multi-Agent Pipeline Types\n// -----------------------------------------------------------------------------\n\n/** Known pipeline definitions */\nexport type PipelineType =\n  | 'product-thinking'\n  | 'full-stack-feature'\n  | 'ai-integration'\n  | 'security-audit'\n  | 'frontend-compliance'\n  | 'custom';\n\n/** Step in a multi-agent pipeline */\nexport interface PipelineStep {\n  agent: string;\n  description: string;\n  /** Task dependencies (step indices) */\n  dependsOn: number[];\n  /** Skills to inject for this step */\n  skills?: string[];\n  /** Estimated context tokens for this step */\n  estimatedTokens?: number;\n}\n\n/** Definition of a multi-agent pipeline */\nexport interface PipelineDefinition {\n  type: PipelineType;\n  name: string;\n  description: string;\n  /** Trigger patterns that activate this pipeline */\n  triggers: string[];\n  steps: PipelineStep[];\n  /** Total estimated tokens for full pipeline */\n  estimatedTotalTokens: number;\n}\n\n/** Active pipeline execution state */\nexport interface PipelineExecution {\n  pipelineId: string;\n  type: PipelineType;\n  startedAt: string;\n  /** Map of step index to task ID */\n  taskIds: Record<number, string>;\n  /** Current step being executed */\n  currentStep: number;\n  /** Completed steps */\n  completedSteps: number[];\n  status: 'running' | 'completed' | 'failed' | 'paused';\n}\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/** Orchestration configuration */\nexport interface OrchestrationConfig {\n  /** Enable auto-dispatch at high confidence */\n  enableAutoDispatch: boolean;\n  /** Enable skill auto-injection */\n  enableSkillInjection: boolean;\n  /** Maximum tokens for skill injection */\n  maxSkillInjectionTokens: number;\n  /** Enable outcome calibration */\n  enableCalibration: boolean;\n  /** Enable pipeline detection */\n  enablePipelines: boolean;\n  /** Custom confidence thresholds */\n  thresholds?: Partial<typeof THRESHOLDS>;\n  /** Max retries for failed agents */\n  maxRetries: number;\n  /** Retry delay base in ms */\n  retryDelayBaseMs: number;\n}\n\n/** Default orchestration configuration */\nexport const DEFAULT_CONFIG: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n", "/**\n * Intent Classifier - Hybrid semantic+keyword scoring engine\n * Issue #197: Agent Orchestration Layer\n *\n * Scoring weights:\n * - Keyword matching: 30%\n * - Phrase pattern matching: 25%\n * - Context continuity: 20%\n * - Co-occurrence learning: 15%\n * - Negation detection: 10%\n *\n * Target: 85%+ accuracy vs ~60% regex baseline\n */\n\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getPluginRoot, logHook } from './common.js';\nimport {\n  THRESHOLDS,\n  type AgentMatch,\n  type SkillMatch,\n  type IntentSignal,\n  type ClassificationResult,\n  type CalibrationAdjustment,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants and Weights\n// -----------------------------------------------------------------------------\n\n/** Scoring weights for signal types (must sum to 100) */\nconst SIGNAL_WEIGHTS = {\n  keyword: 30,\n  phrase: 25,\n  context: 20,\n  cooccurrence: 15,\n  negation: 10,\n} as const;\n\n/** Negation patterns that reduce confidence */\nconst NEGATION_PATTERNS = [\n  /\\b(not|don't|doesn't|won't|can't|shouldn't|avoid|without|except|unlike|instead of)\\s+/i,\n  /\\b(no|never|neither|nor)\\s+/i,\n];\n\n/** Context keywords that boost confidence when in history */\nconst CONTEXT_BOOST_KEYWORDS = [\n  'continue',\n  'also',\n  'additionally',\n  'and',\n  'then',\n  'next',\n  'follow up',\n  'after that',\n];\n\n// -----------------------------------------------------------------------------\n// Agent Index Cache\n// -----------------------------------------------------------------------------\n\ninterface AgentIndexEntry {\n  keywords: string[];\n  phrases: string[];\n  description: string;\n  skills?: string[];\n}\n\nlet agentIndex: Map<string, AgentIndexEntry> | null = null;\nlet agentIndexPath: string | null = null;\n\n/**\n * Build or get cached agent index from agents/ directory\n */\nfunction getAgentIndex(agentsDir: string): Map<string, AgentIndexEntry> {\n  // Return cache if path matches\n  if (agentIndex && agentIndexPath === agentsDir) {\n    return agentIndex;\n  }\n\n  const index = new Map<string, AgentIndexEntry>();\n\n  try {\n    const files = readdirSync(agentsDir).filter(f => f.endsWith('.md'));\n\n    for (const file of files) {\n      const agentName = file.replace('.md', '');\n      const filePath = join(agentsDir, file);\n\n      try {\n        const content = readFileSync(filePath, 'utf8');\n\n        // Extract frontmatter\n        const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n        if (!frontmatterMatch) continue;\n\n        const frontmatter = frontmatterMatch[1];\n\n        // Extract description\n        const descMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n        if (!descMatch) continue;\n\n        const description = descMatch[1].trim();\n\n        // Extract \"Activates for\" keywords\n        const activatesMatch = description.match(/Activates for\\s+(.+?)\\.?$/i);\n\n        // Also check for keywords in description before \"Activates for\"\n        const descPart = activatesMatch\n          ? description.slice(0, description.indexOf('Activates for')).trim()\n          : description;\n\n        let keywords: string[] = [];\n        let phrases: string[] = [];\n\n        if (activatesMatch) {\n          const keywordsStr = activatesMatch[1];\n          const rawKeywords = keywordsStr.split(/,\\s*/).map(k => k.trim().toLowerCase());\n\n          // Separate phrases (multi-word) from single keywords\n          for (const kw of rawKeywords) {\n            if (kw.includes(' ') || kw.includes('-')) {\n              phrases.push(kw);\n            } else if (kw.length > 1) {\n              keywords.push(kw);\n            }\n          }\n        }\n\n        // Extract skills from frontmatter\n        const skillsMatch = frontmatter.match(/^skills:\\s*\\n((?:\\s+-\\s+.+\\n?)+)/m);\n        let skills: string[] | undefined;\n        if (skillsMatch) {\n          skills = skillsMatch[1]\n            .split('\\n')\n            .map(l => l.replace(/^\\s*-\\s*/, '').trim())\n            .filter(Boolean);\n        }\n\n        if (keywords.length > 0 || phrases.length > 0) {\n          index.set(agentName, {\n            keywords,\n            phrases,\n            description: descPart || description.split('.')[0],\n            skills,\n          });\n        }\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  } catch {\n    logHook('intent-classifier', 'Could not read agents directory');\n  }\n\n  agentIndex = index;\n  agentIndexPath = agentsDir;\n  return index;\n}\n\n// -----------------------------------------------------------------------------\n// Skill Index Cache\n// -----------------------------------------------------------------------------\n\ninterface SkillIndexEntry {\n  keywords: string[];\n  description: string;\n}\n\nlet skillIndex: Map<string, SkillIndexEntry> | null = null;\nlet skillIndexPath: string | null = null;\n\n/**\n * Build or get cached skill index from skills/ directory\n */\nfunction getSkillIndex(skillsDir: string): Map<string, SkillIndexEntry> {\n  if (skillIndex && skillIndexPath === skillsDir) {\n    return skillIndex;\n  }\n\n  const index = new Map<string, SkillIndexEntry>();\n\n  try {\n    const dirs = readdirSync(skillsDir, { withFileTypes: true })\n      .filter(d => d.isDirectory())\n      .map(d => d.name);\n\n    for (const skillName of dirs) {\n      const skillFile = join(skillsDir, skillName, 'SKILL.md');\n\n      if (!existsSync(skillFile)) continue;\n\n      try {\n        const content = readFileSync(skillFile, 'utf8');\n\n        // Extract frontmatter\n        const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n        if (!frontmatterMatch) continue;\n\n        const frontmatter = frontmatterMatch[1];\n\n        // Extract description\n        const descMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n        const description = descMatch ? descMatch[1].trim() : '';\n\n        // Extract tags as keywords\n        const tagsMatch = frontmatter.match(/^tags:\\s*\\[([^\\]]+)\\]/m);\n        let keywords: string[] = [];\n\n        if (tagsMatch) {\n          keywords = tagsMatch[1]\n            .split(',')\n            .map(t => t.trim().toLowerCase().replace(/[\"']/g, ''))\n            .filter(t => t.length > 1);\n        }\n\n        // Also extract keywords from description\n        const descKeywords = description\n          .toLowerCase()\n          .split(/\\s+/)\n          .filter(w => w.length > 4)\n          .slice(0, 5);\n\n        keywords = [...new Set([...keywords, ...descKeywords])];\n\n        if (keywords.length > 0 || description) {\n          index.set(skillName, { keywords, description });\n        }\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  } catch {\n    logHook('intent-classifier', 'Could not read skills directory');\n  }\n\n  skillIndex = index;\n  skillIndexPath = skillsDir;\n  return index;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate keyword match score for an agent\n */\nfunction calculateKeywordScore(\n  promptLower: string,\n  keywords: string[]\n): { score: number; matched: string[]; signals: IntentSignal[] } {\n  let score = 0;\n  const matched: string[] = [];\n  const signals: IntentSignal[] = [];\n\n  for (const keyword of keywords) {\n    // Check word boundary match\n    const regex = new RegExp(`\\\\b${keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n    if (regex.test(promptLower)) {\n      const weight = keyword.length > 5 ? 25 : 20; // Longer keywords are more specific\n      score += weight;\n      matched.push(keyword);\n      signals.push({\n        type: 'keyword',\n        source: 'keyword-match',\n        weight,\n        matched: keyword,\n      });\n    }\n  }\n\n  // Normalize to percentage of max possible\n  const maxScore = keywords.length * 25;\n  return {\n    score: maxScore > 0 ? Math.min((score / maxScore) * 100, 100) : 0,\n    matched,\n    signals,\n  };\n}\n\n/**\n * Calculate phrase match score (multi-word patterns)\n */\nfunction calculatePhraseScore(\n  promptLower: string,\n  phrases: string[]\n): { score: number; matched: string[]; signals: IntentSignal[] } {\n  let score = 0;\n  const matched: string[] = [];\n  const signals: IntentSignal[] = [];\n\n  for (const phrase of phrases) {\n    if (promptLower.includes(phrase)) {\n      const weight = phrase.split(/\\s+/).length * 15; // More words = higher weight\n      score += weight;\n      matched.push(phrase);\n      signals.push({\n        type: 'phrase',\n        source: 'phrase-match',\n        weight,\n        matched: phrase,\n      });\n    }\n  }\n\n  // Normalize to percentage of max possible\n  const maxScore = phrases.length * 45; // Assume avg 3 words per phrase\n  return {\n    score: maxScore > 0 ? Math.min((score / maxScore) * 100, 100) : 0,\n    matched,\n    signals,\n  };\n}\n\n/**\n * Calculate context continuity score from prompt history\n */\nfunction calculateContextScore(\n  promptLower: string,\n  keywords: string[],\n  history: string[]\n): { score: number; signals: IntentSignal[] } {\n  if (history.length === 0) {\n    return { score: 0, signals: [] };\n  }\n\n  const signals: IntentSignal[] = [];\n  let score = 0;\n\n  // Check for continuation keywords\n  for (const continuationWord of CONTEXT_BOOST_KEYWORDS) {\n    if (promptLower.includes(continuationWord)) {\n      score += 15;\n      signals.push({\n        type: 'context',\n        source: 'continuation-keyword',\n        weight: 15,\n        matched: continuationWord,\n      });\n      break; // Only count once\n    }\n  }\n\n  // Check if agent keywords appeared in recent history\n  const recentHistory = history.slice(-3).join(' ').toLowerCase();\n  for (const keyword of keywords.slice(0, 5)) {\n    if (recentHistory.includes(keyword)) {\n      score += 20;\n      signals.push({\n        type: 'context',\n        source: 'history-keyword',\n        weight: 20,\n        matched: keyword,\n      });\n    }\n  }\n\n  return { score: Math.min(score, 100), signals };\n}\n\n/**\n * Calculate negation penalty\n */\nfunction calculateNegationPenalty(prompt: string): { penalty: number; signals: IntentSignal[] } {\n  const signals: IntentSignal[] = [];\n  let penalty = 0;\n\n  for (const pattern of NEGATION_PATTERNS) {\n    if (pattern.test(prompt)) {\n      penalty = 25; // Significant penalty for negation\n      signals.push({\n        type: 'negation',\n        source: 'negation-detected',\n        weight: -25,\n        matched: prompt.match(pattern)?.[0] || 'negation',\n      });\n      break;\n    }\n  }\n\n  return { penalty, signals };\n}\n\n/**\n * Apply calibration adjustments to score\n */\nfunction applyCalibration(\n  agentName: string,\n  matchedKeywords: string[],\n  adjustments: CalibrationAdjustment[]\n): { adjustment: number; signals: IntentSignal[] } {\n  if (adjustments.length === 0) {\n    return { adjustment: 0, signals: [] };\n  }\n\n  let totalAdjustment = 0;\n  const signals: IntentSignal[] = [];\n\n  for (const adj of adjustments) {\n    if (adj.agent === agentName && matchedKeywords.includes(adj.keyword)) {\n      totalAdjustment += adj.adjustment;\n      signals.push({\n        type: adj.adjustment > 0 ? 'boost' : 'penalty',\n        source: 'calibration',\n        weight: adj.adjustment,\n        matched: `${adj.keyword}:${agentName}`,\n      });\n    }\n  }\n\n  return { adjustment: totalAdjustment, signals };\n}\n\n/**\n * Classify a single agent match\n */\nfunction classifyAgentMatch(\n  promptLower: string,\n  agentName: string,\n  entry: AgentIndexEntry,\n  history: string[],\n  adjustments: CalibrationAdjustment[]\n): AgentMatch | null {\n  const allSignals: IntentSignal[] = [];\n  const allMatched: string[] = [];\n\n  // 1. Keyword matching (30% weight)\n  const keywordResult = calculateKeywordScore(promptLower, entry.keywords);\n  allSignals.push(...keywordResult.signals);\n  allMatched.push(...keywordResult.matched);\n\n  // 2. Phrase matching (25% weight)\n  const phraseResult = calculatePhraseScore(promptLower, entry.phrases);\n  allSignals.push(...phraseResult.signals);\n  allMatched.push(...phraseResult.matched);\n\n  // 3. Context continuity (20% weight)\n  const contextResult = calculateContextScore(promptLower, entry.keywords, history);\n  allSignals.push(...contextResult.signals);\n\n  // 4. Negation detection (10% weight as penalty)\n  const negationResult = calculateNegationPenalty(promptLower);\n  allSignals.push(...negationResult.signals);\n\n  // 5. Calibration adjustments (applies to final score)\n  const calibrationResult = applyCalibration(agentName, allMatched, adjustments);\n  allSignals.push(...calibrationResult.signals);\n\n  // Calculate weighted score\n  let score =\n    keywordResult.score * (SIGNAL_WEIGHTS.keyword / 100) +\n    phraseResult.score * (SIGNAL_WEIGHTS.phrase / 100) +\n    contextResult.score * (SIGNAL_WEIGHTS.context / 100);\n\n  // Apply negation penalty\n  score -= negationResult.penalty * (SIGNAL_WEIGHTS.negation / 100);\n\n  // Apply calibration adjustment (up to +/-15 points)\n  score += Math.max(-15, Math.min(15, calibrationResult.adjustment));\n\n  // Ensure score is within bounds\n  score = Math.max(0, Math.min(100, score));\n\n  // Only return if above minimum threshold\n  if (score < THRESHOLDS.MINIMUM) {\n    return null;\n  }\n\n  return {\n    agent: agentName,\n    confidence: Math.round(score),\n    description: entry.description,\n    matchedKeywords: allMatched,\n    signals: allSignals,\n  };\n}\n\n/**\n * Classify skill match\n */\nfunction classifySkillMatch(\n  promptLower: string,\n  skillName: string,\n  entry: SkillIndexEntry\n): SkillMatch | null {\n  const signals: IntentSignal[] = [];\n  const matched: string[] = [];\n  let score = 0;\n\n  for (const keyword of entry.keywords) {\n    const regex = new RegExp(`\\\\b${keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n    if (regex.test(promptLower)) {\n      const weight = keyword.length > 5 ? 25 : 20;\n      score += weight;\n      matched.push(keyword);\n      signals.push({\n        type: 'keyword',\n        source: 'skill-keyword',\n        weight,\n        matched: keyword,\n      });\n    }\n  }\n\n  // Cap at 100\n  score = Math.min(score, 100);\n\n  if (score < THRESHOLDS.MINIMUM) {\n    return null;\n  }\n\n  return {\n    skill: skillName,\n    confidence: Math.round(score),\n    description: entry.description,\n    matchedKeywords: matched,\n    signals,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Main Classification Function\n// -----------------------------------------------------------------------------\n\n/**\n * Classify user prompt intent and find matching agents/skills\n *\n * @param prompt - The user's input prompt\n * @param history - Recent prompt history for context continuity\n * @param adjustments - Calibration adjustments from outcome learning\n * @returns Classification result with agents, skills, and confidence\n */\nexport function classifyIntent(\n  prompt: string,\n  history: string[] = [],\n  adjustments: CalibrationAdjustment[] = []\n): ClassificationResult {\n  const pluginRoot = getPluginRoot();\n  const agentsDir = join(pluginRoot, 'agents');\n  const skillsDir = join(pluginRoot, 'skills');\n\n  const promptLower = prompt.toLowerCase();\n\n  const allSignals: IntentSignal[] = [];\n  const agentMatches: AgentMatch[] = [];\n  const skillMatches: SkillMatch[] = [];\n\n  // Classify agents\n  const agentIdx = getAgentIndex(agentsDir);\n  for (const [agentName, entry] of agentIdx) {\n    const match = classifyAgentMatch(\n      promptLower,\n      agentName,\n      entry,\n      history,\n      adjustments\n    );\n    if (match) {\n      agentMatches.push(match);\n      allSignals.push(...match.signals);\n    }\n  }\n\n  // Classify skills\n  const skillIdx = getSkillIndex(skillsDir);\n  for (const [skillName, entry] of skillIdx) {\n    const match = classifySkillMatch(promptLower, skillName, entry);\n    if (match) {\n      skillMatches.push(match);\n      allSignals.push(...match.signals);\n    }\n  }\n\n  // Sort by confidence\n  agentMatches.sort((a, b) => b.confidence - a.confidence);\n  skillMatches.sort((a, b) => b.confidence - a.confidence);\n\n  // Determine primary intent from top agent\n  const topAgent = agentMatches[0];\n  const intent = topAgent\n    ? categorizeIntent(topAgent.agent, topAgent.matchedKeywords)\n    : 'general';\n\n  const maxConfidence = Math.max(\n    topAgent?.confidence || 0,\n    skillMatches[0]?.confidence || 0\n  );\n\n  const shouldAutoDispatch =\n    topAgent !== undefined && topAgent.confidence >= THRESHOLDS.AUTO_DISPATCH;\n\n  const shouldInjectSkills =\n    skillMatches.length > 0 &&\n    skillMatches[0].confidence >= THRESHOLDS.SKILL_INJECT;\n\n  return {\n    agents: agentMatches.slice(0, 3), // Top 3\n    skills: skillMatches.slice(0, 5), // Top 5\n    intent,\n    confidence: maxConfidence,\n    signals: allSignals,\n    shouldAutoDispatch,\n    shouldInjectSkills,\n  };\n}\n\n/**\n * Categorize intent based on agent and keywords\n */\nfunction categorizeIntent(agent: string, keywords: string[]): string {\n  const categories: Record<string, string[]> = {\n    'api-design': ['api', 'endpoint', 'rest', 'graphql', 'route'],\n    'database': ['database', 'schema', 'migration', 'sql', 'query'],\n    'authentication': ['auth', 'login', 'jwt', 'oauth', 'session'],\n    'frontend': ['react', 'component', 'ui', 'form', 'state'],\n    'testing': ['test', 'coverage', 'mock', 'fixture', 'e2e'],\n    'devops': ['deploy', 'ci', 'cd', 'release', 'monitor'],\n    'ai-integration': ['llm', 'rag', 'embedding', 'langgraph', 'agent'],\n    'security': ['security', 'owasp', 'xss', 'injection', 'csrf'],\n  };\n\n  for (const [category, categoryKeywords] of Object.entries(categories)) {\n    for (const kw of keywords) {\n      if (categoryKeywords.includes(kw)) {\n        return category;\n      }\n    }\n  }\n\n  // Fallback to agent-based categorization\n  if (agent.includes('backend') || agent.includes('api')) return 'api-design';\n  if (agent.includes('frontend') || agent.includes('ui')) return 'frontend';\n  if (agent.includes('test')) return 'testing';\n  if (agent.includes('security')) return 'security';\n\n  return 'general';\n}\n\n/**\n * Quick check if prompt likely needs orchestration\n * Use this for fast filtering before full classification\n */\nexport function shouldClassify(prompt: string): boolean {\n  if (prompt.length < 10) return false;\n\n  // Skip meta questions about agents/skills\n  if (/what agents|list agents|available agents|what skills/i.test(prompt)) {\n    return false;\n  }\n\n  // Skip simple commands\n  if (/^(yes|no|ok|thanks|done|continue|stop)$/i.test(prompt.trim())) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Clear cached indices (useful for testing or when agents/skills change)\n */\nexport function clearCache(): void {\n  agentIndex = null;\n  agentIndexPath = null;\n  skillIndex = null;\n  skillIndexPath = null;\n}\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n  blockedBy?: string[];\n  blocks?: string[];\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Get action-specific activeForm based on agent type\n */\nfunction getActiveFormForAgent(agent: string, description: string): string {\n  const actionMap: Record<string, string> = {\n    'backend-system-architect': 'Designing',\n    'frontend-ui-developer': 'Building',\n    'test-generator': 'Writing tests for',\n    'security-auditor': 'Auditing',\n    'workflow-architect': 'Architecting',\n    'database-engineer': 'Implementing database for',\n    'llm-integrator': 'Integrating LLM for',\n    'code-quality-reviewer': 'Reviewing',\n    'ux-researcher': 'Researching UX for',\n    'product-strategist': 'Strategizing',\n    'debug-investigator': 'Investigating',\n    'performance-engineer': 'Optimizing',\n    'accessibility-specialist': 'Auditing accessibility for',\n    'infrastructure-architect': 'Designing infrastructure for',\n    'data-pipeline-engineer': 'Building pipeline for',\n  };\n\n  const action = actionMap[agent] || 'Working on';\n  const shortDesc = description.slice(0, 40).toLowerCase();\n  return `${action} ${shortDesc}`;\n}\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: getActiveFormForAgent(agent, description),\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'deleted',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Generate TaskUpdate instruction for task deletion (CC 2.1.20)\n */\nexport function generateTaskDeleteInstruction(\n  taskId: string,\n  _reason: string\n): TaskUpdateInstruction {\n  return {\n    taskId,\n    status: 'deleted',\n  };\n}\n\n/**\n * Format TaskDelete instruction as markdown for Claude (CC 2.1.20)\n */\nexport function formatTaskDeleteForClaude(taskId: string, reason: string): string {\n  return `### Delete Orphaned Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${taskId}\"\n  status: \"deleted\"\n\\`\\`\\`\n\n**Reason**: ${reason}`;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number,\n  blockedBy?: string[],\n  blocks?: string[]\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n    blockedBy,\n    blocks,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get pending tasks blocked by a specific failed task (CC 2.1.20)\n */\nexport function getTasksBlockedBy(failedTaskId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks.filter(\n    t =>\n      t.status === 'pending' &&\n      t.blockedBy &&\n      t.blockedBy.includes(failedTaskId)\n  );\n}\n\n/**\n * Get orphaned tasks - pending tasks where all blockers have failed (CC 2.1.20)\n */\nexport function getOrphanedTasks(): TaskEntry[] {\n  const registry = loadRegistry();\n  const failedIds = new Set(\n    registry.tasks.filter(t => t.status === 'failed').map(t => t.taskId)\n  );\n\n  if (failedIds.size === 0) return [];\n\n  return registry.tasks.filter(t => {\n    if (t.status !== 'pending' || !t.blockedBy || t.blockedBy.length === 0) {\n      return false;\n    }\n    // Orphaned if ALL blockers are failed\n    return t.blockedBy.every(id => failedIds.has(id));\n  });\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Retry Manager - Intelligent retry decisions for failed agents\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Exponential backoff retry logic\n * - Alternative agent suggestions\n * - Failure pattern detection\n * - Max retry limits\n */\n\nimport { logHook } from './common.js';\nimport type {\n  RetryDecision,\n  ExecutionAttempt,\n  AgentOutcome,\n  DispatchedAgent,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_BASE_DELAY_MS = 1000;\nconst MAX_DELAY_MS = 30000;\n\n/** Alternative agent mappings for common failure scenarios */\nconst ALTERNATIVE_AGENTS: Record<string, string[]> = {\n  // If backend architect fails, try these\n  'backend-system-architect': ['database-engineer', 'api-designer'],\n  // If frontend fails, try UI designer first\n  'frontend-ui-developer': ['rapid-ui-designer', 'accessibility-specialist'],\n  // If test generator fails, try debug investigator\n  'test-generator': ['debug-investigator', 'code-quality-reviewer'],\n  // If security auditor fails, try layer auditor\n  'security-auditor': ['security-layer-auditor'],\n  // If workflow architect fails, try LLM integrator\n  'workflow-architect': ['llm-integrator', 'data-pipeline-engineer'],\n};\n\n/** Error patterns that indicate retry is unlikely to help */\nconst NON_RETRYABLE_ERRORS = [\n  /permission denied/i,\n  /access denied/i,\n  /not found.*(?:file|module|package)/i,\n  /(?:file|module|package)\\s+not\\s+found/i,\n  /missing required/i,\n  /invalid (?:api|token|key)/i,\n  /authentication failed/i,\n  /quota exceeded/i,\n  /rate limit/i,\n];\n\n/** Error patterns that suggest trying an alternative agent */\nconst ALTERNATIVE_SUGGESTING_ERRORS = [\n  /not my specialization/i,\n  /outside my scope/i,\n  /better suited for/i,\n  /consider using/i,\n  /specialized agent/i,\n];\n\n// -----------------------------------------------------------------------------\n// Retry Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate exponential backoff delay\n */\nexport function calculateBackoffDelay(\n  attemptNumber: number,\n  baseDelayMs: number = DEFAULT_BASE_DELAY_MS\n): number {\n  // Exponential backoff with jitter\n  const exponentialDelay = baseDelayMs * Math.pow(2, attemptNumber - 1);\n  const jitter = Math.random() * 0.1 * exponentialDelay; // 10% jitter\n  return Math.min(exponentialDelay + jitter, MAX_DELAY_MS);\n}\n\n/**\n * Check if error is retryable\n */\nexport function isRetryableError(error: string): boolean {\n  for (const pattern of NON_RETRYABLE_ERRORS) {\n    if (pattern.test(error)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if error suggests alternative agent\n */\nexport function suggestsAlternative(error: string): boolean {\n  for (const pattern of ALTERNATIVE_SUGGESTING_ERRORS) {\n    if (pattern.test(error)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get alternative agent for a given agent\n */\nexport function getAlternativeAgent(agent: string, triedAgents: string[] = []): string | undefined {\n  const alternatives = ALTERNATIVE_AGENTS[agent];\n  if (!alternatives) return undefined;\n\n  // Return first alternative not yet tried\n  for (const alt of alternatives) {\n    if (!triedAgents.includes(alt)) {\n      return alt;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Make retry decision based on execution history and error\n */\nexport function makeRetryDecision(\n  agent: string,\n  attemptNumber: number,\n  error: string,\n  triedAgents: string[] = [],\n  maxRetries: number = DEFAULT_MAX_RETRIES\n): RetryDecision {\n  logHook('retry-manager', `Evaluating retry for ${agent}, attempt ${attemptNumber}`);\n\n  // Check if max retries exceeded\n  if (attemptNumber >= maxRetries) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Max retries (${maxRetries}) exceeded` +\n        (alternative ? `. Consider trying ${alternative} instead.` : ''),\n    };\n  }\n\n  // Check if error is retryable\n  if (!isRetryableError(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Non-retryable error detected: ${error.slice(0, 100)}`,\n    };\n  }\n\n  // Check if error suggests alternative agent\n  if (suggestsAlternative(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    if (alternative) {\n      return {\n        shouldRetry: false,\n        retryCount: attemptNumber,\n        maxRetries,\n        alternativeAgent: alternative,\n        reason: `Error suggests using alternative agent: ${alternative}`,\n      };\n    }\n  }\n\n  // Retry with backoff\n  const delayMs = calculateBackoffDelay(attemptNumber);\n  return {\n    shouldRetry: true,\n    retryCount: attemptNumber,\n    maxRetries,\n    delayMs,\n    reason: `Retrying (attempt ${attemptNumber + 1}/${maxRetries}) after ${Math.round(delayMs / 1000)}s`,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Execution Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Create execution attempt record\n */\nexport function createAttempt(\n  agent: string,\n  attemptNumber: number,\n  taskId?: string\n): ExecutionAttempt {\n  return {\n    agent,\n    taskId,\n    attemptNumber,\n    startedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Complete execution attempt with outcome\n */\nexport function completeAttempt(\n  attempt: ExecutionAttempt,\n  outcome: AgentOutcome,\n  error?: string\n): ExecutionAttempt {\n  const completedAt = new Date().toISOString();\n  const durationMs = new Date(completedAt).getTime() - new Date(attempt.startedAt).getTime();\n\n  return {\n    ...attempt,\n    completedAt,\n    outcome,\n    error,\n    durationMs,\n  };\n}\n\n/**\n * Analyze execution history for patterns\n */\nexport function analyzeAttemptHistory(attempts: ExecutionAttempt[]): {\n  successRate: number;\n  avgDuration: number;\n  commonErrors: string[];\n} {\n  if (attempts.length === 0) {\n    return { successRate: 0, avgDuration: 0, commonErrors: [] };\n  }\n\n  const successful = attempts.filter(a => a.outcome === 'success').length;\n  const successRate = successful / attempts.length;\n\n  const durations = attempts\n    .filter(a => a.durationMs !== undefined)\n    .map(a => a.durationMs!);\n  const avgDuration = durations.length > 0\n    ? durations.reduce((a, b) => a + b, 0) / durations.length\n    : 0;\n\n  // Count error patterns\n  const errorCounts = new Map<string, number>();\n  for (const attempt of attempts) {\n    if (attempt.error) {\n      // Normalize error to first 50 chars\n      const normalized = attempt.error.slice(0, 50).toLowerCase();\n      errorCounts.set(normalized, (errorCounts.get(normalized) || 0) + 1);\n    }\n  }\n\n  // Get most common errors\n  const commonErrors = Array.from(errorCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([error]) => error);\n\n  return { successRate, avgDuration, commonErrors };\n}\n\n// -----------------------------------------------------------------------------\n// Dispatched Agent Updates\n// -----------------------------------------------------------------------------\n\n/**\n * Update dispatched agent for retry\n */\nexport function prepareForRetry(\n  agent: DispatchedAgent,\n  decision: RetryDecision\n): DispatchedAgent {\n  return {\n    ...agent,\n    status: 'retrying',\n    retryCount: decision.retryCount,\n  };\n}\n\n/**\n * Format retry decision as user-facing message\n */\nexport function formatRetryDecision(decision: RetryDecision, agent: string): string {\n  if (decision.shouldRetry) {\n    return `## Retry Scheduled\n\nAgent \\`${agent}\\` will retry after ${Math.round((decision.delayMs || 0) / 1000)} seconds.\n\n**Attempt:** ${decision.retryCount + 1} of ${decision.maxRetries}\n**Reason:** ${decision.reason}`;\n  }\n\n  let message = `## Retry Not Recommended\n\nAgent \\`${agent}\\` has ${decision.retryCount >= decision.maxRetries ? 'exhausted retries' : 'encountered a non-retryable error'}.\n\n**Reason:** ${decision.reason}`;\n\n  if (decision.alternativeAgent) {\n    message += `\n\n### Alternative Suggestion\n\nConsider using \\`${decision.alternativeAgent}\\` instead:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${decision.alternativeAgent}\"\n\\`\\`\\``;\n  }\n\n  return message;\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Multi-Agent Coordinator - Pipeline detection and coordination logic\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Pipeline definitions for common workflows\n * - Pipeline detection from prompts\n * - Task chain generation with dependencies\n */\n\nimport { logHook } from './common.js';\nimport type {\n  PipelineType,\n  PipelineDefinition,\n  PipelineExecution,\n  TaskCreateInstruction,\n  TaskMetadata,\n} from './orchestration-types.js';\nimport { registerPipeline, registerTask } from './task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Pipeline Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Predefined pipeline configurations\n */\nexport const PIPELINES: PipelineDefinition[] = [\n  {\n    type: 'product-thinking',\n    name: 'Product Thinking Pipeline',\n    description: 'Full product discovery and specification workflow',\n    triggers: [\n      'should we build',\n      'product decision',\n      'feature validation',\n      'market research',\n      'user research',\n    ],\n    steps: [\n      {\n        agent: 'market-intelligence',\n        description: 'Analyze competitive landscape and market trends',\n        dependsOn: [],\n        skills: ['market-research'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'ux-researcher',\n        description: 'Create personas and map user journeys',\n        dependsOn: [0],\n        skills: ['user-research'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'product-strategist',\n        description: 'Validate value proposition and alignment',\n        dependsOn: [0, 1],\n        skills: ['product-strategy'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'prioritization-analyst',\n        description: 'Score and prioritize using frameworks',\n        dependsOn: [2],\n        skills: ['prioritization'],\n        estimatedTokens: 1500,\n      },\n      {\n        agent: 'business-case-builder',\n        description: 'Build ROI and cost-benefit analysis',\n        dependsOn: [2, 3],\n        skills: ['business-case'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'requirements-translator',\n        description: 'Transform to PRD and user stories',\n        dependsOn: [4],\n        skills: ['requirements'],\n        estimatedTokens: 2500,\n      },\n    ],\n    estimatedTotalTokens: 13500,\n  },\n  {\n    type: 'full-stack-feature',\n    name: 'Full-Stack Feature Pipeline',\n    description: 'End-to-end feature implementation workflow',\n    triggers: [\n      'full-stack feature',\n      'build a feature',\n      'implement end-to-end',\n      'create full feature',\n      'add complete feature',\n    ],\n    steps: [\n      {\n        agent: 'backend-system-architect',\n        description: 'Design API and database schema',\n        dependsOn: [],\n        skills: ['api-design-framework', 'database-schema-designer'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Build React components and UI',\n        dependsOn: [0],\n        skills: ['react-server-components-framework', 'form-state-patterns'],\n        estimatedTokens: 3500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create unit and integration tests',\n        dependsOn: [0, 1],\n        skills: ['integration-testing', 'msw-mocking'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-auditor',\n        description: 'Audit for vulnerabilities',\n        dependsOn: [0, 1],\n        skills: ['owasp-top-10', 'auth-patterns'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 10000,\n  },\n  {\n    type: 'ai-integration',\n    name: 'AI Integration Pipeline',\n    description: 'Add AI/LLM capabilities to application',\n    triggers: [\n      'add rag',\n      'add llm',\n      'ai integration',\n      'implement rag',\n      'add ai feature',\n      'langgraph workflow',\n    ],\n    steps: [\n      {\n        agent: 'workflow-architect',\n        description: 'Design LangGraph workflow and state',\n        dependsOn: [],\n        skills: ['langgraph-state', 'langgraph-routing'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'llm-integrator',\n        description: 'Connect LLM APIs with function calling',\n        dependsOn: [0],\n        skills: ['function-calling', 'llm-streaming'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'data-pipeline-engineer',\n        description: 'Build embeddings and data pipeline',\n        dependsOn: [0],\n        skills: ['embeddings', 'rag-retrieval'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create LLM testing infrastructure',\n        dependsOn: [1, 2],\n        skills: ['llm-testing', 'property-based-testing'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 8500,\n  },\n  {\n    type: 'security-audit',\n    name: 'Security Audit Pipeline',\n    description: 'Comprehensive security review workflow',\n    triggers: [\n      'security audit',\n      'security review',\n      'vulnerability scan',\n      'security assessment',\n    ],\n    steps: [\n      {\n        agent: 'security-auditor',\n        description: 'Scan for OWASP Top 10 vulnerabilities',\n        dependsOn: [],\n        skills: ['owasp-top-10', 'input-validation'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-layer-auditor',\n        description: 'Verify defense-in-depth layers',\n        dependsOn: [0],\n        skills: ['defense-in-depth'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'ai-safety-auditor',\n        description: 'Audit AI/LLM security if applicable',\n        dependsOn: [0],\n        skills: ['mcp-security-hardening'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 5500,\n  },\n  {\n    type: 'frontend-compliance',\n    name: 'Frontend 2026 Compliance Pipeline',\n    description: 'Modernize frontend to 2026 patterns',\n    triggers: [\n      'frontend compliance',\n      'modernize frontend',\n      'update react',\n      'frontend 2026',\n    ],\n    steps: [\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Upgrade to React 19 patterns',\n        dependsOn: [],\n        skills: ['react-server-components-framework', 'zustand-patterns'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'performance-engineer',\n        description: 'Optimize Core Web Vitals',\n        dependsOn: [0],\n        skills: ['core-web-vitals', 'lazy-loading-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'accessibility-specialist',\n        description: 'Ensure WCAG 2.2 compliance',\n        dependsOn: [0],\n        skills: ['a11y-testing', 'focus-management'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 6500,\n  },\n];\n\n// -----------------------------------------------------------------------------\n// Pipeline Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect if prompt matches a pipeline trigger\n */\nexport function detectPipeline(prompt: string): PipelineDefinition | null {\n  const promptLower = prompt.toLowerCase();\n\n  for (const pipeline of PIPELINES) {\n    for (const trigger of pipeline.triggers) {\n      if (promptLower.includes(trigger)) {\n        logHook(\n          'multi-agent-coordinator',\n          `Detected pipeline: ${pipeline.type} (trigger: \"${trigger}\")`\n        );\n        return pipeline;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get pipeline by type\n */\nexport function getPipelineByType(type: PipelineType): PipelineDefinition | null {\n  return PIPELINES.find(p => p.type === type) || null;\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Execution\n// -----------------------------------------------------------------------------\n\n/**\n * Create a pipeline execution plan with task instructions\n */\nexport function createPipelineExecution(\n  pipeline: PipelineDefinition\n): {\n  execution: PipelineExecution;\n  tasks: TaskCreateInstruction[];\n} {\n  const pipelineId = `pipeline-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n\n  // Create task instructions for each step\n  const tasks: TaskCreateInstruction[] = [];\n  const taskIds: Record<number, string> = {};\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const taskId = `task-${pipelineId}-${i}`;\n    taskIds[i] = taskId;\n\n    const metadata: TaskMetadata = {\n      source: 'pipeline',\n      dispatchedAgent: step.agent,\n      pipelineId,\n      pipelineStep: i,\n      relatedSkills: step.skills,\n    };\n\n    // Build blockedBy from dependsOn\n    const blockedBy = step.dependsOn.map(dep => taskIds[dep]).filter(Boolean);\n\n    tasks.push({\n      subject: `[${pipeline.name}] Step ${i + 1}: ${step.description}`,\n      description: `Pipeline step: ${step.agent}\\n\\n${step.description}\\n\\nEstimated tokens: ${step.estimatedTokens}`,\n      activeForm: `Running ${step.agent}`,\n      metadata,\n      blockedBy: blockedBy.length > 0 ? blockedBy : undefined,\n    });\n  }\n\n  const execution: PipelineExecution = {\n    pipelineId,\n    type: pipeline.type,\n    startedAt: new Date().toISOString(),\n    taskIds,\n    currentStep: 0,\n    completedSteps: [],\n    status: 'running',\n  };\n\n  return { execution, tasks };\n}\n\n/**\n * Register pipeline and tasks with tracking systems\n */\nexport function registerPipelineExecution(\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): void {\n  // Register pipeline\n  registerPipeline(execution);\n\n  // Register each task\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    const taskId = execution.taskIds[i];\n\n    if (taskId && task.metadata.dispatchedAgent) {\n      registerTask(\n        taskId,\n        task.metadata.dispatchedAgent,\n        task.metadata.dispatchConfidence || 100,\n        execution.pipelineId,\n        i\n      );\n    }\n  }\n\n  logHook(\n    'multi-agent-coordinator',\n    `Registered pipeline ${execution.pipelineId} with ${tasks.length} tasks`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Message Formatting\n// -----------------------------------------------------------------------------\n\n/**\n * Format pipeline plan as markdown for user\n */\nexport function formatPipelinePlan(\n  pipeline: PipelineDefinition,\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): string {\n  let md = `## \uD83D\uDD04 Pipeline Detected: ${pipeline.name}\n\n${pipeline.description}\n\n**Pipeline ID:** \\`${execution.pipelineId}\\`\n**Estimated Total Tokens:** ~${pipeline.estimatedTotalTokens}\n\n### Pipeline Steps\n\n`;\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const deps = step.dependsOn.length > 0\n      ? ` (after steps: ${step.dependsOn.map(d => d + 1).join(', ')})`\n      : ' (can start immediately)';\n\n    md += `**${i + 1}. ${step.agent}**${deps}\n   ${step.description}\n   Skills: ${step.skills?.join(', ') || 'none'}\n\n`;\n  }\n\n  md += `### Task Creation Instructions\n\nCreate these tasks to track the pipeline:\n\n`;\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    md += `**Task ${i + 1}:**\n\\`\\`\\`\nTaskCreate:\n  subject: \"${task.subject}\"\n  activeForm: \"${task.activeForm}\"\n${task.blockedBy ? `  blockedBy: ${JSON.stringify(task.blockedBy)}` : ''}\n\\`\\`\\`\n\n`;\n  }\n\n  md += `### Start Pipeline\n\nAfter creating all tasks, spawn the first agent:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${pipeline.steps[0].agent}\"\n\\`\\`\\`\n\nThe orchestration layer will track progress and suggest next agents as steps complete.`;\n\n  return md;\n}\n", "/**\n * Antipattern Detector - UserPromptSubmit Hook\n * Suggests checking mem0 for known failed patterns before implementation\n * CC 2.1.7 Compliant\n *\n * Part of mem0 Semantic Memory Integration (#49)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// Keywords that suggest implementation work where antipatterns matter\nconst IMPLEMENTATION_KEYWORDS = [\n  'implement',\n  'add',\n  'create',\n  'build',\n  'set up',\n  'configure',\n  'pagination',\n  'authentication',\n  'caching',\n  'database',\n  'api',\n  'endpoint',\n];\n\n/**\n * Detect best practice category from prompt\n */\nfunction detectCategory(prompt: string): string {\n  const promptLower = prompt.toLowerCase();\n\n  if (/pagination|cursor|offset|page/i.test(promptLower)) return 'pagination';\n  if (/auth|jwt|oauth|login|session/i.test(promptLower)) return 'authentication';\n  if (/cache|redis|memo/i.test(promptLower)) return 'caching';\n  if (/database|sql|postgres|query/i.test(promptLower)) return 'database';\n  if (/api|endpoint|rest|graphql/i.test(promptLower)) return 'api';\n  if (/error|exception|handling/i.test(promptLower)) return 'error-handling';\n  if (/test|testing|spec/i.test(promptLower)) return 'testing';\n\n  return 'general';\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Generate global mem0 user ID\n */\nfunction getGlobalUserId(scope: string): string {\n  return `global:${scope}`;\n}\n\n/**\n * Antipattern detector - suggests mem0 search for known failures\n */\nexport function antipatternDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Skip if prompt too short\n  if (prompt.length < 30) {\n    return outputSilentSuccess();\n  }\n\n  // Check if prompt suggests implementation work\n  const promptLower = prompt.toLowerCase();\n  let matchedKeyword = '';\n\n  for (const keyword of IMPLEMENTATION_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      matchedKeyword = keyword;\n      break;\n    }\n  }\n\n  if (!matchedKeyword) {\n    return outputSilentSuccess();\n  }\n\n  logHook('antipattern-detector', `Implementation keyword detected: ${matchedKeyword}`);\n\n  // Get category and user IDs for search suggestion\n  const category = detectCategory(prompt);\n  const projectUserId = getMem0UserId('best-practices', projectDir);\n  const globalUserId = getGlobalUserId('best-practices');\n\n  logHook('antipattern-detector', `Suggesting antipattern check for: ${matchedKeyword} (category: ${category})`);\n\n  // Build search suggestion message\n  const systemMsg = `[Antipattern Check] Before implementing ${matchedKeyword}, check for known failures:\n\\`mcp__mem0__search_memories\\` with query=\"${matchedKeyword} failed\" and filters={\"AND\":[{\"user_id\":\"${projectUserId}\"},{\"metadata.outcome\":\"failed\"}]}\nOr check global: user_id=\"${globalUserId}\"`;\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n  };\n}\n", "/**\n * Antipattern Warning - UserPromptSubmit Hook\n * Proactive anti-pattern detection and warning injection\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for warnings\n *\n * Enhanced with Mem0 semantic search hints for project/global anti-patterns.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Keywords that indicate implementation intent\nconst IMPLEMENTATION_KEYWORDS = [\n  'implement',\n  'add',\n  'create',\n  'build',\n  'set up',\n  'setup',\n  'configure',\n  'use',\n  'write',\n  'make',\n  'develop',\n];\n\n// Known anti-patterns database\nconst KNOWN_ANTIPATTERNS: Array<{ pattern: string; warning: string }> = [\n  {\n    pattern: 'offset pagination',\n    warning:\n      'Offset pagination causes performance issues on large tables. Use cursor-based pagination instead.',\n  },\n  {\n    pattern: 'manual jwt validation',\n    warning:\n      'Manual JWT validation is error-prone. Use established libraries like python-jose or jsonwebtoken.',\n  },\n  {\n    pattern: 'storing passwords in plaintext',\n    warning: 'Never store passwords in plaintext. Use bcrypt, argon2, or scrypt.',\n  },\n  {\n    pattern: 'global state',\n    warning:\n      'Global mutable state causes testing and concurrency issues. Use dependency injection.',\n  },\n  {\n    pattern: 'synchronous file operations',\n    warning: 'Synchronous file I/O blocks the event loop. Use async file operations.',\n  },\n  {\n    pattern: 'n+1 query',\n    warning: 'N+1 queries cause performance problems. Use eager loading or batch queries.',\n  },\n  {\n    pattern: 'polling for real-time',\n    warning: 'Polling is inefficient for real-time updates. Consider SSE or WebSocket.',\n  },\n];\n\ninterface LearnedPattern {\n  text: string;\n  outcome?: string;\n}\n\ninterface PatternsFile {\n  patterns?: LearnedPattern[];\n}\n\ninterface GlobalAntipattern {\n  pattern: string;\n  warning: string;\n}\n\ninterface GlobalPatternsFile {\n  antipatterns?: GlobalAntipattern[];\n}\n\n/**\n * Check if prompt contains implementation keywords\n */\nfunction isImplementationPrompt(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of IMPLEMENTATION_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Detect best practice category from prompt\n */\nfunction detectCategory(prompt: string): string {\n  const promptLower = prompt.toLowerCase();\n\n  if (/pagination|cursor|offset|page/i.test(promptLower)) return 'pagination';\n  if (/auth|jwt|oauth|login|session/i.test(promptLower)) return 'authentication';\n  if (/cache|redis|memo/i.test(promptLower)) return 'caching';\n  if (/database|sql|postgres|query/i.test(promptLower)) return 'database';\n  if (/api|endpoint|rest|graphql/i.test(promptLower)) return 'api';\n\n  return 'general';\n}\n\n/**\n * Search local patterns for anti-patterns\n */\nfunction searchLocalAntipatterns(prompt: string, projectDir: string): string[] {\n  const promptLower = prompt.toLowerCase();\n  const warnings: string[] = [];\n\n  // Check known anti-patterns\n  for (const { pattern, warning } of KNOWN_ANTIPATTERNS) {\n    if (promptLower.includes(pattern)) {\n      warnings.push(warning);\n    }\n  }\n\n  // Check learned patterns file\n  const patternsFile = join(projectDir, '.claude', 'feedback', 'learned-patterns.json');\n  if (existsSync(patternsFile)) {\n    try {\n      const data: PatternsFile = JSON.parse(readFileSync(patternsFile, 'utf8'));\n      const failedPatterns = (data.patterns || []).filter((p) => p.outcome === 'failed');\n\n      for (const pattern of failedPatterns) {\n        if (pattern.text) {\n          const patternLower = pattern.text.toLowerCase();\n          const firstWord = patternLower.split(' ')[0];\n          if (firstWord && promptLower.includes(firstWord)) {\n            warnings.push(`Previously failed: ${pattern.text}`);\n          }\n        }\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  // Check global patterns\n  const globalPatternsFile = join(process.env.HOME || '', '.claude', 'global-patterns.json');\n  if (existsSync(globalPatternsFile)) {\n    try {\n      const data: GlobalPatternsFile = JSON.parse(readFileSync(globalPatternsFile, 'utf8'));\n      for (const { pattern, warning } of data.antipatterns || []) {\n        if (promptLower.includes(pattern.toLowerCase())) {\n          warnings.push(`${pattern}: ${warning}`);\n        }\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  return warnings;\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Build mem0 search hint for the prompt\n */\nfunction buildMem0SearchHint(prompt: string, projectDir: string): string {\n  const category = detectCategory(prompt);\n  const userId = getMem0UserId('best-practices', projectDir);\n  const globalUserId = `global:best-practices`;\n\n  return `Before implementing, search Mem0 for relevant patterns (graph memory enabled):\n\n1. Project anti-patterns (category: ${category}):\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${userId}\", \"filters\": {\"metadata.outcome\": \"failed\"}}\n\n2. Project best practices:\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${userId}\", \"filters\": {\"metadata.outcome\": \"success\"}}\n\n3. Cross-project failures:\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${globalUserId}\", \"filters\": {\"metadata.outcome\": \"failed\"}}`;\n}\n\n/**\n * Antipattern warning hook - detects and warns about known anti-patterns\n */\nexport function antipatternWarning(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  // Only check implementation prompts\n  if (!isImplementationPrompt(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('antipattern-warning', 'Checking prompt for anti-patterns...');\n\n  // Search for matching anti-patterns\n  const warnings = searchLocalAntipatterns(prompt, projectDir);\n\n  // Build mem0 search hints\n  const mem0SearchHints = buildMem0SearchHint(prompt, projectDir);\n\n  if (warnings.length > 0) {\n    logHook('antipattern-warning', `Found anti-pattern warnings: ${warnings.join(', ')}`);\n\n    // Build warning message with mem0 search hints\n    const warningMessage = `## Anti-Pattern Warning\n\nThe following patterns have previously caused issues:\n\n${warnings.map((w) => `- ${w}`).join('\\n')}\n\nConsider alternative approaches before proceeding.\n\n${mem0SearchHints}`;\n\n    return outputPromptContext(warningMessage);\n  }\n\n  // No local warnings - provide mem0 search hints for significant implementation tasks\n  if (/implement|build|create|develop/.test(prompt.toLowerCase())) {\n    return outputPromptContext(mem0SearchHints);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Context Injector - UserPromptSubmit Hook\n * Injects relevant context hints based on user prompt keywords\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Context injector hook - adds helpful hints based on prompt content\n */\nexport function contextInjector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  logHook('context-injector', `User prompt received (${prompt.length} chars)`);\n\n  const contextHints: string[] = [];\n\n  // If prompt mentions issues or bugs, remind about issue docs\n  if (/issue|bug|fix|#[0-9]+/.test(prompt)) {\n    const issueDocsDir = join(projectDir, 'docs', 'issues');\n    if (existsSync(issueDocsDir)) {\n      contextHints.push('Check docs/issues/ for issue documentation.');\n    }\n  }\n\n  // If prompt mentions testing, remind about test patterns\n  if (/test|testing|pytest|jest/.test(prompt.toLowerCase())) {\n    contextHints.push(\"Remember to use 'tee' for visible test output.\");\n  }\n\n  // If prompt mentions deployment or CI/CD\n  if (/deploy|ci|cd|pipeline|github.actions/.test(prompt.toLowerCase())) {\n    contextHints.push('Check .github/workflows/ for CI configuration.');\n  }\n\n  // Log context hints if any\n  if (contextHints.length > 0) {\n    logHook('context-injector', `Context hints: ${contextHints.join(' ')}`);\n  }\n\n  // Currently outputs silent success - hints are logged only\n  // Could be enhanced to use additionalContext in the future\n  return outputSilentSuccess();\n}\n", "/**\n * Context Pruning Advisor - UserPromptSubmit Hook\n * Recommends context pruning when usage exceeds 70%\n *\n * Analyzes loaded context (skills, files, agent outputs) and scores by:\n * - Recency: How recently was it accessed? (0-10 points)\n * - Frequency: How often accessed this session? (0-10 points)\n * - Relevance: How related to current prompt? (0-10 points)\n *\n * Total score: 0-30 points\n * Pruning threshold: Items with score < 15 are candidates\n *\n * Issue: #126\n * CC 2.1.9 Compliant: Uses additionalContext for recommendations\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  outputPromptContext,\n  logHook,\n  getProjectDir,\n  getSessionId,\n} from '../lib/common.js';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// Configuration\nconst CONTEXT_TRIGGER = 0.7; // Trigger at 70% context usage\nconst CONTEXT_CRITICAL = 0.95; // Critical threshold\nconst PRUNE_THRESHOLD_HIGH = 8; // Score 0-8: High priority pruning\nconst PRUNE_THRESHOLD_MED = 15; // Score 9-15: Medium priority pruning\nconst MAX_RECOMMENDATIONS = 5; // Limit recommendations\n\ninterface ContextItem {\n  id: string;\n  tags?: string[];\n  last_accessed?: string;\n  loaded_at?: string;\n  access_count?: number;\n  estimated_tokens?: number;\n}\n\ninterface StateFile {\n  session_id: string;\n  updated_at: string;\n  total_context_tokens: number;\n  context_budget: number;\n  items: ContextItem[];\n}\n\n/**\n * Calculate recency score (0-10) based on time since last access\n */\nfunction calculateRecencyScore(lastAccessed: string | undefined): number {\n  if (!lastAccessed) return 0;\n\n  const currentTime = Date.now();\n  let lastEpoch: number;\n\n  if (/^\\d+$/.test(lastAccessed)) {\n    lastEpoch = parseInt(lastAccessed, 10);\n  } else {\n    lastEpoch = new Date(lastAccessed).getTime();\n    if (isNaN(lastEpoch)) return 0;\n  }\n\n  const ageMinutes = (currentTime - lastEpoch) / (1000 * 60);\n\n  if (ageMinutes <= 5) return 10;\n  if (ageMinutes <= 15) return 8;\n  if (ageMinutes <= 30) return 6;\n  if (ageMinutes <= 60) return 4;\n  if (ageMinutes <= 120) return 2;\n  return 0;\n}\n\n/**\n * Calculate frequency score (0-10) based on access count\n */\nfunction calculateFrequencyScore(count: number): number {\n  if (count >= 10) return 10;\n  if (count >= 7) return 8;\n  if (count >= 4) return 6;\n  if (count >= 2) return 4;\n  if (count >= 1) return 2;\n  return 0;\n}\n\n/**\n * Calculate relevance score (0-10) based on keyword overlap\n */\nfunction calculateRelevanceScore(itemKeywords: string[], promptKeywords: string[]): number {\n  if (itemKeywords.length === 0 || promptKeywords.length === 0) {\n    return 2; // Generic/infrastructure default\n  }\n\n  const itemSet = new Set(itemKeywords.map((k) => k.toLowerCase()));\n  const promptSet = new Set(promptKeywords.map((k) => k.toLowerCase()));\n\n  let overlap = 0;\n  for (const keyword of itemSet) {\n    if (promptSet.has(keyword)) {\n      overlap++;\n    }\n  }\n\n  const overlapRatio = overlap / itemSet.size;\n\n  if (overlapRatio >= 0.75) return 10;\n  if (overlapRatio >= 0.5) return 8;\n  if (overlapRatio >= 0.3) return 6;\n  if (overlapRatio >= 0.15) return 4;\n  if (overlap > 0) return 2;\n  return 0;\n}\n\n/**\n * Extract keywords from user prompt\n */\nfunction extractPromptKeywords(prompt: string): string[] {\n  const stopwords = new Set([\n    'the',\n    'and',\n    'for',\n    'with',\n    'from',\n    'that',\n    'this',\n    'have',\n    'will',\n    'can',\n    'should',\n    'would',\n    'could',\n  ]);\n\n  return prompt\n    .toLowerCase()\n    .match(/\\b[a-z]{3,}\\b/g)\n    ?.filter((word) => !stopwords.has(word))\n    .slice(0, 20) || [];\n}\n\n/**\n * Get state file path\n */\nfunction getStateFilePath(): string {\n  const sessionId = getSessionId();\n  return `/tmp/claude-context-tracking-${sessionId}.json`;\n}\n\n/**\n * Initialize or load state file\n */\nfunction loadOrInitState(): StateFile {\n  const stateFile = getStateFilePath();\n\n  if (existsSync(stateFile)) {\n    try {\n      return JSON.parse(readFileSync(stateFile, 'utf8'));\n    } catch {\n      // Fall through to create new\n    }\n  }\n\n  const sessionId = getSessionId();\n  const state: StateFile = {\n    session_id: sessionId,\n    updated_at: new Date().toISOString(),\n    total_context_tokens: 0,\n    context_budget: 12000,\n    items: [],\n  };\n\n  writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  return state;\n}\n\n/**\n * Get estimated context usage percentage\n */\nfunction getContextUsagePercentage(state: StateFile): number {\n  // Try environment variable first (if available from CC)\n  const envPercent = process.env.CLAUDE_CONTEXT_USAGE_PERCENT;\n  if (envPercent) {\n    const parsed = parseFloat(envPercent);\n    if (!isNaN(parsed)) return parsed;\n  }\n\n  // Fallback to state file estimate\n  if (state.context_budget > 0) {\n    return state.total_context_tokens / state.context_budget;\n  }\n\n  return 0;\n}\n\ninterface PruneCandidate {\n  score: number;\n  priority: string;\n  itemId: string;\n  tokens: number;\n}\n\n/**\n * Analyze context and generate pruning recommendations\n */\nfunction analyzeAndRecommend(state: StateFile, promptKeywords: string[]): PruneCandidate[] {\n  const candidates: PruneCandidate[] = [];\n\n  for (const item of state.items) {\n    const lastAccessed = item.last_accessed || item.loaded_at;\n    const accessCount = item.access_count || 0;\n    const keywords = item.tags || [];\n\n    const recencyScore = calculateRecencyScore(lastAccessed);\n    const frequencyScore = calculateFrequencyScore(accessCount);\n    const relevanceScore = calculateRelevanceScore(keywords, promptKeywords);\n    const totalScore = recencyScore + frequencyScore + relevanceScore;\n\n    logHook(\n      'context-pruning-advisor',\n      `Scored ${item.id}: R=${recencyScore} F=${frequencyScore} V=${relevanceScore} Total=${totalScore}`\n    );\n\n    if (totalScore <= PRUNE_THRESHOLD_MED) {\n      candidates.push({\n        score: totalScore,\n        priority: totalScore <= PRUNE_THRESHOLD_HIGH ? 'HIGH' : 'MED',\n        itemId: item.id,\n        tokens: item.estimated_tokens || 500,\n      });\n    }\n  }\n\n  // Sort by score ascending (lowest first) and limit\n  return candidates.sort((a, b) => a.score - b.score).slice(0, MAX_RECOMMENDATIONS);\n}\n\n/**\n * Build recommendation message\n */\nfunction buildRecommendationMessage(candidates: PruneCandidate[]): string {\n  let totalSavings = 0;\n  const lines: string[] = [];\n\n  for (let i = 0; i < candidates.length; i++) {\n    const { priority, itemId, score, tokens } = candidates[i];\n    totalSavings += tokens;\n\n    // Format item name for display\n    const displayName = itemId.replace(/^(skill:|file:|agent:)/, '');\n    lines.push(`  ${i + 1}. [${priority}] ${displayName} (score: ${score}, saves ~${tokens}t)`);\n  }\n\n  return `Context usage >70%. Pruning recommendations:\n${lines.join('\\n')}\n\nPotential savings: ~${totalSavings} tokens\nTo prune: Archive or unload low-scoring context items.`;\n}\n\n/**\n * Context pruning advisor hook\n */\nexport function contextPruningAdvisor(input: HookInput): HookResult {\n  const projectDir = input.project_dir || getProjectDir();\n  const prompt = input.prompt || '';\n\n  // Ensure log directory exists\n  const logDir = join(projectDir, 'logs');\n  if (!existsSync(logDir)) {\n    try {\n      mkdirSync(logDir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Initialize/load state\n  const state = loadOrInitState();\n\n  // Get current context usage\n  const contextUsage = getContextUsagePercentage(state);\n  logHook(\n    'context-pruning-advisor',\n    `Context usage: ${contextUsage} (trigger threshold: ${CONTEXT_TRIGGER})`\n  );\n\n  // Fast exit: Context usage below threshold\n  if (contextUsage < CONTEXT_TRIGGER) {\n    logHook('context-pruning-advisor', 'Context usage within limits, no pruning needed');\n    return outputSilentSuccess();\n  }\n\n  // Critical path: Context usage at critical level (>95%)\n  if (contextUsage >= CONTEXT_CRITICAL) {\n    logHook('context-pruning-advisor', `CRITICAL: Context usage at ${contextUsage * 100}% (>95%)`);\n    const criticalMsg = `CRITICAL: Context usage at ${Math.round(contextUsage * 100)}% (>95%). Use /ork:context-compression immediately or manually archive old decisions and patterns.`;\n    return outputPromptContext(criticalMsg);\n  }\n\n  // Extract keywords from current prompt\n  if (!prompt) {\n    logHook('context-pruning-advisor', 'No user prompt found in hook input, skipping analysis');\n    return outputSilentSuccess();\n  }\n\n  const promptKeywords = extractPromptKeywords(prompt);\n  logHook('context-pruning-advisor', `Extracted prompt keywords: ${promptKeywords.join(', ')}`);\n\n  // Analyze context and generate recommendations\n  const candidates = analyzeAndRecommend(state, promptKeywords);\n\n  if (candidates.length > 0) {\n    const message = buildRecommendationMessage(candidates);\n    logHook(\n      'context-pruning-advisor',\n      `Recommending ${candidates.length} pruning candidates`\n    );\n    return outputPromptContext(message);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Memory Context - UserPromptSubmit Hook\n * Auto-searches knowledge graph for relevant context based on user prompt\n * CC 2.1.7 Compliant\n *\n * Graph-First Architecture (v2.1):\n * - ALWAYS works - knowledge graph requires no configuration\n * - Primary: Search knowledge graph (mcp__memory__search_nodes)\n * - Optional: Also search mem0 for semantic matches if configured\n *\n * Part of Memory Fabric v2.1\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Keywords that suggest memory search would be valuable\nconst MEMORY_TRIGGER_KEYWORDS = [\n  'add',\n  'implement',\n  'create',\n  'build',\n  'design',\n  'refactor',\n  'update',\n  'modify',\n  'fix',\n  'change',\n  'continue',\n  'resume',\n  'remember',\n  'previous',\n  'last time',\n  'before',\n  'earlier',\n  'pattern',\n  'decision',\n  'how did we',\n  'what did we',\n];\n\n// Keywords that suggest graph search would be valuable\nconst GRAPH_TRIGGER_KEYWORDS = [\n  'relationship',\n  'related',\n  'connected',\n  'depends',\n  'uses',\n  'recommends',\n  'what does.*recommend',\n  'how does.*work with',\n];\n\n// Minimum prompt length to trigger memory search\nconst MIN_PROMPT_LENGTH = 20;\n\n/**\n * Check if prompt contains memory trigger keywords\n */\nfunction shouldSearchMemory(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of MEMORY_TRIGGER_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if prompt contains graph trigger keywords\n */\nfunction hasGraphTrigger(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of GRAPH_TRIGGER_KEYWORDS) {\n    if (new RegExp(keyword, 'i').test(promptLower)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Extract search terms from prompt\n */\nfunction extractSearchTerms(prompt: string): string {\n  const stopwords = new Set([\n    'the',\n    'a',\n    'an',\n    'to',\n    'for',\n    'in',\n    'on',\n    'at',\n    'is',\n    'are',\n    'was',\n    'were',\n    'be',\n    'been',\n    'being',\n    'have',\n    'has',\n    'had',\n    'do',\n    'does',\n    'did',\n    'will',\n    'would',\n    'could',\n    'should',\n    'can',\n    'may',\n    'might',\n    'must',\n    'shall',\n    'i',\n    'you',\n    'we',\n    'they',\n    'it',\n    'this',\n    'that',\n    'these',\n    'those',\n    'my',\n    'your',\n    'our',\n    'their',\n    'its',\n    'and',\n    'or',\n    'but',\n    'if',\n    'then',\n    'else',\n    'when',\n    'where',\n    'how',\n    'what',\n    'which',\n    'who',\n    'whom',\n    'with',\n    'from',\n    'into',\n    'onto',\n    'about',\n    'after',\n    'before',\n    'global',\n  ]);\n\n  const words = prompt\n    .toLowerCase()\n    .replace(/[^a-z\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter((word) => word.length > 2 && !stopwords.has(word))\n    .slice(0, 5);\n\n  return words.join(' ');\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Get current agent ID if available\n */\nfunction getAgentContext(projectDir: string): string {\n  // Check environment variable first\n  const agentId = process.env.CLAUDE_AGENT_ID;\n  if (agentId) return agentId;\n\n  // Check agent tracking file\n  const trackingFile = join(projectDir, '.claude', 'session', 'current-agent-id');\n  if (existsSync(trackingFile)) {\n    try {\n      return readFileSync(trackingFile, 'utf8').trim();\n    } catch {\n      // Ignore\n    }\n  }\n\n  return '';\n}\n\n/**\n * Memory context hook - suggests memory searches for relevant context\n */\nexport function memoryContext(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  const isMem0Available = false; // Simplified - mem0 availability would be checked at runtime\n\n  logHook('memory-context', `Memory context hook starting (graph-first, mem0=${isMem0Available})`);\n\n  // Skip if prompt is too short\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    logHook('memory-context', `Prompt too short (${prompt.length} chars), skipping memory search`);\n    return outputSilentSuccess();\n  }\n\n  // Check for special prefixes\n  const useGlobal =\n    prompt.startsWith('@global') ||\n    prompt.includes('cross-project') ||\n    prompt.includes('all projects');\n  const useGraph = hasGraphTrigger(prompt);\n\n  if (useGlobal) {\n    logHook('memory-context', 'Detected @global prefix - will suggest cross-project search');\n  }\n\n  if (useGraph) {\n    logHook('memory-context', 'Detected graph-related query');\n  }\n\n  // Get agent context\n  const agentContext = getAgentContext(projectDir);\n  if (agentContext) {\n    logHook('memory-context', `Agent context detected: ${agentContext}`);\n  }\n\n  // Check if memory search would be valuable\n  if (!shouldSearchMemory(prompt)) {\n    logHook('memory-context', 'No memory trigger keywords found, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Extract search terms\n  const searchTerms = extractSearchTerms(prompt);\n  if (!searchTerms) {\n    logHook('memory-context', 'No search terms extracted, skipping');\n    return outputSilentSuccess();\n  }\n\n  logHook('memory-context', `Search terms: ${searchTerms}`);\n\n  // Build scope description\n  const scopeDesc = useGlobal ? 'cross-project' : 'project';\n\n  // Build context suggestion message\n  // NOTE: We build the message but return silent success\n  // The original bash hook did the same - built the message but returned silently\n  // Claude already has access to memory tools\n\n  const userIdDecisions = getMem0UserId('decisions', projectDir);\n\n  let systemMsg = `[Memory Context] For relevant past ${scopeDesc} decisions, use mcp__memory__search_nodes with query=\"${searchTerms}\"`;\n\n  // Add relationship hint if graph-related query\n  if (useGraph) {\n    systemMsg +=\n      ' | For relationships: mcp__memory__open_nodes on found entities | Graph traversal available';\n  }\n\n  // Add mem0 hint if available\n  if (isMem0Available && userIdDecisions) {\n    systemMsg += ` | [Enhanced] For semantic search: mcp__mem0__search_memories query=\"${searchTerms}\" user_id=\"${userIdDecisions}\" enable_graph=true`;\n\n    if (!useGlobal) {\n      systemMsg += ' | Cross-project: user_id=\"global:best-practices\"';\n    }\n  }\n\n  // Add agent context hint\n  if (agentContext) {\n    systemMsg += ` | Agent context: ${agentContext}`;\n  }\n\n  logHook('memory-context', `Memory context available for: ${searchTerms}`);\n\n  // Silent operation - Claude already has access to memory tools\n  return outputSilentSuccess();\n}\n", "/**\n * Satisfaction Detector - UserPromptSubmit Hook\n * Detects user satisfaction signals from conversation patterns\n * CC 2.1.7 Compliant\n *\n * Strategy:\n * - Analyze user prompt for positive/negative signals\n * - Track satisfaction per session\n * - Log to feedback system for reporting\n *\n * Performance optimization:\n * - Sampling mode: only analyzes every Nth prompt to reduce overhead\n * - Configure via SATISFACTION_SAMPLE_RATE (default: 3)\n *\n * Part of Feedback System (#57)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\nimport { existsSync, readFileSync, writeFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// Configuration\nconst MIN_PROMPT_LENGTH = 2;\n\n// Positive signal patterns\nconst POSITIVE_PATTERNS = [\n  /\\bthank/i,\n  /\\bgreat\\b/i,\n  /\\bperfect\\b/i,\n  /\\bexcellent\\b/i,\n  /\\bawesome\\b/i,\n  /\\bworks?\\b.*\\b(well|great|perfectly)/i,\n  /\\bthat('s| is) (exactly|just) what/i,\n  /\\bnice\\b/i,\n  /\\bgood job\\b/i,\n  /\\bwell done\\b/i,\n  /\\blooks? good\\b/i,\n  /\\blgtm\\b/i,\n  /\\bship it\\b/i,\n];\n\n// Negative signal patterns\nconst NEGATIVE_PATTERNS = [\n  /\\bno(t| ).*right/i,\n  /\\bwrong\\b/i,\n  /\\bdoesn't work/i,\n  /\\bbroken\\b/i,\n  /\\bfailed\\b/i,\n  /\\btry again\\b/i,\n  /\\bstart over\\b/i,\n  /\\bundo\\b/i,\n  /\\brevert\\b/i,\n  /\\bfrustrat/i,\n  /\\bannoy/i,\n  /\\bconfus/i,\n  /\\bstill (not|doesn't)/i,\n  /\\bdidn't (work|help)/i,\n  /\\bthat's not/i,\n];\n\n/**\n * Detect satisfaction from prompt\n */\nfunction detectSatisfaction(prompt: string): 'positive' | 'negative' | 'neutral' {\n  // Check positive patterns\n  for (const pattern of POSITIVE_PATTERNS) {\n    if (pattern.test(prompt)) {\n      return 'positive';\n    }\n  }\n\n  // Check negative patterns\n  for (const pattern of NEGATIVE_PATTERNS) {\n    if (pattern.test(prompt)) {\n      return 'negative';\n    }\n  }\n\n  return 'neutral';\n}\n\n/**\n * Get counter file path\n */\nfunction getCounterFilePath(projectDir: string): string {\n  return join(projectDir, '.claude', '.satisfaction-counter');\n}\n\n/**\n * Get or increment counter for sampling\n */\nfunction getAndIncrementCounter(projectDir: string): number {\n  const counterFile = getCounterFilePath(projectDir);\n\n  // Ensure directory exists\n  const dir = dirname(counterFile);\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n\n  let counter = 0;\n  if (existsSync(counterFile)) {\n    try {\n      counter = parseInt(readFileSync(counterFile, 'utf8').trim(), 10) || 0;\n    } catch {\n      // Ignore\n    }\n  }\n\n  counter++;\n\n  try {\n    writeFileSync(counterFile, String(counter));\n  } catch {\n    // Ignore\n  }\n\n  return counter;\n}\n\n/**\n * Log satisfaction signal to feedback file\n */\nfunction logSatisfaction(sessionId: string, sentiment: string, context: string, projectDir: string): void {\n  const feedbackDir = join(projectDir, '.claude', 'feedback');\n  const logFile = join(feedbackDir, 'satisfaction.log');\n\n  // Ensure directory exists\n  if (!existsSync(feedbackDir)) {\n    try {\n      mkdirSync(feedbackDir, { recursive: true });\n    } catch {\n      return;\n    }\n  }\n\n  const timestamp = new Date().toISOString();\n  const logEntry = `${timestamp} | ${sessionId} | ${sentiment} | ${context}\\n`;\n\n  try {\n    appendFileSync(logFile, logEntry);\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n/**\n * Satisfaction detector hook\n */\nexport function satisfactionDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionId = input.session_id || getSessionId();\n\n  // Get sample rate from environment (default: 3)\n  const sampleRate = parseInt(process.env.SATISFACTION_SAMPLE_RATE || '3', 10);\n\n  // Get and increment counter for sampling\n  const counter = getAndIncrementCounter(projectDir);\n\n  // Skip if not on sampling interval (for performance)\n  if (sampleRate > 1 && counter % sampleRate !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('satisfaction-detector', `Satisfaction detector hook starting (sample ${counter})`);\n\n  // Skip empty prompts\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  // Skip very short prompts (likely commands)\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Skip prompts that look like commands (start with /)\n  if (prompt.startsWith('/')) {\n    return outputSilentSuccess();\n  }\n\n  // Detect satisfaction\n  const sentiment = detectSatisfaction(prompt);\n\n  // Only log non-neutral signals to avoid noise\n  if (sentiment !== 'neutral') {\n    // Truncate context for logging\n    let context = prompt.slice(0, 50);\n    if (prompt.length > 50) {\n      context += '...';\n    }\n\n    // Log the satisfaction signal\n    logSatisfaction(sessionId, sentiment, context, projectDir);\n\n    logHook('satisfaction-detector', `Detected ${sentiment} satisfaction signal`);\n  }\n\n  // Output CC 2.1.7 compliant JSON (silent success)\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Auto-Suggest - UserPromptSubmit Hook\n * Proactive skill suggestion based on prompt analysis\n * Issue #123: Skill Auto-Suggest Hook\n *\n * Analyzes user prompts for task keywords and suggests relevant skills\n * from the skills/ directory via CC 2.1.9 additionalContext injection.\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for suggestions\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getPluginRoot } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Maximum number of skills to suggest\nconst MAX_SUGGESTIONS = 3;\n\n// Minimum confidence score (0-100) to include a skill\nconst MIN_CONFIDENCE = 30;\n\n// Keyword-to-Skill mapping\n// Format: [keyword, skillName, confidenceBoost]\nconst KEYWORD_MAPPINGS: Array<[string, string, number]> = [\n  // API & Backend\n  ['api', 'api-design-framework', 80],\n  ['endpoint', 'api-design-framework', 70],\n  ['rest', 'api-design-framework', 75],\n  ['graphql', 'api-design-framework', 75],\n  ['route', 'api-design-framework', 60],\n  ['fastapi', 'fastapi-advanced', 90],\n  ['uvicorn', 'fastapi-advanced', 70],\n  ['starlette', 'fastapi-advanced', 60],\n  ['middleware', 'fastapi-advanced', 50],\n  ['pydantic', 'fastapi-advanced', 60],\n\n  // Database\n  ['database', 'database-schema-designer', 80],\n  ['schema', 'database-schema-designer', 70],\n  ['table', 'database-schema-designer', 50],\n  ['migration', 'alembic-migrations', 85],\n  ['alembic', 'alembic-migrations', 95],\n  ['sql', 'database-schema-designer', 60],\n  ['postgres', 'database-schema-designer', 70],\n  ['query', 'database-schema-designer', 40],\n  ['index', 'database-schema-designer', 50],\n  ['sqlalchemy', 'sqlalchemy-2-async', 85],\n  ['async.*database', 'sqlalchemy-2-async', 80],\n  ['orm', 'sqlalchemy-2-async', 60],\n  ['connection.*pool', 'connection-pooling', 90],\n  ['pool', 'connection-pooling', 60],\n  ['pgvector', 'pgvector-search', 95],\n  ['vector.*search', 'pgvector-search', 85],\n  ['embedding', 'embeddings', 80],\n\n  // Authentication & Security\n  ['auth', 'auth-patterns', 85],\n  ['login', 'auth-patterns', 75],\n  ['jwt', 'auth-patterns', 80],\n  ['oauth', 'auth-patterns', 85],\n  ['passkey', 'auth-patterns', 90],\n  ['webauthn', 'auth-patterns', 90],\n  ['session', 'auth-patterns', 60],\n  ['password', 'auth-patterns', 70],\n  ['security', 'owasp-top-10', 75],\n  ['owasp', 'owasp-top-10', 95],\n  ['xss', 'owasp-top-10', 80],\n  ['injection', 'owasp-top-10', 80],\n  ['csrf', 'owasp-top-10', 80],\n  ['validation', 'input-validation', 70],\n  ['sanitiz', 'input-validation', 80],\n  ['defense.*depth', 'defense-in-depth', 95],\n\n  // Testing\n  ['test', 'integration-testing', 60],\n  ['unit.*test', 'pytest-advanced', 80],\n  ['pytest', 'pytest-advanced', 90],\n  ['integration.*test', 'integration-testing', 85],\n  ['e2e', 'e2e-testing', 90],\n  ['playwright', 'e2e-testing', 80],\n  ['mock', 'msw-mocking', 75],\n  ['msw', 'msw-mocking', 95],\n  ['fixture', 'test-data-management', 80],\n  ['test.*data', 'test-data-management', 85],\n  ['coverage', 'pytest-advanced', 60],\n  ['property.*test', 'property-based-testing', 90],\n  ['hypothesis', 'property-based-testing', 95],\n  ['contract.*test', 'contract-testing', 95],\n  ['pact', 'contract-testing', 95],\n  ['golden.*dataset', 'golden-dataset-validation', 90],\n  ['performance.*test', 'performance-testing', 90],\n  ['load.*test', 'performance-testing', 85],\n  ['k6', 'performance-testing', 95],\n  ['locust', 'performance-testing', 95],\n\n  // Frontend & React\n  ['react', 'react-server-components-framework', 70],\n  ['component', 'react-server-components-framework', 50],\n  ['server.*component', 'react-server-components-framework', 95],\n  ['nextjs', 'react-server-components-framework', 85],\n  ['next\\\\.js', 'react-server-components-framework', 85],\n  ['suspense', 'react-server-components-framework', 70],\n  ['streaming.*ssr', 'react-server-components-framework', 90],\n  ['form', 'form-state-patterns', 70],\n  ['react.*hook.*form', 'form-state-patterns', 95],\n  ['zod', 'form-state-patterns', 60],\n  ['zustand', 'zustand-patterns', 95],\n  ['state.*management', 'zustand-patterns', 70],\n  ['tanstack', 'tanstack-query-advanced', 90],\n  ['react.*query', 'tanstack-query-advanced', 85],\n  ['radix', 'radix-primitives', 95],\n  ['shadcn', 'radix-primitives', 80],\n  ['tailwind', 'design-system-starter', 60],\n  ['design.*system', 'design-system-starter', 85],\n  ['animation', 'motion-animation-patterns', 80],\n  ['framer', 'motion-animation-patterns', 90],\n  ['core.*web.*vital', 'core-web-vitals', 95],\n  ['lcp', 'core-web-vitals', 80],\n  ['cls', 'core-web-vitals', 80],\n  ['inp', 'core-web-vitals', 80],\n  ['i18n', 'i18n-date-patterns', 90],\n  ['internationalization', 'i18n-date-patterns', 95],\n  ['locale', 'i18n-date-patterns', 70],\n\n  // Accessibility\n  ['accessibility', 'a11y-testing', 85],\n  ['a11y', 'a11y-testing', 95],\n  ['wcag', 'a11y-testing', 95],\n  ['screen.*reader', 'focus-management', 80],\n  ['keyboard.*nav', 'focus-management', 90],\n  ['focus', 'focus-management', 60],\n  ['aria', 'focus-management', 70],\n\n  // AI/LLM\n  ['llm', 'function-calling', 70],\n  ['openai', 'function-calling', 60],\n  ['anthropic', 'function-calling', 60],\n  ['function.*call', 'function-calling', 90],\n  ['tool.*use', 'function-calling', 85],\n  ['stream', 'llm-streaming', 70],\n  ['rag', 'rag-retrieval', 95],\n  ['retrieval', 'rag-retrieval', 75],\n  ['context', 'contextual-retrieval', 60],\n  ['chunk', 'embeddings', 70],\n  ['vector', 'embeddings', 75],\n  ['semantic.*search', 'embeddings', 85],\n  ['langfuse', 'langfuse-observability', 95],\n  ['llm.*observ', 'langfuse-observability', 90],\n  ['langgraph', 'langgraph-state', 85],\n  ['agent', 'agent-loops', 70],\n  ['workflow', 'langgraph-state', 60],\n  ['supervisor', 'langgraph-supervisor', 90],\n  ['human.*in.*loop', 'langgraph-human-in-loop', 95],\n  ['checkpoint', 'langgraph-checkpoints', 90],\n  ['prompt.*cache', 'prompt-caching', 95],\n  ['cache.*llm', 'semantic-caching', 85],\n  ['eval', 'llm-evaluation', 70],\n  ['llm.*test', 'llm-testing', 85],\n  ['ollama', 'ollama-local', 95],\n\n  // DevOps & Infrastructure\n  ['deploy', 'devops-deployment', 75],\n  ['ci', 'devops-deployment', 60],\n  ['cd', 'devops-deployment', 60],\n  ['github.*action', 'github-operations', 85],\n  ['release', 'release-management', 80],\n  ['changelog', 'release-management', 70],\n  ['version', 'release-management', 50],\n  ['observ', 'observability-monitoring', 80],\n  ['monitor', 'observability-monitoring', 70],\n  ['log', 'observability-monitoring', 50],\n  ['metric', 'observability-monitoring', 60],\n  ['trace', 'observability-monitoring', 70],\n  ['alert', 'observability-monitoring', 60],\n\n  // Git & GitHub\n  ['git', 'git-workflow', 70],\n  ['branch', 'git-workflow', 60],\n  ['commit', 'commit', 80],\n  ['rebase', 'git-workflow', 70],\n  ['stacked.*pr', 'stacked-prs', 95],\n  ['pr', 'create-pr', 60],\n  ['pull.*request', 'create-pr', 75],\n  ['recovery', 'git-recovery-command', 80],\n  ['reflog', 'git-recovery-command', 95],\n  ['milestone', 'github-operations', 80],\n  ['issue', 'github-operations', 50],\n\n  // Event-Driven & Messaging\n  ['event.*sourc', 'event-sourcing', 95],\n  ['kafka', 'message-queues', 85],\n  ['rabbitmq', 'message-queues', 85],\n  ['queue', 'message-queues', 75],\n  ['pub.*sub', 'message-queues', 80],\n  ['outbox', 'outbox-pattern', 95],\n  ['saga', 'event-sourcing', 70],\n  ['cqrs', 'event-sourcing', 80],\n\n  // Async & Concurrency\n  ['async', 'asyncio-advanced', 70],\n  ['asyncio', 'asyncio-advanced', 90],\n  ['taskgroup', 'asyncio-advanced', 95],\n  ['concurrent', 'asyncio-advanced', 60],\n  ['background.*job', 'background-jobs', 90],\n  ['celery', 'background-jobs', 95],\n  ['worker', 'background-jobs', 60],\n  ['distributed.*lock', 'distributed-locks', 95],\n  ['redis.*lock', 'distributed-locks', 85],\n  ['idempoten', 'idempotency-patterns', 95],\n\n  // Architecture & Patterns\n  ['clean.*architecture', 'clean-architecture', 95],\n  ['ddd', 'domain-driven-design', 95],\n  ['domain.*driven', 'domain-driven-design', 90],\n  ['aggregate', 'aggregate-patterns', 90],\n  ['adr', 'architecture-decision-record', 95],\n  ['decision.*record', 'architecture-decision-record', 85],\n\n  // Code Quality\n  ['lint', 'biome-linting', 70],\n  ['biome', 'biome-linting', 95],\n  ['eslint', 'biome-linting', 60],\n  ['format', 'biome-linting', 50],\n  ['code.*review', 'code-review-playbook', 90],\n  ['review', 'code-review-playbook', 60],\n  ['quality.*gate', 'quality-gates', 90],\n\n  // Error Handling\n  ['error.*handl', 'error-handling-rfc9457', 85],\n  ['rfc.*9457', 'error-handling-rfc9457', 95],\n  ['problem.*detail', 'error-handling-rfc9457', 90],\n];\n\ninterface SkillMatch {\n  skill: string;\n  confidence: number;\n}\n\n/**\n * Find matching skills based on prompt keywords\n */\nfunction findMatchingSkills(prompt: string): SkillMatch[] {\n  const promptLower = prompt.toLowerCase();\n  const skillScores = new Map<string, number>();\n\n  for (const [keyword, skill, confidence] of KEYWORD_MAPPINGS) {\n    // Convert keyword to regex pattern\n    const regex = new RegExp(keyword, 'i');\n\n    if (regex.test(promptLower)) {\n      const currentScore = skillScores.get(skill) || 0;\n      if (confidence > currentScore) {\n        skillScores.set(skill, confidence);\n      }\n    }\n  }\n\n  // Convert to array and sort by confidence\n  const matches: SkillMatch[] = Array.from(skillScores.entries())\n    .map(([skill, confidence]) => ({ skill, confidence }))\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, MAX_SUGGESTIONS);\n\n  return matches;\n}\n\n/**\n * Get skill description from SKILL.md frontmatter\n */\nfunction getSkillDescription(skillName: string, skillsDir: string): string {\n  const skillFile = join(skillsDir, skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) {\n    return '';\n  }\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n\n    // Extract description from YAML frontmatter\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (frontmatterMatch) {\n      const frontmatter = frontmatterMatch[1];\n      const descriptionMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n      if (descriptionMatch) {\n        return descriptionMatch[1].trim();\n      }\n    }\n  } catch {\n    // Ignore\n  }\n\n  return '';\n}\n\n/**\n * Build suggestion message for Claude\n */\nfunction buildSuggestionMessage(matches: SkillMatch[], skillsDir: string): string {\n  if (matches.length === 0) {\n    return '';\n  }\n\n  let message = `## Relevant Skills Detected\n\nBased on your prompt, the following skills may be helpful:\n\n`;\n\n  for (const { skill, confidence } of matches) {\n    if (confidence >= MIN_CONFIDENCE) {\n      const description = getSkillDescription(skill, skillsDir);\n      if (description) {\n        message += `- **${skill}** (${confidence}% match): ${description}\\n`;\n      } else {\n        message += `- **${skill}** (${confidence}% match)\\n`;\n      }\n    }\n  }\n\n  message += `\nUse \\`/ork:<skill-name>\\` to invoke a user-invocable skill, or read the skill with \\`Read skills/<skill-name>/SKILL.md\\` for patterns and guidance.`;\n\n  return message;\n}\n\n/**\n * Skill auto-suggest hook\n */\nexport function skillAutoSuggest(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const pluginRoot = getPluginRoot();\n  const skillsDir = join(pluginRoot, 'skills');\n\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  logHook('skill-auto-suggest', 'Analyzing prompt for skill suggestions...');\n\n  // Find matching skills\n  const matches = findMatchingSkills(prompt);\n\n  if (matches.length === 0) {\n    logHook('skill-auto-suggest', 'No skill matches found');\n    return outputSilentSuccess();\n  }\n\n  logHook(\n    'skill-auto-suggest',\n    `Found matches: ${matches.map((m) => `${m.skill}:${m.confidence}`).join(', ')}`\n  );\n\n  // Build suggestion message\n  const suggestionMessage = buildSuggestionMessage(matches, skillsDir);\n\n  if (suggestionMessage) {\n    logHook('skill-auto-suggest', 'Injecting skill suggestions via additionalContext');\n    return outputPromptContext(suggestionMessage);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Todo Enforcer - UserPromptSubmit Hook\n * Reminds about todo tracking for complex tasks\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\n// Complex task indicators (regex patterns)\nconst COMPLEX_PATTERNS = [\n  /implement/i,\n  /refactor/i,\n  /add feature/i,\n  /create.*component/i,\n  /build.*system/i,\n  /fix.*multiple/i,\n  /update.*across/i,\n  /migrate/i,\n];\n\n// Threshold for long prompts (often indicate complex tasks)\nconst LONG_PROMPT_THRESHOLD = 500;\n\n/**\n * Todo enforcer hook - detects complex tasks\n */\nexport function todoEnforcer(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const promptLength = prompt.length;\n\n  logHook('todo-enforcer', `Prompt length: ${promptLength} chars`);\n\n  let isComplex = false;\n\n  // Check for complex task patterns\n  for (const pattern of COMPLEX_PATTERNS) {\n    if (pattern.test(prompt)) {\n      isComplex = true;\n      break;\n    }\n  }\n\n  // Long prompts often indicate complex tasks\n  if (promptLength > LONG_PROMPT_THRESHOLD) {\n    isComplex = true;\n  }\n\n  if (isComplex) {\n    logHook('todo-enforcer', 'Complex task detected - todo tracking recommended');\n  }\n\n  // Output systemMessage for user visibility\n  // Currently outputs silent success - could be enhanced to inject context\n  return outputSilentSuccess();\n}\n", "/**\n * Agent Auto-Suggest - UserPromptSubmit Hook\n * Proactive agent dispatch suggestion based on prompt analysis\n * Issue #197: Agent Orchestration Layer\n *\n * NOW USES: Intent Classifier for hybrid semantic+keyword scoring\n * Target: 85%+ accuracy vs ~60% regex baseline\n *\n * This is the LEGACY hook maintained for backward compatibility.\n * The new agent-orchestrator.ts provides full orchestration with\n * task integration. This hook provides simple suggestions only.\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport { getAdjustments } from '../lib/calibration-engine.js';\nimport { getPromptHistory, loadConfig } from '../lib/orchestration-state.js';\nimport type { AgentMatch } from '../lib/orchestration-types.js';\nimport { THRESHOLDS } from '../lib/orchestration-types.js';\n\n// Maximum number of agents to suggest\nconst MAX_SUGGESTIONS = 2;\n\n/**\n * Build suggestion message based on confidence level\n * (Backward compatible message format)\n */\nfunction buildSuggestionMessage(matches: AgentMatch[]): string {\n  if (matches.length === 0) return '';\n\n  const topMatch = matches[0];\n  let message = '';\n\n  if (topMatch.confidence >= THRESHOLDS.AUTO_DISPATCH) {\n    // HIGH CONFIDENCE - Strong directive\n    message = `## \uD83C\uDFAF AGENT DISPATCH RECOMMENDED\n\n**Agent:** \\`${topMatch.agent}\\` (${topMatch.confidence}% confidence)\n\nThis task strongly matches the agent's specialization. **Spawn this agent:**\n\n\\`\\`\\`\nTask tool with subagent_type: \"${topMatch.agent}\"\n\\`\\`\\`\n\nMatched: ${topMatch.matchedKeywords.slice(0, 5).join(', ')}`;\n\n  } else if (topMatch.confidence >= THRESHOLDS.STRONG_RECOMMEND) {\n    // MEDIUM-HIGH - Recommendation\n    message = `## Agent Recommendation\n\n**RECOMMENDED:** \\`${topMatch.agent}\\` (${topMatch.confidence}% match)\n${topMatch.description}\n\nMatched keywords: ${topMatch.matchedKeywords.slice(0, 4).join(', ')}\n\nConsider spawning with: \\`Task tool, subagent_type: \"${topMatch.agent}\"\\``;\n\n  } else if (topMatch.confidence >= THRESHOLDS.SUGGEST) {\n    // MEDIUM - Suggestion\n    message = `## Agent Suggestion\n\n**Consider:** \\`${topMatch.agent}\\` (${topMatch.confidence}% match)\n\nThis agent specializes in: ${topMatch.matchedKeywords.slice(0, 3).join(', ')}`;\n  }\n\n  // Add second match if exists and significant\n  if (matches.length > 1 && matches[1].confidence >= THRESHOLDS.SUGGEST) {\n    const second = matches[1];\n    message += `\\n\\n**Alternative:** \\`${second.agent}\\` (${second.confidence}% match)`;\n  }\n\n  return message;\n}\n\n/**\n * Agent auto-suggest hook\n *\n * Uses the new intent classifier for improved accuracy:\n * - Hybrid keyword + phrase + context scoring\n * - Calibration adjustments from outcome learning\n * - Negation detection to reduce false positives\n */\nexport function agentAutoSuggest(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filter using classifier's shouldClassify\n  if (!shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  // Skip if agent-orchestrator is enabled (let it handle classification)\n  const config = loadConfig();\n  if (config.enableAutoDispatch) {\n    // agent-orchestrator.ts will handle this\n    logHook('agent-auto-suggest', 'Deferring to agent-orchestrator (auto-dispatch enabled)');\n    return outputSilentSuccess();\n  }\n\n  logHook('agent-auto-suggest', 'Analyzing prompt with intent classifier...');\n\n  // Get context for classification\n  const history = getPromptHistory();\n  const adjustments = getAdjustments();\n\n  // Run classification\n  const result = classifyIntent(prompt, history, adjustments);\n\n  // Filter to top suggestions\n  const matches = result.agents.slice(0, MAX_SUGGESTIONS);\n\n  if (matches.length === 0) {\n    logHook('agent-auto-suggest', 'No agent matches found');\n    return outputSilentSuccess();\n  }\n\n  logHook(\n    'agent-auto-suggest',\n    `Found matches: ${matches.map(m => `${m.agent}:${m.confidence}`).join(', ')}`\n  );\n\n  // Build suggestion message (backward compatible format)\n  const suggestionMessage = buildSuggestionMessage(matches);\n\n  if (suggestionMessage) {\n    logHook('agent-auto-suggest', `Suggesting ${matches[0].agent} at ${matches[0].confidence}%`);\n    return outputPromptContext(suggestionMessage);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Agent Orchestrator - Main UserPromptSubmit Hook for Auto-Dispatch\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * At confidence >= 85%: AUTO-DISPATCH directive\n * At confidence 70-84%: Strong recommendation\n * At confidence 50-69%: Suggestion\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n * CC 2.1.16 Compliant: Outputs TaskCreate instructions for task management\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport {\n  loadConfig,\n  addToPromptHistory,\n  cacheClassification,\n  isAgentDispatched,\n  trackDispatchedAgent,\n  getPromptHistory,\n} from '../lib/orchestration-state.js';\nimport type {\n  ClassificationResult,\n  AgentMatch,\n  TaskMetadata,\n} from '../lib/orchestration-types.js';\nimport { THRESHOLDS } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Message Builders\n// -----------------------------------------------------------------------------\n\n/**\n * Build auto-dispatch directive message (conf >= 85%)\n */\nfunction buildAutoDispatchMessage(match: AgentMatch, taskMeta: TaskMetadata): string {\n  return `## \uD83C\uDFAF AUTO-DISPATCH: ${match.agent}\n\n**Confidence:** ${match.confidence}% (auto-dispatch threshold: ${THRESHOLDS.AUTO_DISPATCH}%)\n\nThis task strongly matches the agent's specialization. **IMMEDIATELY spawn this agent:**\n\n\\`\\`\\`\nTask tool with subagent_type: \"${match.agent}\"\n\\`\\`\\`\n\n**Matched Keywords:** ${match.matchedKeywords.slice(0, 5).join(', ')}\n\n### CC 2.1.16 Task Instruction\nBefore spawning, create a task to track this work:\n\n\\`\\`\\`json\nTaskCreate:\n{\n  \"subject\": \"${match.agent.replace(/-/g, ' ')} implementation\",\n  \"description\": \"Agent dispatched automatically at ${match.confidence}% confidence\",\n  \"activeForm\": \"Working on ${match.description.toLowerCase()}\",\n  \"metadata\": ${JSON.stringify(taskMeta)}\n}\n\\`\\`\\`\n\nAfter creating the task, spawn the agent with the task ID in the prompt.`;\n}\n\n/**\n * Build strong recommendation message (conf 70-84%)\n */\nfunction buildStrongRecommendMessage(match: AgentMatch): string {\n  return `## Agent Recommendation\n\n**RECOMMENDED:** \\`${match.agent}\\` (${match.confidence}% confidence)\n\n${match.description}\n\n**Matched:** ${match.matchedKeywords.slice(0, 4).join(', ')}\n\n**Spawn with:**\n\\`\\`\\`\nTask tool with subagent_type: \"${match.agent}\"\n\\`\\`\\``;\n}\n\n/**\n * Build suggestion message (conf 50-69%)\n */\nfunction buildSuggestionMessage(match: AgentMatch): string {\n  return `## Agent Suggestion\n\n**Consider:** \\`${match.agent}\\` (${match.confidence}% match)\n\nThis agent specializes in: ${match.matchedKeywords.slice(0, 3).join(', ')}`;\n}\n\n/**\n * Build alternative agent note\n */\nfunction buildAlternativeNote(match: AgentMatch): string {\n  return `\\n\\n**Alternative:** \\`${match.agent}\\` (${match.confidence}% match)`;\n}\n\n/**\n * Build the complete orchestration message\n */\nfunction buildOrchestrationMessage(\n  result: ClassificationResult,\n  config: ReturnType<typeof loadConfig>\n): string {\n  if (result.agents.length === 0) {\n    return '';\n  }\n\n  const topMatch = result.agents[0];\n  let message = '';\n\n  // Check if already dispatched\n  if (isAgentDispatched(topMatch.agent)) {\n    logHook('agent-orchestrator', `Agent ${topMatch.agent} already dispatched, skipping`);\n    return '';\n  }\n\n  // Auto-dispatch at high confidence\n  if (\n    config.enableAutoDispatch &&\n    topMatch.confidence >= THRESHOLDS.AUTO_DISPATCH\n  ) {\n    const taskMeta: TaskMetadata = {\n      source: 'orchestration',\n      dispatchedAgent: topMatch.agent,\n      dispatchConfidence: topMatch.confidence,\n      relatedSkills: result.skills.slice(0, 3).map(s => s.skill),\n      dispatchSignals: topMatch.signals.slice(0, 5),\n    };\n\n    // Track the dispatch\n    trackDispatchedAgent(topMatch.agent, topMatch.confidence);\n\n    message = buildAutoDispatchMessage(topMatch, taskMeta);\n\n  } else if (topMatch.confidence >= THRESHOLDS.STRONG_RECOMMEND) {\n    // Strong recommendation\n    message = buildStrongRecommendMessage(topMatch);\n\n  } else if (topMatch.confidence >= THRESHOLDS.SUGGEST) {\n    // Suggestion\n    message = buildSuggestionMessage(topMatch);\n  }\n\n  // Add alternative if significant\n  if (\n    result.agents.length > 1 &&\n    result.agents[1].confidence >= THRESHOLDS.SUGGEST\n  ) {\n    message += buildAlternativeNote(result.agents[1]);\n  }\n\n  return message;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Agent orchestrator hook - main entry point\n *\n * Analyzes user prompts and either:\n * 1. Auto-dispatches agents at 85%+ confidence\n * 2. Strongly recommends agents at 70-84%\n * 3. Suggests agents at 50-69%\n *\n * Also integrates with CC 2.1.16 task management.\n */\nexport function agentOrchestrator(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filter\n  if (!shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('agent-orchestrator', 'Classifying intent for orchestration...');\n\n  // Load config and state\n  const config = loadConfig();\n  const history = getPromptHistory();\n\n  // Run classification\n  const result = classifyIntent(prompt, history);\n\n  // Cache classification for later use\n  cacheClassification(result);\n\n  // Add to prompt history\n  addToPromptHistory(prompt.slice(0, 500)); // Truncate for storage\n\n  // Log classification\n  logHook(\n    'agent-orchestrator',\n    `Classification: intent=${result.intent}, ` +\n    `agents=[${result.agents.map(a => `${a.agent}:${a.confidence}`).join(', ')}], ` +\n    `autoDispatch=${result.shouldAutoDispatch}`\n  );\n\n  // No matches\n  if (result.agents.length === 0) {\n    logHook('agent-orchestrator', 'No agent matches found');\n    return outputSilentSuccess();\n  }\n\n  // Build orchestration message\n  const message = buildOrchestrationMessage(result, config);\n\n  if (message) {\n    return outputPromptContext(message);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Injector - UserPromptSubmit Hook for Auto-Injecting Skill Content\n * Issue #197: Agent Orchestration Layer\n *\n * At confidence >= 80%: Auto-injects skill SKILL.md content\n * Maximum 800 tokens per skill injection to respect context budget\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getPluginRoot } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport {\n  loadConfig,\n  isSkillInjected,\n  trackInjectedSkill,\n  getLastClassification,\n} from '../lib/orchestration-state.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport { THRESHOLDS } from '../lib/orchestration-types.js';\nimport type { ClassificationResult } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum tokens for skill content injection */\nconst MAX_INJECTION_TOKENS = 800;\n\n/** Approximate characters per token */\nconst CHARS_PER_TOKEN = 4;\n\n/** Maximum skills to inject per prompt */\nconst MAX_SKILLS_PER_PROMPT = 2;\n\n// -----------------------------------------------------------------------------\n// Skill Content Loading\n// -----------------------------------------------------------------------------\n\n/**\n * Load skill content from SKILL.md\n * Returns truncated content to fit within token budget\n */\nfunction loadSkillContent(skillName: string, maxTokens: number): string | null {\n  const pluginRoot = getPluginRoot();\n  const skillFile = join(pluginRoot, 'skills', skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) {\n    logHook('skill-injector', `Skill file not found: ${skillFile}`);\n    return null;\n  }\n\n  try {\n    let content = readFileSync(skillFile, 'utf8');\n\n    // Remove frontmatter\n    const frontmatterMatch = content.match(/^---\\n[\\s\\S]*?\\n---\\n/);\n    if (frontmatterMatch) {\n      content = content.slice(frontmatterMatch[0].length);\n    }\n\n    // Trim whitespace\n    content = content.trim();\n\n    // Truncate to token budget\n    const maxChars = maxTokens * CHARS_PER_TOKEN;\n    if (content.length > maxChars) {\n      // Try to break at a paragraph\n      const truncated = content.slice(0, maxChars);\n      const lastParagraph = truncated.lastIndexOf('\\n\\n');\n      if (lastParagraph > maxChars * 0.6) {\n        content = truncated.slice(0, lastParagraph) + '\\n\\n[... truncated for context budget]';\n      } else {\n        content = truncated + '\\n\\n[... truncated for context budget]';\n      }\n    }\n\n    return content;\n  } catch (err) {\n    logHook('skill-injector', `Failed to load skill: ${err}`);\n    return null;\n  }\n}\n\n/**\n * Calculate token estimate for content\n */\nfunction estimateTokens(content: string): number {\n  return Math.ceil(content.length / CHARS_PER_TOKEN);\n}\n\n// -----------------------------------------------------------------------------\n// Message Building\n// -----------------------------------------------------------------------------\n\n/**\n * Build injection message for skills\n */\nfunction buildInjectionMessage(skills: Array<{ skill: string; content: string }>): string {\n  if (skills.length === 0) return '';\n\n  let message = `## \uD83D\uDCDA Skill Knowledge Injected\n\nThe following skill patterns have been auto-loaded based on your prompt:\n\n`;\n\n  for (const { skill, content } of skills) {\n    message += `### ${skill}\n\n${content}\n\n---\n\n`;\n  }\n\n  message += `*Auto-injected by OrchestKit Agent Orchestration Layer*`;\n\n  return message;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Skill injector hook\n *\n * Automatically injects relevant skill content when:\n * 1. Skill match confidence >= 80%\n * 2. Skill not already injected in session\n * 3. Within token budget\n */\nexport function skillInjector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filter\n  if (!shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  // Load config\n  const config = loadConfig();\n\n  if (!config.enableSkillInjection) {\n    return outputSilentSuccess();\n  }\n\n  logHook('skill-injector', 'Checking for skill injection...');\n\n  // Try to use cached classification from agent-orchestrator\n  let result: ClassificationResult | undefined = getLastClassification();\n\n  // If no cached result, run classification\n  if (!result) {\n    result = classifyIntent(prompt);\n  }\n\n  // Filter skills above injection threshold\n  const eligibleSkills = result.skills.filter(\n    s => s.confidence >= THRESHOLDS.SKILL_INJECT && !isSkillInjected(s.skill)\n  );\n\n  if (eligibleSkills.length === 0) {\n    logHook('skill-injector', 'No eligible skills for injection');\n    return outputSilentSuccess();\n  }\n\n  // Calculate token budget per skill\n  const maxTotalTokens = config.maxSkillInjectionTokens || MAX_INJECTION_TOKENS;\n  const skillCount = Math.min(eligibleSkills.length, MAX_SKILLS_PER_PROMPT);\n  const tokensPerSkill = Math.floor(maxTotalTokens / skillCount);\n\n  // Load skill content\n  const loadedSkills: Array<{ skill: string; content: string }> = [];\n  let totalTokens = 0;\n\n  for (const match of eligibleSkills.slice(0, MAX_SKILLS_PER_PROMPT)) {\n    const remainingTokens = maxTotalTokens - totalTokens;\n    if (remainingTokens < 100) break; // Minimum useful content\n\n    const content = loadSkillContent(match.skill, Math.min(tokensPerSkill, remainingTokens));\n\n    if (content) {\n      const tokens = estimateTokens(content);\n      totalTokens += tokens;\n\n      loadedSkills.push({ skill: match.skill, content });\n      trackInjectedSkill(match.skill);\n\n      logHook('skill-injector', `Loaded skill ${match.skill} (~${tokens} tokens)`);\n    }\n  }\n\n  if (loadedSkills.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  // Build injection message\n  const message = buildInjectionMessage(loadedSkills);\n\n  logHook(\n    'skill-injector',\n    `Injecting ${loadedSkills.length} skills (~${totalTokens} tokens): ${loadedSkills.map(s => s.skill).join(', ')}`\n  );\n\n  return outputPromptContext(message);\n}\n", "/**\n * Pipeline Detector - UserPromptSubmit Hook for Multi-Agent Workflows\n * Issue #197: Agent Orchestration Layer\n *\n * Detects multi-agent pipeline triggers in prompts:\n * - Product thinking: \"should we build...\"\n * - Full-stack feature: \"build a full-stack feature...\"\n * - AI integration: \"add RAG/LLM...\"\n * - Security audit: \"security audit...\"\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { loadConfig } from '../lib/orchestration-state.js';\nimport {\n  detectPipeline,\n  createPipelineExecution,\n  registerPipelineExecution,\n  formatPipelinePlan,\n} from '../lib/multi-agent-coordinator.js';\nimport { getActivePipeline } from '../lib/task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Minimum prompt length to consider for pipeline detection */\nconst MIN_PROMPT_LENGTH = 15;\n\n/** Words that indicate this is NOT a pipeline request */\nconst EXCLUSION_WORDS = [\n  'what is',\n  'explain',\n  'how does',\n  'tell me about',\n  'describe',\n  'list',\n  'show me',\n];\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Check if prompt is asking a question rather than requesting action\n */\nfunction isQuestionNotRequest(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const exclusion of EXCLUSION_WORDS) {\n    if (promptLower.startsWith(exclusion)) {\n      return true;\n    }\n  }\n\n  // Ends with question mark and is short\n  if (prompt.endsWith('?') && prompt.length < 100) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check if user is already in a pipeline\n */\nfunction isInActivePipeline(): boolean {\n  const active = getActivePipeline();\n  return active !== undefined && active.status === 'running';\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Pipeline detector hook\n *\n * Detects multi-agent workflow patterns:\n * 1. Checks if prompt matches pipeline triggers\n * 2. Creates pipeline execution plan\n * 3. Outputs task creation instructions\n */\nexport function pipelineDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filters\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  if (isQuestionNotRequest(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  // Check config\n  const config = loadConfig();\n  if (!config.enablePipelines) {\n    return outputSilentSuccess();\n  }\n\n  // Check if already in pipeline\n  if (isInActivePipeline()) {\n    logHook('pipeline-detector', 'Already in active pipeline, skipping detection');\n    return outputSilentSuccess();\n  }\n\n  logHook('pipeline-detector', 'Checking for pipeline triggers...');\n\n  // Detect pipeline\n  const pipeline = detectPipeline(prompt);\n\n  if (!pipeline) {\n    logHook('pipeline-detector', 'No pipeline triggers detected');\n    return outputSilentSuccess();\n  }\n\n  logHook('pipeline-detector', `Detected pipeline: ${pipeline.type}`);\n\n  // Create pipeline execution\n  const { execution, tasks } = createPipelineExecution(pipeline);\n\n  // Register with tracking systems\n  registerPipelineExecution(execution, tasks);\n\n  // Format plan message\n  const message = formatPipelinePlan(pipeline, execution, tasks);\n\n  logHook(\n    'pipeline-detector',\n    `Created pipeline ${execution.pipelineId} with ${tasks.length} steps`\n  );\n\n  return outputPromptContext(message);\n}\n", "/**\n * Prompt Hooks Entry Point\n *\n * Hooks that run on user prompt submission (UserPromptSubmit)\n * Bundle: prompt.mjs (~35 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\n\n// Re-export orchestration modules needed by prompt hooks\nexport * from '../lib/orchestration-types.js';\nexport * from '../lib/intent-classifier.js';\nexport * from '../lib/orchestration-state.js';\nexport * from '../lib/task-integration.js';\nexport * from '../lib/retry-manager.js';\nexport * from '../lib/calibration-engine.js';\nexport * from '../lib/multi-agent-coordinator.js';\n\n// Prompt hooks (12) - UserPromptSubmit\nimport { antipatternDetector } from '../prompt/antipattern-detector.js';\nimport { antipatternWarning } from '../prompt/antipattern-warning.js';\nimport { contextInjector } from '../prompt/context-injector.js';\nimport { contextPruningAdvisor } from '../prompt/context-pruning-advisor.js';\nimport { memoryContext } from '../prompt/memory-context.js';\nimport { satisfactionDetector } from '../prompt/satisfaction-detector.js';\nimport { skillAutoSuggest } from '../prompt/skill-auto-suggest.js';\nimport { todoEnforcer } from '../prompt/todo-enforcer.js';\nimport { agentAutoSuggest } from '../prompt/agent-auto-suggest.js';\n\n// Orchestration hooks (Issue #197)\nimport { agentOrchestrator } from '../prompt/agent-orchestrator.js';\nimport { skillInjector } from '../prompt/skill-injector.js';\nimport { pipelineDetector } from '../prompt/pipeline-detector.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Prompt hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'prompt/antipattern-detector': antipatternDetector,\n  'prompt/antipattern-warning': antipatternWarning,\n  'prompt/context-injector': contextInjector,\n  'prompt/context-pruning-advisor': contextPruningAdvisor,\n  'prompt/memory-context': memoryContext,\n  'prompt/satisfaction-detector': satisfactionDetector,\n  'prompt/skill-auto-suggest': skillAutoSuggest,\n  'prompt/todo-enforcer': todoEnforcer,\n  'prompt/agent-auto-suggest': agentAutoSuggest,\n  // Orchestration hooks (Issue #197)\n  'prompt/agent-orchestrator': agentOrchestrator,\n  'prompt/skill-injector': skillInjector,\n  'prompt/pipeline-detector': pipelineDetector,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "execSync", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "getCachedBranch", "projectDir", "branch", "getLogLevel", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "readHookInput", "chunks", "buf", "bytesRead", "fd", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "THRESHOLDS", "DEFAULT_CONFIG", "existsSync", "readFileSync", "readdirSync", "join", "SIGNAL_WEIGHTS", "NEGATION_PATTERNS", "CONTEXT_BOOST_KEYWORDS", "agentIndex", "agentIndexPath", "getAgentIndex", "agentsDir", "index", "files", "readdirSync", "f", "file", "agentName", "filePath", "join", "frontmatterMatch", "readFileSync", "frontmatter", "descMatch", "description", "activatesMatch", "descPart", "keywords", "phrases", "rawKeywords", "k", "kw", "skillsMatch", "skills", "l", "logHook", "skillIndex", "skillIndexPath", "getSkillIndex", "skillsDir", "dirs", "d", "skillName", "skillFile", "existsSync", "tagsMatch", "t", "descKeywords", "w", "calculateKeywordScore", "promptLower", "score", "matched", "signals", "keyword", "weight", "maxScore", "calculatePhraseScore", "phrase", "calculateContextScore", "history", "continuationWord", "recentHistory", "calculateNegationPenalty", "prompt", "penalty", "pattern", "applyCalibration", "matchedKeywords", "adjustments", "totalAdjustment", "adj", "classifyAgentMatch", "entry", "allSignals", "allMatched", "keywordResult", "phraseResult", "contextResult", "negationResult", "calibrationResult", "THRESHOLDS", "classifySkillMatch", "classifyIntent", "pluginRoot", "getPluginRoot", "agentMatches", "skillMatches", "agentIdx", "match", "skillIdx", "a", "b", "topAgent", "intent", "categorizeIntent", "maxConfidence", "shouldAutoDispatch", "shouldInjectSkills", "agent", "categories", "category", "categoryKeywords", "shouldClassify", "clearCache", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "ensureStateDir", "dir", "existsSync", "mkdirSync", "logHook", "loadState", "stateFile", "data", "readFileSync", "err", "saveState", "state", "writeFileSync", "updateState", "mutate", "trackDispatchedAgent", "agent", "confidence", "taskId", "dispatched", "a", "updateAgentStatus", "status", "entry", "removeAgent", "getActiveAgent", "isAgentDispatched", "trackInjectedSkill", "skill", "isSkillInjected", "getInjectedSkills", "addToPromptHistory", "prompt", "getPromptHistory", "cacheClassification", "result", "getLastClassification", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "saveConfig", "config", "merged", "clearSessionState", "unlinkSync", "cleanupOldStates", "readdirSync", "statSync", "files", "f", "b", "file", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadRegistry", "file", "readFileSync", "saveRegistry", "registry", "writeFileSync", "err", "logHook", "getActiveFormForAgent", "agent", "description", "action", "shortDesc", "generateTaskCreateInstruction", "confidence", "metadata", "agentTitle", "w", "fullMetadata", "generateTaskUpdateInstruction", "taskId", "status", "blockedBy", "blocks", "instruction", "formatTaskCreateForClaude", "generateTaskDeleteInstruction", "_reason", "formatTaskDeleteForClaude", "reason", "formatTaskUpdateForClaude", "md", "registerTask", "pipelineId", "pipelineStep", "t", "updateTaskStatus", "task", "getTaskByAgent", "getTaskById", "getTasksBlockedBy", "failedTaskId", "getOrphanedTasks", "failedIds", "id", "getPipelineTasks", "a", "b", "registerPipeline", "pipeline", "p", "updatePipeline", "updates", "getActivePipeline", "completePipelineStep", "step", "tasks", "taskStep", "cleanupOldTasks", "maxAgeMs", "cutoff", "DEFAULT_MAX_RETRIES", "DEFAULT_BASE_DELAY_MS", "MAX_DELAY_MS", "ALTERNATIVE_AGENTS", "NON_RETRYABLE_ERRORS", "ALTERNATIVE_SUGGESTING_ERRORS", "calculateBackoffDelay", "attemptNumber", "baseDelayMs", "exponentialDelay", "jitter", "isRetryableError", "error", "pattern", "suggestsAlternative", "getAlternativeAgent", "agent", "triedAgents", "alternatives", "alt", "makeRetryDecision", "maxRetries", "logHook", "alternative", "delayMs", "createAttempt", "taskId", "completeAttempt", "attempt", "outcome", "completedAt", "durationMs", "analyzeAttemptHistory", "attempts", "successRate", "durations", "avgDuration", "b", "errorCounts", "normalized", "commonErrors", "prepareForRetry", "decision", "formatRetryDecision", "message", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MIN_SAMPLES_FOR_ADJUSTMENT", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "DECAY_FACTOR", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "keyword", "existing", "applyDecay", "now", "dayMs", "adj", "age", "a", "records", "successful", "r", "avgConf", "sum", "agentStats", "stat", "b", "getAdjustments", "getAgentSuccessRate", "agentRecords", "getCalibrationStats", "hasMinimalCalibrationData", "PIPELINES", "detectPipeline", "prompt", "promptLower", "pipeline", "trigger", "logHook", "getPipelineByType", "type", "p", "createPipelineExecution", "pipelineId", "tasks", "taskIds", "i", "step", "taskId", "metadata", "blockedBy", "dep", "registerPipelineExecution", "execution", "registerPipeline", "task", "registerTask", "formatPipelinePlan", "md", "deps", "d", "IMPLEMENTATION_KEYWORDS", "detectCategory", "prompt", "promptLower", "getMem0UserId", "scope", "projectDir", "getGlobalUserId", "antipatternDetector", "input", "getProjectDir", "outputSilentSuccess", "matchedKeyword", "keyword", "logHook", "category", "projectUserId", "globalUserId", "existsSync", "readFileSync", "join", "IMPLEMENTATION_KEYWORDS", "KNOWN_ANTIPATTERNS", "isImplementationPrompt", "prompt", "promptLower", "keyword", "detectCategory", "searchLocalAntipatterns", "projectDir", "warnings", "pattern", "warning", "patternsFile", "failedPatterns", "p", "firstWord", "globalPatternsFile", "data", "getMem0UserId", "scope", "buildMem0SearchHint", "category", "userId", "antipatternWarning", "input", "getProjectDir", "outputSilentSuccess", "logHook", "mem0SearchHints", "warningMessage", "w", "outputPromptContext", "existsSync", "join", "contextInjector", "input", "prompt", "projectDir", "getProjectDir", "logHook", "contextHints", "issueDocsDir", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "CONTEXT_TRIGGER", "CONTEXT_CRITICAL", "PRUNE_THRESHOLD_HIGH", "PRUNE_THRESHOLD_MED", "MAX_RECOMMENDATIONS", "calculateRecencyScore", "lastAccessed", "currentTime", "lastEpoch", "ageMinutes", "calculateFrequencyScore", "count", "calculateRelevanceScore", "itemKeywords", "promptKeywords", "itemSet", "k", "promptSet", "overlap", "keyword", "overlapRatio", "extractPromptKeywords", "prompt", "stopwords", "word", "getStateFilePath", "getSessionId", "loadOrInitState", "stateFile", "state", "getContextUsagePercentage", "envPercent", "parsed", "analyzeAndRecommend", "candidates", "item", "accessCount", "keywords", "recencyScore", "frequencyScore", "relevanceScore", "totalScore", "logHook", "a", "b", "buildRecommendationMessage", "totalSavings", "lines", "priority", "itemId", "score", "tokens", "displayName", "contextPruningAdvisor", "input", "projectDir", "getProjectDir", "logDir", "contextUsage", "outputSilentSuccess", "criticalMsg", "outputPromptContext", "message", "existsSync", "readFileSync", "join", "MEMORY_TRIGGER_KEYWORDS", "GRAPH_TRIGGER_KEYWORDS", "MIN_PROMPT_LENGTH", "shouldSearchMemory", "prompt", "promptLower", "keyword", "hasGraphTrigger", "extractSearchTerms", "stopwords", "word", "getMem0UserId", "scope", "projectDir", "getAgentContext", "agentId", "trackingFile", "memoryContext", "input", "getProjectDir", "isMem0Available", "logHook", "outputSilentSuccess", "useGlobal", "useGraph", "agentContext", "searchTerms", "scopeDesc", "userIdDecisions", "systemMsg", "existsSync", "readFileSync", "writeFileSync", "appendFileSync", "mkdirSync", "join", "dirname", "MIN_PROMPT_LENGTH", "POSITIVE_PATTERNS", "NEGATIVE_PATTERNS", "detectSatisfaction", "prompt", "pattern", "getCounterFilePath", "projectDir", "getAndIncrementCounter", "counterFile", "dir", "counter", "logSatisfaction", "sessionId", "sentiment", "context", "feedbackDir", "logFile", "logEntry", "satisfactionDetector", "input", "getProjectDir", "getSessionId", "sampleRate", "outputSilentSuccess", "logHook", "existsSync", "readFileSync", "join", "MAX_SUGGESTIONS", "MIN_CONFIDENCE", "KEYWORD_MAPPINGS", "findMatchingSkills", "prompt", "promptLower", "skillScores", "keyword", "skill", "confidence", "currentScore", "a", "b", "getSkillDescription", "skillName", "skillsDir", "skillFile", "frontmatterMatch", "descriptionMatch", "buildSuggestionMessage", "matches", "message", "description", "skillAutoSuggest", "input", "pluginRoot", "getPluginRoot", "outputSilentSuccess", "logHook", "m", "suggestionMessage", "outputPromptContext", "COMPLEX_PATTERNS", "LONG_PROMPT_THRESHOLD", "todoEnforcer", "input", "prompt", "promptLength", "logHook", "isComplex", "pattern", "outputSilentSuccess", "MAX_SUGGESTIONS", "buildSuggestionMessage", "matches", "topMatch", "message", "THRESHOLDS", "second", "agentAutoSuggest", "input", "prompt", "shouldClassify", "outputSilentSuccess", "loadConfig", "logHook", "history", "getPromptHistory", "adjustments", "getAdjustments", "classifyIntent", "m", "suggestionMessage", "outputPromptContext", "buildAutoDispatchMessage", "match", "taskMeta", "THRESHOLDS", "buildStrongRecommendMessage", "buildSuggestionMessage", "buildAlternativeNote", "buildOrchestrationMessage", "result", "config", "topMatch", "message", "isAgentDispatched", "logHook", "trackDispatchedAgent", "agentOrchestrator", "input", "prompt", "shouldClassify", "outputSilentSuccess", "loadConfig", "history", "getPromptHistory", "classifyIntent", "cacheClassification", "addToPromptHistory", "a", "outputPromptContext", "existsSync", "readFileSync", "join", "MAX_INJECTION_TOKENS", "CHARS_PER_TOKEN", "MAX_SKILLS_PER_PROMPT", "loadSkillContent", "skillName", "maxTokens", "pluginRoot", "getPluginRoot", "skillFile", "join", "existsSync", "logHook", "content", "readFileSync", "frontmatterMatch", "maxChars", "truncated", "lastParagraph", "err", "estimateTokens", "buildInjectionMessage", "skills", "message", "skill", "skillInjector", "input", "prompt", "shouldClassify", "outputSilentSuccess", "config", "loadConfig", "result", "getLastClassification", "classifyIntent", "eligibleSkills", "s", "THRESHOLDS", "isSkillInjected", "maxTotalTokens", "skillCount", "tokensPerSkill", "loadedSkills", "totalTokens", "match", "remainingTokens", "tokens", "trackInjectedSkill", "outputPromptContext", "MIN_PROMPT_LENGTH", "EXCLUSION_WORDS", "isQuestionNotRequest", "prompt", "promptLower", "exclusion", "isInActivePipeline", "active", "getActivePipeline", "pipelineDetector", "input", "outputSilentSuccess", "loadConfig", "logHook", "pipeline", "detectPipeline", "execution", "tasks", "createPipelineExecution", "registerPipelineExecution", "message", "formatPipelinePlan", "outputPromptContext", "hooks", "antipatternDetector", "antipatternWarning", "contextInjector", "contextPruningAdvisor", "memoryContext", "satisfactionDetector", "skillAutoSuggest", "todoEnforcer", "agentAutoSuggest", "agentOrchestrator", "skillInjector", "pipelineDetector", "getHook", "name", "listHooks"]
}
