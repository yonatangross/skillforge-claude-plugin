{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/orchestration-types.ts", "../src/lib/intent-classifier.ts", "../src/lib/orchestration-state.ts", "../src/lib/task-integration.ts", "../src/lib/retry-manager.ts", "../src/lib/calibration-engine.ts", "../src/lib/multi-agent-coordinator.ts", "../src/prompt/antipattern-detector.ts", "../src/prompt/antipattern-warning.ts", "../src/prompt/context-injector.ts", "../src/prompt/context-pruning-advisor.ts", "../src/prompt/memory-context.ts", "../src/lib/session-tracker.ts", "../src/lib/user-identity.ts", "../src/prompt/satisfaction-detector.ts", "../src/prompt/todo-enforcer.ts", "../src/prompt/agent-auto-suggest.ts", "../src/prompt/agent-orchestrator.ts", "../src/prompt/pipeline-detector.ts", "../src/prompt/skill-resolver.ts", "../src/prompt/skill-auto-suggest.ts", "../src/lib/user-intent-detector.ts", "../src/prompt/capture-user-intent.ts", "../src/lib/user-profile.ts", "../src/prompt/profile-injector.ts", "../src/prompt/communication-style-tracker.ts", "../src/entries/prompt.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME || process.env.USERPROFILE || '/tmp'}/.claude/logs/ork`;\n  }\n  return `${getProjectDir()}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n * Read dynamically to support testing\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory\n * Read dynamically to support testing\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability, but we add\n * a defensive fallback to prevent hook crashes during edge cases.\n * Read dynamically to support testing.\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}-${Date.now()}`;\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker && budgetChecker.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Orchestration Types - Shared type definitions for Agent Orchestration Layer\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * These types support:\n * - Intent classification with hybrid scoring\n * - Agent and skill matching\n * - CC 2.1.16 Task system integration\n * - Outcome-based calibration\n * - Multi-agent coordination\n */\n\n// -----------------------------------------------------------------------------\n// Confidence Thresholds\n// -----------------------------------------------------------------------------\n\nexport const THRESHOLDS = {\n  /** Auto-dispatch agent without confirmation */\n  AUTO_DISPATCH: 85,\n  /** Auto-inject skill content */\n  SKILL_INJECT: 80,\n  /** Strong recommendation shown to user */\n  STRONG_RECOMMEND: 70,\n  /** Suggestion shown to user */\n  SUGGEST: 50,\n  /** Minimum confidence to consider */\n  MINIMUM: 40,\n} as const;\n\n// -----------------------------------------------------------------------------\n// Intent Classification Types\n// -----------------------------------------------------------------------------\n\n/** Signal types used in intent classification */\nexport type SignalType =\n  | 'keyword'         // Direct keyword match\n  | 'phrase'          // Multi-word phrase match\n  | 'context'         // Context continuity from history\n  | 'cooccurrence'    // Learned keyword co-occurrence\n  | 'negation'        // Detected negation reducing confidence\n  | 'boost'           // Calibration boost from successful outcomes\n  | 'penalty';        // Calibration penalty from failures\n\n/** Individual signal contributing to classification */\nexport interface IntentSignal {\n  type: SignalType;\n  source: string;       // What triggered this signal\n  weight: number;       // Weight contribution (0-100)\n  matched: string;      // What was matched in the prompt\n}\n\n/** Match result for an agent */\nexport interface AgentMatch {\n  agent: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Match result for a skill */\nexport interface SkillMatch {\n  skill: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Result from intent classification */\nexport interface ClassificationResult {\n  /** Matching agents sorted by confidence */\n  agents: AgentMatch[];\n  /** Matching skills sorted by confidence */\n  skills: SkillMatch[];\n  /** Primary detected intent category */\n  intent: string;\n  /** Highest confidence score across all matches */\n  confidence: number;\n  /** All signals used in classification */\n  signals: IntentSignal[];\n  /** Whether this should trigger auto-dispatch */\n  shouldAutoDispatch: boolean;\n  /** Whether skills should be auto-injected */\n  shouldInjectSkills: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Orchestration State Types\n// -----------------------------------------------------------------------------\n\n/** Action to take based on classification */\nexport type OrchestrationAction =\n  | 'auto-dispatch'    // Immediately spawn agent\n  | 'inject-skill'     // Auto-load skill content\n  | 'strong-recommend' // Show strong recommendation\n  | 'suggest'          // Show suggestion\n  | 'none';            // No action needed\n\n/** State for a dispatched agent */\nexport interface DispatchedAgent {\n  agent: string;\n  taskId?: string;     // CC 2.1.16 task ID if created\n  confidence: number;\n  dispatchedAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'retrying';\n  retryCount: number;\n  maxRetries: number;\n}\n\n/** Current orchestration session state */\nexport interface OrchestrationState {\n  sessionId: string;\n  /** Active dispatched agents */\n  activeAgents: DispatchedAgent[];\n  /** Skills currently injected */\n  injectedSkills: string[];\n  /** Recent prompts for context continuity */\n  promptHistory: string[];\n  /** Max prompts to keep in history */\n  maxHistorySize: number;\n  /** Last classification result */\n  lastClassification?: ClassificationResult;\n  /** Timestamp of last update */\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// CC 2.1.16 Task Integration Types\n// -----------------------------------------------------------------------------\n\n/** Metadata attached to tasks for orchestration */\nexport interface TaskMetadata {\n  /** Source of task creation */\n  source: 'orchestration' | 'user' | 'pipeline';\n  /** Agent that was dispatched */\n  dispatchedAgent?: string;\n  /** Classification confidence at dispatch time */\n  dispatchConfidence?: number;\n  /** Pipeline this task belongs to */\n  pipelineId?: string;\n  /** Step in pipeline sequence */\n  pipelineStep?: number;\n  /** Related skill names */\n  relatedSkills?: string[];\n  /** Signals that triggered dispatch */\n  dispatchSignals?: IntentSignal[];\n}\n\n/** Instruction to create a CC 2.1.16 task */\nexport interface TaskCreateInstruction {\n  subject: string;\n  description: string;\n  activeForm: string;\n  metadata: TaskMetadata;\n  /** Tasks this one is blocked by */\n  blockedBy?: string[];\n}\n\n/** Instruction to update a CC 2.1.16 task */\nexport interface TaskUpdateInstruction {\n  taskId: string;\n  status?: 'pending' | 'in_progress' | 'completed' | 'deleted';\n  addBlockedBy?: string[];\n  addBlocks?: string[];\n}\n\n// -----------------------------------------------------------------------------\n// Retry and Error Handling Types\n// -----------------------------------------------------------------------------\n\n/** Outcome of an agent execution */\nexport type AgentOutcome = 'success' | 'partial' | 'failure' | 'rejected';\n\n/** Decision on what to do after failure */\nexport interface RetryDecision {\n  shouldRetry: boolean;\n  retryCount: number;\n  maxRetries: number;\n  /** Alternative agent to suggest if giving up */\n  alternativeAgent?: string;\n  /** Reason for decision */\n  reason: string;\n  /** Delay before retry in ms */\n  delayMs?: number;\n}\n\n/** Record of an agent execution attempt */\nexport interface ExecutionAttempt {\n  agent: string;\n  taskId?: string;\n  attemptNumber: number;\n  startedAt: string;\n  completedAt?: string;\n  outcome?: AgentOutcome;\n  error?: string;\n  durationMs?: number;\n}\n\n// -----------------------------------------------------------------------------\n// Calibration Types\n// -----------------------------------------------------------------------------\n\n/** Record of a dispatched agent outcome for calibration */\nexport interface CalibrationRecord {\n  timestamp: string;\n  sessionId: string;\n  agent: string;\n  promptHash: string;        // Hash of triggering prompt\n  matchedKeywords: string[];\n  dispatchConfidence: number;\n  outcome: AgentOutcome;\n  durationMs?: number;\n  /** User feedback if any */\n  feedback?: 'positive' | 'negative' | 'neutral';\n}\n\n/** Learned adjustment for keyword/agent pairs */\nexport interface CalibrationAdjustment {\n  keyword: string;\n  agent: string;\n  /** Positive = boost, negative = penalty */\n  adjustment: number;\n  sampleCount: number;\n  lastUpdated: string;\n}\n\n/** Calibration data store */\nexport interface CalibrationData {\n  schemaVersion: string;\n  createdAt: string;\n  updatedAt: string;\n  records: CalibrationRecord[];\n  adjustments: CalibrationAdjustment[];\n  /** Summary stats for monitoring */\n  stats: {\n    totalDispatches: number;\n    successRate: number;\n    avgConfidence: number;\n    topAgents: Array<{ agent: string; count: number; successRate: number }>;\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Multi-Agent Pipeline Types\n// -----------------------------------------------------------------------------\n\n/** Known pipeline definitions */\nexport type PipelineType =\n  | 'product-thinking'\n  | 'full-stack-feature'\n  | 'ai-integration'\n  | 'security-audit'\n  | 'frontend-compliance'\n  | 'custom';\n\n/** Step in a multi-agent pipeline */\nexport interface PipelineStep {\n  agent: string;\n  description: string;\n  /** Task dependencies (step indices) */\n  dependsOn: number[];\n  /** Skills to inject for this step */\n  skills?: string[];\n  /** Estimated context tokens for this step */\n  estimatedTokens?: number;\n}\n\n/** Definition of a multi-agent pipeline */\nexport interface PipelineDefinition {\n  type: PipelineType;\n  name: string;\n  description: string;\n  /** Trigger patterns that activate this pipeline */\n  triggers: string[];\n  steps: PipelineStep[];\n  /** Total estimated tokens for full pipeline */\n  estimatedTotalTokens: number;\n}\n\n/** Active pipeline execution state */\nexport interface PipelineExecution {\n  pipelineId: string;\n  type: PipelineType;\n  startedAt: string;\n  /** Map of step index to task ID */\n  taskIds: Record<number, string>;\n  /** Current step being executed */\n  currentStep: number;\n  /** Completed steps */\n  completedSteps: number[];\n  status: 'running' | 'completed' | 'failed' | 'paused';\n}\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/** Orchestration configuration */\nexport interface OrchestrationConfig {\n  /** Enable auto-dispatch at high confidence */\n  enableAutoDispatch: boolean;\n  /** Enable skill auto-injection */\n  enableSkillInjection: boolean;\n  /** Maximum tokens for skill injection */\n  maxSkillInjectionTokens: number;\n  /** Enable outcome calibration */\n  enableCalibration: boolean;\n  /** Enable pipeline detection */\n  enablePipelines: boolean;\n  /** Custom confidence thresholds */\n  thresholds?: Partial<typeof THRESHOLDS>;\n  /** Max retries for failed agents */\n  maxRetries: number;\n  /** Retry delay base in ms */\n  retryDelayBaseMs: number;\n}\n\n/** Default orchestration configuration */\nexport const DEFAULT_CONFIG: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n", "/**\n * Intent Classifier - Hybrid semantic+keyword scoring engine\n * Issue #197: Agent Orchestration Layer\n *\n * Scoring weights:\n * - Keyword matching: 30%\n * - Phrase pattern matching: 25%\n * - Context continuity: 20%\n * - Co-occurrence learning: 15%\n * - Negation detection: 10%\n *\n * Target: 85%+ accuracy vs ~60% regex baseline\n */\n\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getPluginRoot, logHook } from './common.js';\nimport {\n  THRESHOLDS,\n  type AgentMatch,\n  type SkillMatch,\n  type IntentSignal,\n  type ClassificationResult,\n  type CalibrationAdjustment,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants and Weights\n// -----------------------------------------------------------------------------\n\n/** Scoring weights for signal types (must sum to 100) */\nconst SIGNAL_WEIGHTS = {\n  keyword: 30,\n  phrase: 25,\n  context: 20,\n  cooccurrence: 15,\n  negation: 10,\n} as const;\n\n/** Negation patterns that reduce confidence */\nconst NEGATION_PATTERNS = [\n  /\\b(not|don't|doesn't|won't|can't|shouldn't|avoid|without|except|unlike|instead of)\\s+/i,\n  /\\b(no|never|neither|nor)\\s+/i,\n];\n\n/** Context keywords that boost confidence when in history */\nconst CONTEXT_BOOST_KEYWORDS = [\n  'continue',\n  'also',\n  'additionally',\n  'and',\n  'then',\n  'next',\n  'follow up',\n  'after that',\n];\n\n// -----------------------------------------------------------------------------\n// Agent Index Cache\n// -----------------------------------------------------------------------------\n\ninterface AgentIndexEntry {\n  keywords: string[];\n  phrases: string[];\n  description: string;\n  skills?: string[];\n}\n\nlet agentIndex: Map<string, AgentIndexEntry> | null = null;\nlet agentIndexPath: string | null = null;\n\n/**\n * Build or get cached agent index from agents/ directory\n */\nfunction getAgentIndex(agentsDir: string): Map<string, AgentIndexEntry> {\n  // Return cache if path matches\n  if (agentIndex && agentIndexPath === agentsDir) {\n    return agentIndex;\n  }\n\n  const index = new Map<string, AgentIndexEntry>();\n\n  try {\n    const files = readdirSync(agentsDir).filter(f => f.endsWith('.md'));\n\n    for (const file of files) {\n      const agentName = file.replace('.md', '');\n      const filePath = join(agentsDir, file);\n\n      try {\n        const content = readFileSync(filePath, 'utf8');\n\n        // Extract frontmatter\n        const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n        if (!frontmatterMatch) continue;\n\n        const frontmatter = frontmatterMatch[1];\n\n        // Extract description\n        const descMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n        if (!descMatch) continue;\n\n        const description = descMatch[1].trim();\n\n        // Extract \"Activates for\" keywords\n        const activatesMatch = description.match(/Activates for\\s+(.+?)\\.?$/i);\n\n        // Also check for keywords in description before \"Activates for\"\n        const descPart = activatesMatch\n          ? description.slice(0, description.indexOf('Activates for')).trim()\n          : description;\n\n        let keywords: string[] = [];\n        let phrases: string[] = [];\n\n        if (activatesMatch) {\n          const keywordsStr = activatesMatch[1];\n          const rawKeywords = keywordsStr.split(/,\\s*/).map(k => k.trim().toLowerCase());\n\n          // Separate phrases (multi-word) from single keywords\n          for (const kw of rawKeywords) {\n            if (kw.includes(' ') || kw.includes('-')) {\n              phrases.push(kw);\n            } else if (kw.length > 1) {\n              keywords.push(kw);\n            }\n          }\n        }\n\n        // Extract skills from frontmatter\n        const skillsMatch = frontmatter.match(/^skills:\\s*\\n((?:\\s+-\\s+.+\\n?)+)/m);\n        let skills: string[] | undefined;\n        if (skillsMatch) {\n          skills = skillsMatch[1]\n            .split('\\n')\n            .map(l => l.replace(/^\\s*-\\s*/, '').trim())\n            .filter(Boolean);\n        }\n\n        if (keywords.length > 0 || phrases.length > 0) {\n          index.set(agentName, {\n            keywords,\n            phrases,\n            description: descPart || description.split('.')[0],\n            skills,\n          });\n        }\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  } catch {\n    logHook('intent-classifier', 'Could not read agents directory');\n  }\n\n  agentIndex = index;\n  agentIndexPath = agentsDir;\n  return index;\n}\n\n// -----------------------------------------------------------------------------\n// Skill Index Cache\n// -----------------------------------------------------------------------------\n\ninterface SkillIndexEntry {\n  keywords: string[];\n  description: string;\n}\n\nlet skillIndex: Map<string, SkillIndexEntry> | null = null;\nlet skillIndexPath: string | null = null;\n\n/**\n * Build or get cached skill index from skills/ directory\n */\nfunction getSkillIndex(skillsDir: string): Map<string, SkillIndexEntry> {\n  if (skillIndex && skillIndexPath === skillsDir) {\n    return skillIndex;\n  }\n\n  const index = new Map<string, SkillIndexEntry>();\n\n  try {\n    const dirs = readdirSync(skillsDir, { withFileTypes: true })\n      .filter(d => d.isDirectory())\n      .map(d => d.name);\n\n    for (const skillName of dirs) {\n      const skillFile = join(skillsDir, skillName, 'SKILL.md');\n\n      if (!existsSync(skillFile)) continue;\n\n      try {\n        const content = readFileSync(skillFile, 'utf8');\n\n        // Extract frontmatter\n        const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n        if (!frontmatterMatch) continue;\n\n        const frontmatter = frontmatterMatch[1];\n\n        // Extract description\n        const descMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n        const description = descMatch ? descMatch[1].trim() : '';\n\n        // Extract tags as keywords\n        const tagsMatch = frontmatter.match(/^tags:\\s*\\[([^\\]]+)\\]/m);\n        let keywords: string[] = [];\n\n        if (tagsMatch) {\n          keywords = tagsMatch[1]\n            .split(',')\n            .map(t => t.trim().toLowerCase().replace(/[\"']/g, ''))\n            .filter(t => t.length > 1);\n        }\n\n        // Also extract keywords from description\n        const descKeywords = description\n          .toLowerCase()\n          .split(/\\s+/)\n          .filter(w => w.length > 4)\n          .slice(0, 5);\n\n        keywords = [...new Set([...keywords, ...descKeywords])];\n\n        if (keywords.length > 0 || description) {\n          index.set(skillName, { keywords, description });\n        }\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  } catch {\n    logHook('intent-classifier', 'Could not read skills directory');\n  }\n\n  skillIndex = index;\n  skillIndexPath = skillsDir;\n  return index;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate keyword match score for an agent\n */\nfunction calculateKeywordScore(\n  promptLower: string,\n  keywords: string[]\n): { score: number; matched: string[]; signals: IntentSignal[] } {\n  let score = 0;\n  const matched: string[] = [];\n  const signals: IntentSignal[] = [];\n\n  for (const keyword of keywords) {\n    // Check word boundary match\n    const regex = new RegExp(`\\\\b${keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n    if (regex.test(promptLower)) {\n      const weight = keyword.length > 5 ? 25 : 20; // Longer keywords are more specific\n      score += weight;\n      matched.push(keyword);\n      signals.push({\n        type: 'keyword',\n        source: 'keyword-match',\n        weight,\n        matched: keyword,\n      });\n    }\n  }\n\n  // Normalize to percentage of max possible\n  const maxScore = keywords.length * 25;\n  return {\n    score: maxScore > 0 ? Math.min((score / maxScore) * 100, 100) : 0,\n    matched,\n    signals,\n  };\n}\n\n/**\n * Calculate phrase match score (multi-word patterns)\n */\nfunction calculatePhraseScore(\n  promptLower: string,\n  phrases: string[]\n): { score: number; matched: string[]; signals: IntentSignal[] } {\n  let score = 0;\n  const matched: string[] = [];\n  const signals: IntentSignal[] = [];\n\n  for (const phrase of phrases) {\n    if (promptLower.includes(phrase)) {\n      const weight = phrase.split(/\\s+/).length * 15; // More words = higher weight\n      score += weight;\n      matched.push(phrase);\n      signals.push({\n        type: 'phrase',\n        source: 'phrase-match',\n        weight,\n        matched: phrase,\n      });\n    }\n  }\n\n  // Normalize to percentage of max possible\n  const maxScore = phrases.length * 45; // Assume avg 3 words per phrase\n  return {\n    score: maxScore > 0 ? Math.min((score / maxScore) * 100, 100) : 0,\n    matched,\n    signals,\n  };\n}\n\n/**\n * Calculate context continuity score from prompt history\n */\nfunction calculateContextScore(\n  promptLower: string,\n  keywords: string[],\n  history: string[]\n): { score: number; signals: IntentSignal[] } {\n  if (history.length === 0) {\n    return { score: 0, signals: [] };\n  }\n\n  const signals: IntentSignal[] = [];\n  let score = 0;\n\n  // Check for continuation keywords\n  for (const continuationWord of CONTEXT_BOOST_KEYWORDS) {\n    if (promptLower.includes(continuationWord)) {\n      score += 15;\n      signals.push({\n        type: 'context',\n        source: 'continuation-keyword',\n        weight: 15,\n        matched: continuationWord,\n      });\n      break; // Only count once\n    }\n  }\n\n  // Check if agent keywords appeared in recent history\n  const recentHistory = history.slice(-3).join(' ').toLowerCase();\n  for (const keyword of keywords.slice(0, 5)) {\n    if (recentHistory.includes(keyword)) {\n      score += 20;\n      signals.push({\n        type: 'context',\n        source: 'history-keyword',\n        weight: 20,\n        matched: keyword,\n      });\n    }\n  }\n\n  return { score: Math.min(score, 100), signals };\n}\n\n/**\n * Calculate negation penalty\n */\nfunction calculateNegationPenalty(prompt: string): { penalty: number; signals: IntentSignal[] } {\n  const signals: IntentSignal[] = [];\n  let penalty = 0;\n\n  for (const pattern of NEGATION_PATTERNS) {\n    if (pattern.test(prompt)) {\n      penalty = 25; // Significant penalty for negation\n      signals.push({\n        type: 'negation',\n        source: 'negation-detected',\n        weight: -25,\n        matched: prompt.match(pattern)?.[0] || 'negation',\n      });\n      break;\n    }\n  }\n\n  return { penalty, signals };\n}\n\n/**\n * Apply calibration adjustments to score\n */\nfunction applyCalibration(\n  agentName: string,\n  matchedKeywords: string[],\n  adjustments: CalibrationAdjustment[]\n): { adjustment: number; signals: IntentSignal[] } {\n  if (adjustments.length === 0) {\n    return { adjustment: 0, signals: [] };\n  }\n\n  let totalAdjustment = 0;\n  const signals: IntentSignal[] = [];\n\n  for (const adj of adjustments) {\n    if (adj.agent === agentName && matchedKeywords.includes(adj.keyword)) {\n      totalAdjustment += adj.adjustment;\n      signals.push({\n        type: adj.adjustment > 0 ? 'boost' : 'penalty',\n        source: 'calibration',\n        weight: adj.adjustment,\n        matched: `${adj.keyword}:${agentName}`,\n      });\n    }\n  }\n\n  return { adjustment: totalAdjustment, signals };\n}\n\n/**\n * Classify a single agent match\n */\nfunction classifyAgentMatch(\n  promptLower: string,\n  agentName: string,\n  entry: AgentIndexEntry,\n  history: string[],\n  adjustments: CalibrationAdjustment[]\n): AgentMatch | null {\n  const allSignals: IntentSignal[] = [];\n  const allMatched: string[] = [];\n\n  // 1. Keyword matching (30% weight)\n  const keywordResult = calculateKeywordScore(promptLower, entry.keywords);\n  allSignals.push(...keywordResult.signals);\n  allMatched.push(...keywordResult.matched);\n\n  // 2. Phrase matching (25% weight)\n  const phraseResult = calculatePhraseScore(promptLower, entry.phrases);\n  allSignals.push(...phraseResult.signals);\n  allMatched.push(...phraseResult.matched);\n\n  // 3. Context continuity (20% weight)\n  const contextResult = calculateContextScore(promptLower, entry.keywords, history);\n  allSignals.push(...contextResult.signals);\n\n  // 4. Negation detection (10% weight as penalty)\n  const negationResult = calculateNegationPenalty(promptLower);\n  allSignals.push(...negationResult.signals);\n\n  // 5. Calibration adjustments (applies to final score)\n  const calibrationResult = applyCalibration(agentName, allMatched, adjustments);\n  allSignals.push(...calibrationResult.signals);\n\n  // Calculate weighted score\n  let score =\n    keywordResult.score * (SIGNAL_WEIGHTS.keyword / 100) +\n    phraseResult.score * (SIGNAL_WEIGHTS.phrase / 100) +\n    contextResult.score * (SIGNAL_WEIGHTS.context / 100);\n\n  // Apply negation penalty\n  score -= negationResult.penalty * (SIGNAL_WEIGHTS.negation / 100);\n\n  // Apply calibration adjustment (up to +/-15 points)\n  score += Math.max(-15, Math.min(15, calibrationResult.adjustment));\n\n  // Ensure score is within bounds\n  score = Math.max(0, Math.min(100, score));\n\n  // Only return if above minimum threshold\n  if (score < THRESHOLDS.MINIMUM) {\n    return null;\n  }\n\n  return {\n    agent: agentName,\n    confidence: Math.round(score),\n    description: entry.description,\n    matchedKeywords: allMatched,\n    signals: allSignals,\n  };\n}\n\n/**\n * Classify skill match\n */\nfunction classifySkillMatch(\n  promptLower: string,\n  skillName: string,\n  entry: SkillIndexEntry\n): SkillMatch | null {\n  const signals: IntentSignal[] = [];\n  const matched: string[] = [];\n  let score = 0;\n\n  for (const keyword of entry.keywords) {\n    const regex = new RegExp(`\\\\b${keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`, 'i');\n    if (regex.test(promptLower)) {\n      const weight = keyword.length > 5 ? 25 : 20;\n      score += weight;\n      matched.push(keyword);\n      signals.push({\n        type: 'keyword',\n        source: 'skill-keyword',\n        weight,\n        matched: keyword,\n      });\n    }\n  }\n\n  // Cap at 100\n  score = Math.min(score, 100);\n\n  if (score < THRESHOLDS.MINIMUM) {\n    return null;\n  }\n\n  return {\n    skill: skillName,\n    confidence: Math.round(score),\n    description: entry.description,\n    matchedKeywords: matched,\n    signals,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Main Classification Function\n// -----------------------------------------------------------------------------\n\n/**\n * Classify user prompt intent and find matching agents/skills\n *\n * @param prompt - The user's input prompt\n * @param history - Recent prompt history for context continuity\n * @param adjustments - Calibration adjustments from outcome learning\n * @returns Classification result with agents, skills, and confidence\n */\nexport function classifyIntent(\n  prompt: string,\n  history: string[] = [],\n  adjustments: CalibrationAdjustment[] = []\n): ClassificationResult {\n  const pluginRoot = getPluginRoot();\n  const agentsDir = join(pluginRoot, 'agents');\n  const skillsDir = join(pluginRoot, 'skills');\n\n  const promptLower = prompt.toLowerCase();\n\n  const allSignals: IntentSignal[] = [];\n  const agentMatches: AgentMatch[] = [];\n  const skillMatches: SkillMatch[] = [];\n\n  // Classify agents\n  const agentIdx = getAgentIndex(agentsDir);\n  for (const [agentName, entry] of agentIdx) {\n    const match = classifyAgentMatch(\n      promptLower,\n      agentName,\n      entry,\n      history,\n      adjustments\n    );\n    if (match) {\n      agentMatches.push(match);\n      allSignals.push(...match.signals);\n    }\n  }\n\n  // Classify skills\n  const skillIdx = getSkillIndex(skillsDir);\n  for (const [skillName, entry] of skillIdx) {\n    const match = classifySkillMatch(promptLower, skillName, entry);\n    if (match) {\n      skillMatches.push(match);\n      allSignals.push(...match.signals);\n    }\n  }\n\n  // Sort by confidence\n  agentMatches.sort((a, b) => b.confidence - a.confidence);\n  skillMatches.sort((a, b) => b.confidence - a.confidence);\n\n  // Determine primary intent from top agent\n  const topAgent = agentMatches[0];\n  const intent = topAgent\n    ? categorizeIntent(topAgent.agent, topAgent.matchedKeywords)\n    : 'general';\n\n  const maxConfidence = Math.max(\n    topAgent?.confidence || 0,\n    skillMatches[0]?.confidence || 0\n  );\n\n  const shouldAutoDispatch =\n    topAgent !== undefined && topAgent.confidence >= THRESHOLDS.AUTO_DISPATCH;\n\n  const shouldInjectSkills =\n    skillMatches.length > 0 &&\n    skillMatches[0].confidence >= THRESHOLDS.SKILL_INJECT;\n\n  return {\n    agents: agentMatches.slice(0, 3), // Top 3\n    skills: skillMatches.slice(0, 5), // Top 5\n    intent,\n    confidence: maxConfidence,\n    signals: allSignals,\n    shouldAutoDispatch,\n    shouldInjectSkills,\n  };\n}\n\n/**\n * Categorize intent based on agent and keywords\n */\nfunction categorizeIntent(agent: string, keywords: string[]): string {\n  const categories: Record<string, string[]> = {\n    'api-design': ['api', 'endpoint', 'rest', 'graphql', 'route'],\n    'database': ['database', 'schema', 'migration', 'sql', 'query'],\n    'authentication': ['auth', 'login', 'jwt', 'oauth', 'session'],\n    'frontend': ['react', 'component', 'ui', 'form', 'state'],\n    'testing': ['test', 'coverage', 'mock', 'fixture', 'e2e'],\n    'devops': ['deploy', 'ci', 'cd', 'release', 'monitor'],\n    'ai-integration': ['llm', 'rag', 'embedding', 'langgraph', 'agent'],\n    'security': ['security', 'owasp', 'xss', 'injection', 'csrf'],\n  };\n\n  for (const [category, categoryKeywords] of Object.entries(categories)) {\n    for (const kw of keywords) {\n      if (categoryKeywords.includes(kw)) {\n        return category;\n      }\n    }\n  }\n\n  // Fallback to agent-based categorization\n  if (agent.includes('backend') || agent.includes('api')) return 'api-design';\n  if (agent.includes('frontend') || agent.includes('ui')) return 'frontend';\n  if (agent.includes('test')) return 'testing';\n  if (agent.includes('security')) return 'security';\n\n  return 'general';\n}\n\n/**\n * Quick check if prompt likely needs orchestration\n * Use this for fast filtering before full classification\n */\nexport function shouldClassify(prompt: string): boolean {\n  if (prompt.length < 10) return false;\n\n  // Skip meta questions about agents/skills\n  if (/what agents|list agents|available agents|what skills/i.test(prompt)) {\n    return false;\n  }\n\n  // Skip simple commands\n  if (/^(yes|no|ok|thanks|done|continue|stop)$/i.test(prompt.trim())) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Clear cached indices (useful for testing or when agents/skills change)\n */\nexport function clearCache(): void {\n  agentIndex = null;\n  agentIndexPath = null;\n  skillIndex = null;\n  skillIndexPath = null;\n}\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n  blockedBy?: string[];\n  blocks?: string[];\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Get action-specific activeForm based on agent type\n */\nfunction getActiveFormForAgent(agent: string, description: string): string {\n  const actionMap: Record<string, string> = {\n    'backend-system-architect': 'Designing',\n    'frontend-ui-developer': 'Building',\n    'test-generator': 'Writing tests for',\n    'security-auditor': 'Auditing',\n    'workflow-architect': 'Architecting',\n    'database-engineer': 'Implementing database for',\n    'llm-integrator': 'Integrating LLM for',\n    'code-quality-reviewer': 'Reviewing',\n    'ux-researcher': 'Researching UX for',\n    'product-strategist': 'Strategizing',\n    'debug-investigator': 'Investigating',\n    'performance-engineer': 'Optimizing',\n    'accessibility-specialist': 'Auditing accessibility for',\n    'infrastructure-architect': 'Designing infrastructure for',\n    'data-pipeline-engineer': 'Building pipeline for',\n  };\n\n  const action = actionMap[agent] || 'Working on';\n  const shortDesc = description.slice(0, 40).toLowerCase();\n  return `${action} ${shortDesc}`;\n}\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: getActiveFormForAgent(agent, description),\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'deleted',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Generate TaskUpdate instruction for task deletion (CC 2.1.20)\n */\nexport function generateTaskDeleteInstruction(\n  taskId: string,\n  _reason: string\n): TaskUpdateInstruction {\n  return {\n    taskId,\n    status: 'deleted',\n  };\n}\n\n/**\n * Format TaskDelete instruction as markdown for Claude (CC 2.1.20)\n */\nexport function formatTaskDeleteForClaude(taskId: string, reason: string): string {\n  return `### Delete Orphaned Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${taskId}\"\n  status: \"deleted\"\n\\`\\`\\`\n\n**Reason**: ${reason}`;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number,\n  blockedBy?: string[],\n  blocks?: string[]\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n    blockedBy,\n    blocks,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get pending tasks blocked by a specific failed task (CC 2.1.20)\n */\nexport function getTasksBlockedBy(failedTaskId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks.filter(\n    t =>\n      t.status === 'pending' &&\n      t.blockedBy &&\n      t.blockedBy.includes(failedTaskId)\n  );\n}\n\n/**\n * Get orphaned tasks - pending tasks where all blockers have failed (CC 2.1.20)\n */\nexport function getOrphanedTasks(): TaskEntry[] {\n  const registry = loadRegistry();\n  const failedIds = new Set(\n    registry.tasks.filter(t => t.status === 'failed').map(t => t.taskId)\n  );\n\n  if (failedIds.size === 0) return [];\n\n  return registry.tasks.filter(t => {\n    if (t.status !== 'pending' || !t.blockedBy || t.blockedBy.length === 0) {\n      return false;\n    }\n    // Orphaned if ALL blockers are failed\n    return t.blockedBy.every(id => failedIds.has(id));\n  });\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Retry Manager - Intelligent retry decisions for failed agents\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Exponential backoff retry logic\n * - Alternative agent suggestions\n * - Failure pattern detection\n * - Max retry limits\n */\n\nimport { logHook } from './common.js';\nimport type {\n  RetryDecision,\n  ExecutionAttempt,\n  AgentOutcome,\n  DispatchedAgent,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_BASE_DELAY_MS = 1000;\nconst MAX_DELAY_MS = 30000;\n\n/** Alternative agent mappings for common failure scenarios */\nconst ALTERNATIVE_AGENTS: Record<string, string[]> = {\n  // If backend architect fails, try these\n  'backend-system-architect': ['database-engineer', 'api-designer'],\n  // If frontend fails, try UI designer first\n  'frontend-ui-developer': ['rapid-ui-designer', 'accessibility-specialist'],\n  // If test generator fails, try debug investigator\n  'test-generator': ['debug-investigator', 'code-quality-reviewer'],\n  // If security auditor fails, try layer auditor\n  'security-auditor': ['security-layer-auditor'],\n  // If workflow architect fails, try LLM integrator\n  'workflow-architect': ['llm-integrator', 'data-pipeline-engineer'],\n};\n\n/** Error patterns that indicate retry is unlikely to help */\nconst NON_RETRYABLE_ERRORS = [\n  /permission denied/i,\n  /access denied/i,\n  /not found.*(?:file|module|package)/i,\n  /(?:file|module|package)\\s+not\\s+found/i,\n  /missing required/i,\n  /invalid (?:api|token|key)/i,\n  /authentication failed/i,\n  /quota exceeded/i,\n  /rate limit/i,\n];\n\n/** Error patterns that suggest trying an alternative agent */\nconst ALTERNATIVE_SUGGESTING_ERRORS = [\n  /not my specialization/i,\n  /outside my scope/i,\n  /better suited for/i,\n  /consider using/i,\n  /specialized agent/i,\n];\n\n// -----------------------------------------------------------------------------\n// Retry Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate exponential backoff delay\n */\nexport function calculateBackoffDelay(\n  attemptNumber: number,\n  baseDelayMs: number = DEFAULT_BASE_DELAY_MS\n): number {\n  // Exponential backoff with jitter\n  const exponentialDelay = baseDelayMs * Math.pow(2, attemptNumber - 1);\n  const jitter = Math.random() * 0.1 * exponentialDelay; // 10% jitter\n  return Math.min(exponentialDelay + jitter, MAX_DELAY_MS);\n}\n\n/**\n * Check if error is retryable\n */\nexport function isRetryableError(error: string): boolean {\n  for (const pattern of NON_RETRYABLE_ERRORS) {\n    if (pattern.test(error)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if error suggests alternative agent\n */\nexport function suggestsAlternative(error: string): boolean {\n  for (const pattern of ALTERNATIVE_SUGGESTING_ERRORS) {\n    if (pattern.test(error)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get alternative agent for a given agent\n */\nexport function getAlternativeAgent(agent: string, triedAgents: string[] = []): string | undefined {\n  const alternatives = ALTERNATIVE_AGENTS[agent];\n  if (!alternatives) return undefined;\n\n  // Return first alternative not yet tried\n  for (const alt of alternatives) {\n    if (!triedAgents.includes(alt)) {\n      return alt;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Make retry decision based on execution history and error\n */\nexport function makeRetryDecision(\n  agent: string,\n  attemptNumber: number,\n  error: string,\n  triedAgents: string[] = [],\n  maxRetries: number = DEFAULT_MAX_RETRIES\n): RetryDecision {\n  logHook('retry-manager', `Evaluating retry for ${agent}, attempt ${attemptNumber}`);\n\n  // Check if max retries exceeded\n  if (attemptNumber >= maxRetries) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Max retries (${maxRetries}) exceeded` +\n        (alternative ? `. Consider trying ${alternative} instead.` : ''),\n    };\n  }\n\n  // Check if error is retryable\n  if (!isRetryableError(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Non-retryable error detected: ${error.slice(0, 100)}`,\n    };\n  }\n\n  // Check if error suggests alternative agent\n  if (suggestsAlternative(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    if (alternative) {\n      return {\n        shouldRetry: false,\n        retryCount: attemptNumber,\n        maxRetries,\n        alternativeAgent: alternative,\n        reason: `Error suggests using alternative agent: ${alternative}`,\n      };\n    }\n  }\n\n  // Retry with backoff\n  const delayMs = calculateBackoffDelay(attemptNumber);\n  return {\n    shouldRetry: true,\n    retryCount: attemptNumber,\n    maxRetries,\n    delayMs,\n    reason: `Retrying (attempt ${attemptNumber + 1}/${maxRetries}) after ${Math.round(delayMs / 1000)}s`,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Execution Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Create execution attempt record\n */\nexport function createAttempt(\n  agent: string,\n  attemptNumber: number,\n  taskId?: string\n): ExecutionAttempt {\n  return {\n    agent,\n    taskId,\n    attemptNumber,\n    startedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Complete execution attempt with outcome\n */\nexport function completeAttempt(\n  attempt: ExecutionAttempt,\n  outcome: AgentOutcome,\n  error?: string\n): ExecutionAttempt {\n  const completedAt = new Date().toISOString();\n  const durationMs = new Date(completedAt).getTime() - new Date(attempt.startedAt).getTime();\n\n  return {\n    ...attempt,\n    completedAt,\n    outcome,\n    error,\n    durationMs,\n  };\n}\n\n/**\n * Analyze execution history for patterns\n */\nexport function analyzeAttemptHistory(attempts: ExecutionAttempt[]): {\n  successRate: number;\n  avgDuration: number;\n  commonErrors: string[];\n} {\n  if (attempts.length === 0) {\n    return { successRate: 0, avgDuration: 0, commonErrors: [] };\n  }\n\n  const successful = attempts.filter(a => a.outcome === 'success').length;\n  const successRate = successful / attempts.length;\n\n  const durations = attempts\n    .filter(a => a.durationMs !== undefined)\n    .map(a => a.durationMs!);\n  const avgDuration = durations.length > 0\n    ? durations.reduce((a, b) => a + b, 0) / durations.length\n    : 0;\n\n  // Count error patterns\n  const errorCounts = new Map<string, number>();\n  for (const attempt of attempts) {\n    if (attempt.error) {\n      // Normalize error to first 50 chars\n      const normalized = attempt.error.slice(0, 50).toLowerCase();\n      errorCounts.set(normalized, (errorCounts.get(normalized) || 0) + 1);\n    }\n  }\n\n  // Get most common errors\n  const commonErrors = Array.from(errorCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([error]) => error);\n\n  return { successRate, avgDuration, commonErrors };\n}\n\n// -----------------------------------------------------------------------------\n// Dispatched Agent Updates\n// -----------------------------------------------------------------------------\n\n/**\n * Update dispatched agent for retry\n */\nexport function prepareForRetry(\n  agent: DispatchedAgent,\n  decision: RetryDecision\n): DispatchedAgent {\n  return {\n    ...agent,\n    status: 'retrying',\n    retryCount: decision.retryCount,\n  };\n}\n\n/**\n * Format retry decision as user-facing message\n */\nexport function formatRetryDecision(decision: RetryDecision, agent: string): string {\n  if (decision.shouldRetry) {\n    return `## Retry Scheduled\n\nAgent \\`${agent}\\` will retry after ${Math.round((decision.delayMs || 0) / 1000)} seconds.\n\n**Attempt:** ${decision.retryCount + 1} of ${decision.maxRetries}\n**Reason:** ${decision.reason}`;\n  }\n\n  let message = `## Retry Not Recommended\n\nAgent \\`${agent}\\` has ${decision.retryCount >= decision.maxRetries ? 'exhausted retries' : 'encountered a non-retryable error'}.\n\n**Reason:** ${decision.reason}`;\n\n  if (decision.alternativeAgent) {\n    message += `\n\n### Alternative Suggestion\n\nConsider using \\`${decision.alternativeAgent}\\` instead:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${decision.alternativeAgent}\"\n\\`\\`\\``;\n  }\n\n  return message;\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Multi-Agent Coordinator - Pipeline detection and coordination logic\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Pipeline definitions for common workflows\n * - Pipeline detection from prompts\n * - Task chain generation with dependencies\n */\n\nimport { logHook } from './common.js';\nimport type {\n  PipelineType,\n  PipelineDefinition,\n  PipelineExecution,\n  TaskCreateInstruction,\n  TaskMetadata,\n} from './orchestration-types.js';\nimport { registerPipeline, registerTask } from './task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Pipeline Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Predefined pipeline configurations\n */\nexport const PIPELINES: PipelineDefinition[] = [\n  {\n    type: 'product-thinking',\n    name: 'Product Thinking Pipeline',\n    description: 'Full product discovery and specification workflow',\n    triggers: [\n      'should we build',\n      'product decision',\n      'feature validation',\n      'market research',\n      'user research',\n    ],\n    steps: [\n      {\n        agent: 'market-intelligence',\n        description: 'Analyze competitive landscape and market trends',\n        dependsOn: [],\n        skills: ['market-research'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'ux-researcher',\n        description: 'Create personas and map user journeys',\n        dependsOn: [0],\n        skills: ['user-research'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'product-strategist',\n        description: 'Validate value proposition and alignment',\n        dependsOn: [0, 1],\n        skills: ['product-strategy'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'prioritization-analyst',\n        description: 'Score and prioritize using frameworks',\n        dependsOn: [2],\n        skills: ['prioritization'],\n        estimatedTokens: 1500,\n      },\n      {\n        agent: 'business-case-builder',\n        description: 'Build ROI and cost-benefit analysis',\n        dependsOn: [2, 3],\n        skills: ['business-case'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'requirements-translator',\n        description: 'Transform to PRD and user stories',\n        dependsOn: [4],\n        skills: ['requirements'],\n        estimatedTokens: 2500,\n      },\n    ],\n    estimatedTotalTokens: 13500,\n  },\n  {\n    type: 'full-stack-feature',\n    name: 'Full-Stack Feature Pipeline',\n    description: 'End-to-end feature implementation workflow',\n    triggers: [\n      'full-stack feature',\n      'build a feature',\n      'implement end-to-end',\n      'create full feature',\n      'add complete feature',\n    ],\n    steps: [\n      {\n        agent: 'backend-system-architect',\n        description: 'Design API and database schema',\n        dependsOn: [],\n        skills: ['api-design-framework', 'database-schema-designer'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Build React components and UI',\n        dependsOn: [0],\n        skills: ['react-server-components-framework', 'form-state-patterns'],\n        estimatedTokens: 3500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create unit and integration tests',\n        dependsOn: [0, 1],\n        skills: ['integration-testing', 'msw-mocking'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-auditor',\n        description: 'Audit for vulnerabilities',\n        dependsOn: [0, 1],\n        skills: ['owasp-top-10', 'auth-patterns'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 10000,\n  },\n  {\n    type: 'ai-integration',\n    name: 'AI Integration Pipeline',\n    description: 'Add AI/LLM capabilities to application',\n    triggers: [\n      'add rag',\n      'add llm',\n      'ai integration',\n      'implement rag',\n      'add ai feature',\n      'langgraph workflow',\n    ],\n    steps: [\n      {\n        agent: 'workflow-architect',\n        description: 'Design LangGraph workflow and state',\n        dependsOn: [],\n        skills: ['langgraph-state', 'langgraph-routing'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'llm-integrator',\n        description: 'Connect LLM APIs with function calling',\n        dependsOn: [0],\n        skills: ['function-calling', 'llm-streaming'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'data-pipeline-engineer',\n        description: 'Build embeddings and data pipeline',\n        dependsOn: [0],\n        skills: ['embeddings', 'rag-retrieval'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create LLM testing infrastructure',\n        dependsOn: [1, 2],\n        skills: ['llm-testing', 'property-based-testing'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 8500,\n  },\n  {\n    type: 'security-audit',\n    name: 'Security Audit Pipeline',\n    description: 'Comprehensive security review workflow',\n    triggers: [\n      'security audit',\n      'security review',\n      'vulnerability scan',\n      'security assessment',\n    ],\n    steps: [\n      {\n        agent: 'security-auditor',\n        description: 'Scan for OWASP Top 10 vulnerabilities',\n        dependsOn: [],\n        skills: ['owasp-top-10', 'input-validation'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-layer-auditor',\n        description: 'Verify defense-in-depth layers',\n        dependsOn: [0],\n        skills: ['defense-in-depth'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'ai-safety-auditor',\n        description: 'Audit AI/LLM security if applicable',\n        dependsOn: [0],\n        skills: ['mcp-security-hardening'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 5500,\n  },\n  {\n    type: 'frontend-compliance',\n    name: 'Frontend 2026 Compliance Pipeline',\n    description: 'Modernize frontend to 2026 patterns',\n    triggers: [\n      'frontend compliance',\n      'modernize frontend',\n      'update react',\n      'frontend 2026',\n    ],\n    steps: [\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Upgrade to React 19 patterns',\n        dependsOn: [],\n        skills: ['react-server-components-framework', 'zustand-patterns'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'performance-engineer',\n        description: 'Optimize Core Web Vitals',\n        dependsOn: [0],\n        skills: ['core-web-vitals', 'lazy-loading-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'accessibility-specialist',\n        description: 'Ensure WCAG 2.2 compliance',\n        dependsOn: [0],\n        skills: ['a11y-testing', 'focus-management'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 6500,\n  },\n];\n\n// -----------------------------------------------------------------------------\n// Pipeline Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect if prompt matches a pipeline trigger\n */\nexport function detectPipeline(prompt: string): PipelineDefinition | null {\n  const promptLower = prompt.toLowerCase();\n\n  for (const pipeline of PIPELINES) {\n    for (const trigger of pipeline.triggers) {\n      if (promptLower.includes(trigger)) {\n        logHook(\n          'multi-agent-coordinator',\n          `Detected pipeline: ${pipeline.type} (trigger: \"${trigger}\")`\n        );\n        return pipeline;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get pipeline by type\n */\nexport function getPipelineByType(type: PipelineType): PipelineDefinition | null {\n  return PIPELINES.find(p => p.type === type) || null;\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Execution\n// -----------------------------------------------------------------------------\n\n/**\n * Create a pipeline execution plan with task instructions\n */\nexport function createPipelineExecution(\n  pipeline: PipelineDefinition\n): {\n  execution: PipelineExecution;\n  tasks: TaskCreateInstruction[];\n} {\n  const pipelineId = `pipeline-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n\n  // Create task instructions for each step\n  const tasks: TaskCreateInstruction[] = [];\n  const taskIds: Record<number, string> = {};\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const taskId = `task-${pipelineId}-${i}`;\n    taskIds[i] = taskId;\n\n    const metadata: TaskMetadata = {\n      source: 'pipeline',\n      dispatchedAgent: step.agent,\n      pipelineId,\n      pipelineStep: i,\n      relatedSkills: step.skills,\n    };\n\n    // Build blockedBy from dependsOn\n    const blockedBy = step.dependsOn.map(dep => taskIds[dep]).filter(Boolean);\n\n    tasks.push({\n      subject: `[${pipeline.name}] Step ${i + 1}: ${step.description}`,\n      description: `Pipeline step: ${step.agent}\\n\\n${step.description}\\n\\nEstimated tokens: ${step.estimatedTokens}`,\n      activeForm: `Running ${step.agent}`,\n      metadata,\n      blockedBy: blockedBy.length > 0 ? blockedBy : undefined,\n    });\n  }\n\n  const execution: PipelineExecution = {\n    pipelineId,\n    type: pipeline.type,\n    startedAt: new Date().toISOString(),\n    taskIds,\n    currentStep: 0,\n    completedSteps: [],\n    status: 'running',\n  };\n\n  return { execution, tasks };\n}\n\n/**\n * Register pipeline and tasks with tracking systems\n */\nexport function registerPipelineExecution(\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): void {\n  // Register pipeline\n  registerPipeline(execution);\n\n  // Register each task\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    const taskId = execution.taskIds[i];\n\n    if (taskId && task.metadata.dispatchedAgent) {\n      registerTask(\n        taskId,\n        task.metadata.dispatchedAgent,\n        task.metadata.dispatchConfidence || 100,\n        execution.pipelineId,\n        i\n      );\n    }\n  }\n\n  logHook(\n    'multi-agent-coordinator',\n    `Registered pipeline ${execution.pipelineId} with ${tasks.length} tasks`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Message Formatting\n// -----------------------------------------------------------------------------\n\n/**\n * Format pipeline plan as markdown for user\n */\nexport function formatPipelinePlan(\n  pipeline: PipelineDefinition,\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): string {\n  let md = `## \uD83D\uDD04 Pipeline Detected: ${pipeline.name}\n\n${pipeline.description}\n\n**Pipeline ID:** \\`${execution.pipelineId}\\`\n**Estimated Total Tokens:** ~${pipeline.estimatedTotalTokens}\n\n### Pipeline Steps\n\n`;\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const deps = step.dependsOn.length > 0\n      ? ` (after steps: ${step.dependsOn.map(d => d + 1).join(', ')})`\n      : ' (can start immediately)';\n\n    md += `**${i + 1}. ${step.agent}**${deps}\n   ${step.description}\n   Skills: ${step.skills?.join(', ') || 'none'}\n\n`;\n  }\n\n  md += `### Task Creation Instructions\n\nCreate these tasks to track the pipeline:\n\n`;\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    md += `**Task ${i + 1}:**\n\\`\\`\\`\nTaskCreate:\n  subject: \"${task.subject}\"\n  activeForm: \"${task.activeForm}\"\n${task.blockedBy ? `  blockedBy: ${JSON.stringify(task.blockedBy)}` : ''}\n\\`\\`\\`\n\n`;\n  }\n\n  md += `### Start Pipeline\n\nAfter creating all tasks, spawn the first agent:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${pipeline.steps[0].agent}\"\n\\`\\`\\`\n\nThe orchestration layer will track progress and suggest next agents as steps complete.`;\n\n  return md;\n}\n", "/**\n * Antipattern Detector - UserPromptSubmit Hook\n * Suggests checking mem0 for known failed patterns before implementation\n * CC 2.1.7 Compliant\n *\n * Part of mem0 Semantic Memory Integration (#49)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// Keywords that suggest implementation work where antipatterns matter\nconst IMPLEMENTATION_KEYWORDS = [\n  'implement',\n  'add',\n  'create',\n  'build',\n  'set up',\n  'configure',\n  'pagination',\n  'authentication',\n  'caching',\n  'database',\n  'api',\n  'endpoint',\n];\n\n/**\n * Detect best practice category from prompt\n */\nfunction detectCategory(prompt: string): string {\n  const promptLower = prompt.toLowerCase();\n\n  if (/pagination|cursor|offset|page/i.test(promptLower)) return 'pagination';\n  if (/auth|jwt|oauth|login|session/i.test(promptLower)) return 'authentication';\n  if (/cache|redis|memo/i.test(promptLower)) return 'caching';\n  if (/database|sql|postgres|query/i.test(promptLower)) return 'database';\n  if (/api|endpoint|rest|graphql/i.test(promptLower)) return 'api';\n  if (/error|exception|handling/i.test(promptLower)) return 'error-handling';\n  if (/test|testing|spec/i.test(promptLower)) return 'testing';\n\n  return 'general';\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Generate global mem0 user ID\n */\nfunction getGlobalUserId(scope: string): string {\n  return `global:${scope}`;\n}\n\n/**\n * Antipattern detector - suggests mem0 search for known failures\n */\nexport function antipatternDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Skip if prompt too short\n  if (prompt.length < 30) {\n    return outputSilentSuccess();\n  }\n\n  // Check if prompt suggests implementation work\n  const promptLower = prompt.toLowerCase();\n  let matchedKeyword = '';\n\n  for (const keyword of IMPLEMENTATION_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      matchedKeyword = keyword;\n      break;\n    }\n  }\n\n  if (!matchedKeyword) {\n    return outputSilentSuccess();\n  }\n\n  logHook('antipattern-detector', `Implementation keyword detected: ${matchedKeyword}`);\n\n  // Get category and user IDs for search suggestion\n  const category = detectCategory(prompt);\n  const projectUserId = getMem0UserId('best-practices', projectDir);\n  const globalUserId = getGlobalUserId('best-practices');\n\n  logHook('antipattern-detector', `Suggesting antipattern check for: ${matchedKeyword} (category: ${category})`);\n\n  // Build search suggestion message\n  const systemMsg = `[Antipattern Check] Before implementing ${matchedKeyword}, check for known failures:\n\\`mcp__mem0__search_memories\\` with query=\"${matchedKeyword} failed\" and filters={\"AND\":[{\"user_id\":\"${projectUserId}\"},{\"metadata.outcome\":\"failed\"}]}\nOr check global: user_id=\"${globalUserId}\"`;\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n  };\n}\n", "/**\n * Antipattern Warning - UserPromptSubmit Hook\n * Proactive anti-pattern detection and warning injection\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for warnings\n *\n * Enhanced with Mem0 semantic search hints for project/global anti-patterns.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Keywords that indicate implementation intent\nconst IMPLEMENTATION_KEYWORDS = [\n  'implement',\n  'add',\n  'create',\n  'build',\n  'set up',\n  'setup',\n  'configure',\n  'use',\n  'write',\n  'make',\n  'develop',\n];\n\n// Known anti-patterns database\nconst KNOWN_ANTIPATTERNS: Array<{ pattern: string; warning: string }> = [\n  {\n    pattern: 'offset pagination',\n    warning:\n      'Offset pagination causes performance issues on large tables. Use cursor-based pagination instead.',\n  },\n  {\n    pattern: 'manual jwt validation',\n    warning:\n      'Manual JWT validation is error-prone. Use established libraries like python-jose or jsonwebtoken.',\n  },\n  {\n    pattern: 'storing passwords in plaintext',\n    warning: 'Never store passwords in plaintext. Use bcrypt, argon2, or scrypt.',\n  },\n  {\n    pattern: 'global state',\n    warning:\n      'Global mutable state causes testing and concurrency issues. Use dependency injection.',\n  },\n  {\n    pattern: 'synchronous file operations',\n    warning: 'Synchronous file I/O blocks the event loop. Use async file operations.',\n  },\n  {\n    pattern: 'n+1 query',\n    warning: 'N+1 queries cause performance problems. Use eager loading or batch queries.',\n  },\n  {\n    pattern: 'polling for real-time',\n    warning: 'Polling is inefficient for real-time updates. Consider SSE or WebSocket.',\n  },\n];\n\ninterface LearnedPattern {\n  text: string;\n  outcome?: string;\n}\n\ninterface PatternsFile {\n  patterns?: LearnedPattern[];\n}\n\ninterface GlobalAntipattern {\n  pattern: string;\n  warning: string;\n}\n\ninterface GlobalPatternsFile {\n  antipatterns?: GlobalAntipattern[];\n}\n\n/**\n * Check if prompt contains implementation keywords\n */\nfunction isImplementationPrompt(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of IMPLEMENTATION_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Detect best practice category from prompt\n */\nfunction detectCategory(prompt: string): string {\n  const promptLower = prompt.toLowerCase();\n\n  if (/pagination|cursor|offset|page/i.test(promptLower)) return 'pagination';\n  if (/auth|jwt|oauth|login|session/i.test(promptLower)) return 'authentication';\n  if (/cache|redis|memo/i.test(promptLower)) return 'caching';\n  if (/database|sql|postgres|query/i.test(promptLower)) return 'database';\n  if (/api|endpoint|rest|graphql/i.test(promptLower)) return 'api';\n\n  return 'general';\n}\n\n/**\n * Search local patterns for anti-patterns\n */\nfunction searchLocalAntipatterns(prompt: string, projectDir: string): string[] {\n  const promptLower = prompt.toLowerCase();\n  const warnings: string[] = [];\n\n  // Check known anti-patterns\n  for (const { pattern, warning } of KNOWN_ANTIPATTERNS) {\n    if (promptLower.includes(pattern)) {\n      warnings.push(warning);\n    }\n  }\n\n  // Check learned patterns file\n  const patternsFile = join(projectDir, '.claude', 'feedback', 'learned-patterns.json');\n  if (existsSync(patternsFile)) {\n    try {\n      const data: PatternsFile = JSON.parse(readFileSync(patternsFile, 'utf8'));\n      const failedPatterns = (data.patterns || []).filter((p) => p.outcome === 'failed');\n\n      for (const pattern of failedPatterns) {\n        if (pattern.text) {\n          const patternLower = pattern.text.toLowerCase();\n          const firstWord = patternLower.split(' ')[0];\n          if (firstWord && promptLower.includes(firstWord)) {\n            warnings.push(`Previously failed: ${pattern.text}`);\n          }\n        }\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  // Check global patterns\n  const globalPatternsFile = join(process.env.HOME || process.env.USERPROFILE || '', '.claude', 'global-patterns.json');\n  if (existsSync(globalPatternsFile)) {\n    try {\n      const data: GlobalPatternsFile = JSON.parse(readFileSync(globalPatternsFile, 'utf8'));\n      for (const { pattern, warning } of data.antipatterns || []) {\n        if (promptLower.includes(pattern.toLowerCase())) {\n          warnings.push(`${pattern}: ${warning}`);\n        }\n      }\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  return warnings;\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Build mem0 search hint for the prompt\n */\nfunction buildMem0SearchHint(prompt: string, projectDir: string): string {\n  const category = detectCategory(prompt);\n  const userId = getMem0UserId('best-practices', projectDir);\n  const globalUserId = `global:best-practices`;\n\n  return `Before implementing, search Mem0 for relevant patterns (graph memory enabled):\n\n1. Project anti-patterns (category: ${category}):\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${userId}\", \"filters\": {\"metadata.outcome\": \"failed\"}}\n\n2. Project best practices:\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${userId}\", \"filters\": {\"metadata.outcome\": \"success\"}}\n\n3. Cross-project failures:\n   mcp__mem0__search_memories with:\n   {\"query\": \"${prompt.slice(0, 50)}\", \"user_id\": \"${globalUserId}\", \"filters\": {\"metadata.outcome\": \"failed\"}}`;\n}\n\n/**\n * Antipattern warning hook - detects and warns about known anti-patterns\n */\nexport function antipatternWarning(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  // Only check implementation prompts\n  if (!isImplementationPrompt(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('antipattern-warning', 'Checking prompt for anti-patterns...');\n\n  // Search for matching anti-patterns\n  const warnings = searchLocalAntipatterns(prompt, projectDir);\n\n  // Build mem0 search hints\n  const mem0SearchHints = buildMem0SearchHint(prompt, projectDir);\n\n  if (warnings.length > 0) {\n    logHook('antipattern-warning', `Found anti-pattern warnings: ${warnings.join(', ')}`);\n\n    // Build warning message with mem0 search hints\n    const warningMessage = `## Anti-Pattern Warning\n\nThe following patterns have previously caused issues:\n\n${warnings.map((w) => `- ${w}`).join('\\n')}\n\nConsider alternative approaches before proceeding.\n\n${mem0SearchHints}`;\n\n    return outputPromptContext(warningMessage);\n  }\n\n  // No local warnings - provide mem0 search hints for significant implementation tasks\n  if (/implement|build|create|develop/.test(prompt.toLowerCase())) {\n    return outputPromptContext(mem0SearchHints);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Context Injector - UserPromptSubmit Hook\n * Injects relevant context hints based on user prompt keywords\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Context injector hook - adds helpful hints based on prompt content\n */\nexport function contextInjector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  logHook('context-injector', `User prompt received (${prompt.length} chars)`);\n\n  const contextHints: string[] = [];\n\n  // If prompt mentions issues or bugs, remind about issue docs\n  if (/issue|bug|fix|#[0-9]+/.test(prompt)) {\n    const issueDocsDir = join(projectDir, 'docs', 'issues');\n    if (existsSync(issueDocsDir)) {\n      contextHints.push('Check docs/issues/ for issue documentation.');\n    }\n  }\n\n  // If prompt mentions testing, remind about test patterns\n  if (/test|testing|pytest|jest/.test(prompt.toLowerCase())) {\n    contextHints.push(\"Remember to use 'tee' for visible test output.\");\n  }\n\n  // If prompt mentions deployment or CI/CD\n  if (/deploy|ci|cd|pipeline|github.actions/.test(prompt.toLowerCase())) {\n    contextHints.push('Check .github/workflows/ for CI configuration.');\n  }\n\n  // Log context hints if any\n  if (contextHints.length > 0) {\n    logHook('context-injector', `Context hints: ${contextHints.join(' ')}`);\n  }\n\n  // Currently outputs silent success - hints are logged only\n  // Could be enhanced to use additionalContext in the future\n  return outputSilentSuccess();\n}\n", "/**\n * Context Pruning Advisor - UserPromptSubmit Hook\n * Recommends context pruning when usage exceeds 70%\n *\n * Analyzes loaded context (skills, files, agent outputs) and scores by:\n * - Recency: How recently was it accessed? (0-10 points)\n * - Frequency: How often accessed this session? (0-10 points)\n * - Relevance: How related to current prompt? (0-10 points)\n *\n * Total score: 0-30 points\n * Pruning threshold: Items with score < 15 are candidates\n *\n * Issue: #126\n * CC 2.1.9 Compliant: Uses additionalContext for recommendations\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  outputPromptContext,\n  logHook,\n  getProjectDir,\n  getSessionId,\n} from '../lib/common.js';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// Configuration\nconst CONTEXT_TRIGGER = 0.7; // Trigger at 70% context usage\nconst CONTEXT_CRITICAL = 0.95; // Critical threshold\nconst PRUNE_THRESHOLD_HIGH = 8; // Score 0-8: High priority pruning\nconst PRUNE_THRESHOLD_MED = 15; // Score 9-15: Medium priority pruning\nconst MAX_RECOMMENDATIONS = 5; // Limit recommendations\n\ninterface ContextItem {\n  id: string;\n  tags?: string[];\n  last_accessed?: string;\n  loaded_at?: string;\n  access_count?: number;\n  estimated_tokens?: number;\n}\n\ninterface StateFile {\n  session_id: string;\n  updated_at: string;\n  total_context_tokens: number;\n  context_budget: number;\n  items: ContextItem[];\n}\n\n/**\n * Calculate recency score (0-10) based on time since last access\n */\nfunction calculateRecencyScore(lastAccessed: string | undefined): number {\n  if (!lastAccessed) return 0;\n\n  const currentTime = Date.now();\n  let lastEpoch: number;\n\n  if (/^\\d+$/.test(lastAccessed)) {\n    lastEpoch = parseInt(lastAccessed, 10);\n  } else {\n    lastEpoch = new Date(lastAccessed).getTime();\n    if (isNaN(lastEpoch)) return 0;\n  }\n\n  const ageMinutes = (currentTime - lastEpoch) / (1000 * 60);\n\n  if (ageMinutes <= 5) return 10;\n  if (ageMinutes <= 15) return 8;\n  if (ageMinutes <= 30) return 6;\n  if (ageMinutes <= 60) return 4;\n  if (ageMinutes <= 120) return 2;\n  return 0;\n}\n\n/**\n * Calculate frequency score (0-10) based on access count\n */\nfunction calculateFrequencyScore(count: number): number {\n  if (count >= 10) return 10;\n  if (count >= 7) return 8;\n  if (count >= 4) return 6;\n  if (count >= 2) return 4;\n  if (count >= 1) return 2;\n  return 0;\n}\n\n/**\n * Calculate relevance score (0-10) based on keyword overlap\n */\nfunction calculateRelevanceScore(itemKeywords: string[], promptKeywords: string[]): number {\n  if (itemKeywords.length === 0 || promptKeywords.length === 0) {\n    return 2; // Generic/infrastructure default\n  }\n\n  const itemSet = new Set(itemKeywords.map((k) => k.toLowerCase()));\n  const promptSet = new Set(promptKeywords.map((k) => k.toLowerCase()));\n\n  let overlap = 0;\n  for (const keyword of itemSet) {\n    if (promptSet.has(keyword)) {\n      overlap++;\n    }\n  }\n\n  const overlapRatio = overlap / itemSet.size;\n\n  if (overlapRatio >= 0.75) return 10;\n  if (overlapRatio >= 0.5) return 8;\n  if (overlapRatio >= 0.3) return 6;\n  if (overlapRatio >= 0.15) return 4;\n  if (overlap > 0) return 2;\n  return 0;\n}\n\n/**\n * Extract keywords from user prompt\n */\nfunction extractPromptKeywords(prompt: string): string[] {\n  const stopwords = new Set([\n    'the',\n    'and',\n    'for',\n    'with',\n    'from',\n    'that',\n    'this',\n    'have',\n    'will',\n    'can',\n    'should',\n    'would',\n    'could',\n  ]);\n\n  return prompt\n    .toLowerCase()\n    .match(/\\b[a-z]{3,}\\b/g)\n    ?.filter((word) => !stopwords.has(word))\n    .slice(0, 20) || [];\n}\n\n/**\n * Get state file path\n */\nfunction getStateFilePath(): string {\n  const sessionId = getSessionId();\n  return `/tmp/claude-context-tracking-${sessionId}.json`;\n}\n\n/**\n * Initialize or load state file\n */\nfunction loadOrInitState(): StateFile {\n  const stateFile = getStateFilePath();\n\n  if (existsSync(stateFile)) {\n    try {\n      return JSON.parse(readFileSync(stateFile, 'utf8'));\n    } catch {\n      // Fall through to create new\n    }\n  }\n\n  const sessionId = getSessionId();\n  const state: StateFile = {\n    session_id: sessionId,\n    updated_at: new Date().toISOString(),\n    total_context_tokens: 0,\n    context_budget: 12000,\n    items: [],\n  };\n\n  writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  return state;\n}\n\n/**\n * Get estimated context usage percentage\n */\nfunction getContextUsagePercentage(state: StateFile): number {\n  // Try environment variable first (if available from CC)\n  const envPercent = process.env.CLAUDE_CONTEXT_USAGE_PERCENT;\n  if (envPercent) {\n    const parsed = parseFloat(envPercent);\n    if (!isNaN(parsed)) return parsed;\n  }\n\n  // Fallback to state file estimate\n  if (state.context_budget > 0) {\n    return state.total_context_tokens / state.context_budget;\n  }\n\n  return 0;\n}\n\ninterface PruneCandidate {\n  score: number;\n  priority: string;\n  itemId: string;\n  tokens: number;\n}\n\n/**\n * Analyze context and generate pruning recommendations\n */\nfunction analyzeAndRecommend(state: StateFile, promptKeywords: string[]): PruneCandidate[] {\n  const candidates: PruneCandidate[] = [];\n\n  for (const item of state.items) {\n    const lastAccessed = item.last_accessed || item.loaded_at;\n    const accessCount = item.access_count || 0;\n    const keywords = item.tags || [];\n\n    const recencyScore = calculateRecencyScore(lastAccessed);\n    const frequencyScore = calculateFrequencyScore(accessCount);\n    const relevanceScore = calculateRelevanceScore(keywords, promptKeywords);\n    const totalScore = recencyScore + frequencyScore + relevanceScore;\n\n    logHook(\n      'context-pruning-advisor',\n      `Scored ${item.id}: R=${recencyScore} F=${frequencyScore} V=${relevanceScore} Total=${totalScore}`\n    );\n\n    if (totalScore <= PRUNE_THRESHOLD_MED) {\n      candidates.push({\n        score: totalScore,\n        priority: totalScore <= PRUNE_THRESHOLD_HIGH ? 'HIGH' : 'MED',\n        itemId: item.id,\n        tokens: item.estimated_tokens || 500,\n      });\n    }\n  }\n\n  // Sort by score ascending (lowest first) and limit\n  return candidates.sort((a, b) => a.score - b.score).slice(0, MAX_RECOMMENDATIONS);\n}\n\n/**\n * Build recommendation message\n */\nfunction buildRecommendationMessage(candidates: PruneCandidate[]): string {\n  let totalSavings = 0;\n  const lines: string[] = [];\n\n  for (let i = 0; i < candidates.length; i++) {\n    const { priority, itemId, score, tokens } = candidates[i];\n    totalSavings += tokens;\n\n    // Format item name for display\n    const displayName = itemId.replace(/^(skill:|file:|agent:)/, '');\n    lines.push(`  ${i + 1}. [${priority}] ${displayName} (score: ${score}, saves ~${tokens}t)`);\n  }\n\n  return `Context usage >70%. Pruning recommendations:\n${lines.join('\\n')}\n\nPotential savings: ~${totalSavings} tokens\nTo prune: Archive or unload low-scoring context items.`;\n}\n\n/**\n * Context pruning advisor hook\n */\nexport function contextPruningAdvisor(input: HookInput): HookResult {\n  const projectDir = input.project_dir || getProjectDir();\n  const prompt = input.prompt || '';\n\n  // Ensure log directory exists\n  const logDir = join(projectDir, 'logs');\n  if (!existsSync(logDir)) {\n    try {\n      mkdirSync(logDir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Initialize/load state\n  const state = loadOrInitState();\n\n  // Get current context usage\n  const contextUsage = getContextUsagePercentage(state);\n  logHook(\n    'context-pruning-advisor',\n    `Context usage: ${contextUsage} (trigger threshold: ${CONTEXT_TRIGGER})`\n  );\n\n  // Fast exit: Context usage below threshold\n  if (contextUsage < CONTEXT_TRIGGER) {\n    logHook('context-pruning-advisor', 'Context usage within limits, no pruning needed');\n    return outputSilentSuccess();\n  }\n\n  // Critical path: Context usage at critical level (>95%)\n  if (contextUsage >= CONTEXT_CRITICAL) {\n    logHook('context-pruning-advisor', `CRITICAL: Context usage at ${contextUsage * 100}% (>95%)`);\n    const criticalMsg = `CRITICAL: Context usage at ${Math.round(contextUsage * 100)}% (>95%). Use /ork:context-compression immediately or manually archive old decisions and patterns.`;\n    return outputPromptContext(criticalMsg);\n  }\n\n  // Extract keywords from current prompt\n  if (!prompt) {\n    logHook('context-pruning-advisor', 'No user prompt found in hook input, skipping analysis');\n    return outputSilentSuccess();\n  }\n\n  const promptKeywords = extractPromptKeywords(prompt);\n  logHook('context-pruning-advisor', `Extracted prompt keywords: ${promptKeywords.join(', ')}`);\n\n  // Analyze context and generate recommendations\n  const candidates = analyzeAndRecommend(state, promptKeywords);\n\n  if (candidates.length > 0) {\n    const message = buildRecommendationMessage(candidates);\n    logHook(\n      'context-pruning-advisor',\n      `Recommending ${candidates.length} pruning candidates`\n    );\n    return outputPromptContext(message);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Memory Context - UserPromptSubmit Hook\n * Auto-searches knowledge graph for relevant context based on user prompt\n * CC 2.1.7 Compliant\n *\n * Graph-First Architecture (v2.1):\n * - ALWAYS works - knowledge graph requires no configuration\n * - Primary: Search knowledge graph (mcp__memory__search_nodes)\n * - Optional: Also search mem0 for semantic matches if configured\n *\n * Part of Memory Fabric v2.1\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Keywords that suggest memory search would be valuable\nconst MEMORY_TRIGGER_KEYWORDS = [\n  'add',\n  'implement',\n  'create',\n  'build',\n  'design',\n  'refactor',\n  'update',\n  'modify',\n  'fix',\n  'change',\n  'continue',\n  'resume',\n  'remember',\n  'previous',\n  'last time',\n  'before',\n  'earlier',\n  'pattern',\n  'decision',\n  'how did we',\n  'what did we',\n];\n\n// Keywords that suggest graph search would be valuable\nconst GRAPH_TRIGGER_KEYWORDS = [\n  'relationship',\n  'related',\n  'connected',\n  'depends',\n  'uses',\n  'recommends',\n  'what does.*recommend',\n  'how does.*work with',\n];\n\n// Minimum prompt length to trigger memory search\nconst MIN_PROMPT_LENGTH = 20;\n\n/**\n * Check if prompt contains memory trigger keywords\n */\nfunction shouldSearchMemory(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of MEMORY_TRIGGER_KEYWORDS) {\n    if (promptLower.includes(keyword)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if prompt contains graph trigger keywords\n */\nfunction hasGraphTrigger(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const keyword of GRAPH_TRIGGER_KEYWORDS) {\n    if (new RegExp(keyword, 'i').test(promptLower)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Extract search terms from prompt\n */\nfunction extractSearchTerms(prompt: string): string {\n  const stopwords = new Set([\n    'the',\n    'a',\n    'an',\n    'to',\n    'for',\n    'in',\n    'on',\n    'at',\n    'is',\n    'are',\n    'was',\n    'were',\n    'be',\n    'been',\n    'being',\n    'have',\n    'has',\n    'had',\n    'do',\n    'does',\n    'did',\n    'will',\n    'would',\n    'could',\n    'should',\n    'can',\n    'may',\n    'might',\n    'must',\n    'shall',\n    'i',\n    'you',\n    'we',\n    'they',\n    'it',\n    'this',\n    'that',\n    'these',\n    'those',\n    'my',\n    'your',\n    'our',\n    'their',\n    'its',\n    'and',\n    'or',\n    'but',\n    'if',\n    'then',\n    'else',\n    'when',\n    'where',\n    'how',\n    'what',\n    'which',\n    'who',\n    'whom',\n    'with',\n    'from',\n    'into',\n    'onto',\n    'about',\n    'after',\n    'before',\n    'global',\n  ]);\n\n  const words = prompt\n    .toLowerCase()\n    .replace(/[^a-z\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter((word) => word.length > 2 && !stopwords.has(word))\n    .slice(0, 5);\n\n  return words.join(' ');\n}\n\n/**\n * Generate mem0 user ID for a scope\n */\nfunction getMem0UserId(scope: string, projectDir: string): string {\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  return `project:${projectName}:${scope}`;\n}\n\n/**\n * Get current agent ID if available\n */\nfunction getAgentContext(projectDir: string): string {\n  // Check environment variable first\n  const agentId = process.env.CLAUDE_AGENT_ID;\n  if (agentId) return agentId;\n\n  // Check agent tracking file\n  const trackingFile = join(projectDir, '.claude', 'session', 'current-agent-id');\n  if (existsSync(trackingFile)) {\n    try {\n      return readFileSync(trackingFile, 'utf8').trim();\n    } catch {\n      // Ignore\n    }\n  }\n\n  return '';\n}\n\n/**\n * Memory context hook - suggests memory searches for relevant context\n */\nexport function memoryContext(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  const isMem0Available = false; // Simplified - mem0 availability would be checked at runtime\n\n  logHook('memory-context', `Memory context hook starting (graph-first, mem0=${isMem0Available})`);\n\n  // Skip if prompt is too short\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    logHook('memory-context', `Prompt too short (${prompt.length} chars), skipping memory search`);\n    return outputSilentSuccess();\n  }\n\n  // Check for special prefixes\n  const useGlobal =\n    prompt.startsWith('@global') ||\n    prompt.includes('cross-project') ||\n    prompt.includes('all projects');\n  const useGraph = hasGraphTrigger(prompt);\n\n  if (useGlobal) {\n    logHook('memory-context', 'Detected @global prefix - will suggest cross-project search');\n  }\n\n  if (useGraph) {\n    logHook('memory-context', 'Detected graph-related query');\n  }\n\n  // Get agent context\n  const agentContext = getAgentContext(projectDir);\n  if (agentContext) {\n    logHook('memory-context', `Agent context detected: ${agentContext}`);\n  }\n\n  // Check if memory search would be valuable\n  if (!shouldSearchMemory(prompt)) {\n    logHook('memory-context', 'No memory trigger keywords found, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Extract search terms\n  const searchTerms = extractSearchTerms(prompt);\n  if (!searchTerms) {\n    logHook('memory-context', 'No search terms extracted, skipping');\n    return outputSilentSuccess();\n  }\n\n  logHook('memory-context', `Search terms: ${searchTerms}`);\n\n  // Build scope description\n  const scopeDesc = useGlobal ? 'cross-project' : 'project';\n\n  // Build context suggestion message\n  // NOTE: We build the message but return silent success\n  // The original bash hook did the same - built the message but returned silently\n  // Claude already has access to memory tools\n\n  const userIdDecisions = getMem0UserId('decisions', projectDir);\n\n  let systemMsg = `[Memory Context] For relevant past ${scopeDesc} decisions, use mcp__memory__search_nodes with query=\"${searchTerms}\"`;\n\n  // Add relationship hint if graph-related query\n  if (useGraph) {\n    systemMsg +=\n      ' | For relationships: mcp__memory__open_nodes on found entities | Graph traversal available';\n  }\n\n  // Add mem0 hint if available\n  if (isMem0Available && userIdDecisions) {\n    systemMsg += ` | [Enhanced] For semantic search: mcp__mem0__search_memories query=\"${searchTerms}\" user_id=\"${userIdDecisions}\" enable_graph=true`;\n\n    if (!useGlobal) {\n      systemMsg += ' | Cross-project: user_id=\"global:best-practices\"';\n    }\n  }\n\n  // Add agent context hint\n  if (agentContext) {\n    systemMsg += ` | Agent context: ${agentContext}`;\n  }\n\n  logHook('memory-context', `Memory context available for: ${searchTerms}`);\n\n  // Silent operation - Claude already has access to memory tools\n  return outputSilentSuccess();\n}\n", "/**\n * Session Event Tracker\n * Logs all session events (skills, agents, hooks, decisions) with user identity.\n *\n * Events are stored per-session in JSONL format for later aggregation.\n * This enables learning user patterns across sessions.\n *\n * Storage: .claude/memory/sessions/{session_id}/events.jsonl\n */\n\nimport { existsSync, appendFileSync, mkdirSync, readFileSync, readdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport { getIdentityContext, type IdentityContext } from './user-identity.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Event types that can be tracked\n */\nexport type SessionEventType =\n  | 'skill_invoked'\n  | 'agent_spawned'\n  | 'hook_triggered'\n  | 'decision_made'\n  | 'preference_stated'\n  | 'problem_reported'\n  | 'solution_found'\n  | 'tool_used'\n  | 'session_start'\n  | 'session_end'\n  | 'communication_style_detected';\n\n/**\n * A single session event\n */\nexport interface SessionEvent {\n  /** Unique event ID */\n  event_id: string;\n  /** Event type */\n  event_type: SessionEventType;\n  /** Identity context (user, session, machine) */\n  identity: IdentityContext;\n  /** Event-specific payload */\n  payload: {\n    /** Name of skill/agent/hook/tool */\n    name: string;\n    /** Input data (optional, may be truncated for privacy) */\n    input?: Record<string, unknown>;\n    /** Output/result (optional, may be truncated) */\n    output?: Record<string, unknown>;\n    /** Duration in milliseconds */\n    duration_ms?: number;\n    /** Whether the event succeeded */\n    success: boolean;\n    /** Additional context */\n    context?: string;\n    /** Confidence score (for decisions) */\n    confidence?: number;\n  };\n}\n\n/**\n * Session summary (aggregated at session end)\n */\nexport interface SessionSummary {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  start_time?: string;\n  end_time?: string;\n  duration_ms?: number;\n  event_counts: Record<SessionEventType, number>;\n  skills_used: string[];\n  agents_spawned: string[];\n  hooks_triggered: string[];\n  decisions_made: number;\n  problems_reported: number;\n  solutions_found: number;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/** Session ID validation regex - alphanumeric, dashes, underscores only (SEC-002) */\nconst SESSION_ID_PATTERN = /^[a-zA-Z0-9_-]{1,128}$/;\n\n/**\n * Validate session ID to prevent path traversal attacks.\n * Defense-in-depth: trusted sources, but we validate at boundary anyway.\n */\nfunction isValidSessionId(sessionId: string): boolean {\n  return SESSION_ID_PATTERN.test(sessionId);\n}\n\n/**\n * Get session storage directory\n */\nfunction getSessionDir(sessionId?: string): string {\n  const sid = sessionId || getSessionId();\n  // Validate session ID to prevent path traversal (SEC-002)\n  if (!isValidSessionId(sid)) {\n    throw new Error(`Invalid session ID format`);\n  }\n  return `${getProjectDir()}/.claude/memory/sessions/${sid}`;\n}\n\n/**\n * Get events file path for a session\n */\nfunction getEventsPath(sessionId?: string): string {\n  return `${getSessionDir(sessionId)}/events.jsonl`;\n}\n\n/**\n * Ensure session directory exists\n */\nfunction ensureSessionDir(sessionId?: string): void {\n  const dir = getSessionDir(sessionId);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n// =============================================================================\n// EVENT GENERATION\n// =============================================================================\n\nlet eventCounter = 0;\n\n/**\n * Generate unique event ID\n */\nfunction generateEventId(): string {\n  eventCounter++;\n  return `evt-${Date.now()}-${eventCounter}`;\n}\n\n// =============================================================================\n// EVENT TRACKING\n// =============================================================================\n\n/**\n * Track a session event\n *\n * @param eventType - Type of event\n * @param name - Name of skill/agent/hook/tool\n * @param options - Additional event options\n */\nexport function trackEvent(\n  eventType: SessionEventType,\n  name: string,\n  options: {\n    input?: Record<string, unknown>;\n    output?: Record<string, unknown>;\n    duration_ms?: number;\n    success?: boolean;\n    context?: string;\n    confidence?: number;\n  } = {}\n): void {\n  try {\n    const event: SessionEvent = {\n      event_id: generateEventId(),\n      event_type: eventType,\n      identity: getIdentityContext(),\n      payload: {\n        name,\n        input: sanitizeForStorage(options.input),\n        output: sanitizeForStorage(options.output),\n        duration_ms: options.duration_ms,\n        success: options.success ?? true,\n        context: options.context ? truncate(options.context, 500) : undefined,\n        confidence: options.confidence,\n      },\n    };\n\n    ensureSessionDir();\n    const eventsPath = getEventsPath();\n    appendFileSync(eventsPath, JSON.stringify(event) + '\\n');\n\n    logHook('session-tracker', `Tracked ${eventType}: ${name}`, 'debug');\n  } catch (error) {\n    logHook('session-tracker', `Failed to track event: ${error}`, 'warn');\n  }\n}\n\n/**\n * Track skill invocation\n */\nexport function trackSkillInvoked(\n  skillName: string,\n  args?: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('skill_invoked', skillName, {\n    input: args ? { args } : undefined,\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track agent spawn\n */\nexport function trackAgentSpawned(\n  agentType: string,\n  prompt?: string,\n  success: boolean = true\n): void {\n  trackEvent('agent_spawned', agentType, {\n    input: prompt ? { prompt: truncate(prompt, 200) } : undefined,\n    success,\n  });\n}\n\n/**\n * Track hook triggered\n */\nexport function trackHookTriggered(\n  hookName: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('hook_triggered', hookName, {\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track decision made\n */\nexport function trackDecisionMade(\n  decision: string,\n  rationale?: string,\n  confidence?: number\n): void {\n  trackEvent('decision_made', 'decision', {\n    context: decision,\n    input: rationale ? { rationale } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track preference stated\n */\nexport function trackPreferenceStated(\n  preference: string,\n  confidence?: number\n): void {\n  trackEvent('preference_stated', 'preference', {\n    context: preference,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track problem reported\n */\nexport function trackProblemReported(problem: string): void {\n  trackEvent('problem_reported', 'problem', {\n    context: problem,\n    success: true,\n  });\n}\n\n/**\n * Track solution found\n */\nexport function trackSolutionFound(\n  solution: string,\n  problemId?: string,\n  confidence?: number\n): void {\n  trackEvent('solution_found', 'solution', {\n    context: solution,\n    input: problemId ? { problem_id: problemId } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track tool usage\n *\n * @param toolName - Name of the tool (e.g., 'Grep', 'Read')\n * @param success - Whether the tool call succeeded\n * @param durationMs - Duration of the tool call in milliseconds\n * @param category - Tool category (e.g., 'search', 'file_read') for preference tracking\n */\nexport function trackToolUsed(\n  toolName: string,\n  success: boolean = true,\n  durationMs?: number,\n  category?: string\n): void {\n  trackEvent('tool_used', toolName, {\n    success,\n    duration_ms: durationMs,\n    input: category ? { category } : undefined,\n  });\n}\n\n/**\n * Session context captured at session start\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport interface SessionContext {\n  /** Project directory path */\n  project_dir?: string;\n  /** Current git branch */\n  git_branch?: string;\n  /** Time of day category */\n  time_of_day?: 'morning' | 'afternoon' | 'evening' | 'night';\n  /** Timestamp */\n  started_at: string;\n}\n\n/**\n * Get time of day category from hour\n */\nfunction getTimeOfDay(hour: number): 'morning' | 'afternoon' | 'evening' | 'night' {\n  if (hour >= 5 && hour < 12) return 'morning';\n  if (hour >= 12 && hour < 17) return 'afternoon';\n  if (hour >= 17 && hour < 21) return 'evening';\n  return 'night';\n}\n\n/**\n * Track session start with context\n * Issue #245 Phase 5: Session Lifecycle Tracking\n *\n * @param context - Optional session context (project, branch, time)\n */\nexport function trackSessionStart(context?: Partial<SessionContext>): void {\n  const now = new Date();\n  const sessionContext: SessionContext = {\n    project_dir: context?.project_dir,\n    git_branch: context?.git_branch,\n    time_of_day: context?.time_of_day || getTimeOfDay(now.getHours()),\n    started_at: now.toISOString(),\n  };\n\n  trackEvent('session_start', 'session', {\n    success: true,\n    input: sessionContext as unknown as Record<string, unknown>,\n  });\n}\n\n/**\n * Track session end with timestamp\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport function trackSessionEnd(): void {\n  trackEvent('session_end', 'session', {\n    success: true,\n    input: { ended_at: new Date().toISOString() },\n  });\n}\n\n/**\n * Track user communication style\n */\nexport function trackCommunicationStyle(\n  style: {\n    verbosity: 'terse' | 'moderate' | 'detailed';\n    interaction_type: 'question' | 'command' | 'discussion';\n    technical_level: 'beginner' | 'intermediate' | 'expert';\n  }\n): void {\n  trackEvent('communication_style_detected', 'communication', {\n    input: style as unknown as Record<string, unknown>,\n    success: true,\n  });\n}\n\n\n// =============================================================================\n// SESSION SUMMARY\n// =============================================================================\n\n/**\n * Load all events for a session\n */\nexport function loadSessionEvents(sessionId?: string): SessionEvent[] {\n  const eventsPath = getEventsPath(sessionId);\n\n  if (!existsSync(eventsPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(eventsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    return lines.map(line => JSON.parse(line));\n  } catch (error) {\n    logHook('session-tracker', `Failed to load session events: ${error}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Generate session summary from events\n */\nexport function generateSessionSummary(sessionId?: string): SessionSummary {\n  const events = loadSessionEvents(sessionId);\n  const identity = getIdentityContext();\n\n  const eventCounts: Record<SessionEventType, number> = {\n    skill_invoked: 0,\n    agent_spawned: 0,\n    hook_triggered: 0,\n    decision_made: 0,\n    preference_stated: 0,\n    problem_reported: 0,\n    solution_found: 0,\n    tool_used: 0,\n    session_start: 0,\n    session_end: 0,\n    communication_style_detected: 0,\n  };\n\n  const skillsUsed = new Set<string>();\n  const agentsSpawned = new Set<string>();\n  const hooksTriggered = new Set<string>();\n\n  let startTime: string | undefined;\n  let endTime: string | undefined;\n\n  for (const event of events) {\n    eventCounts[event.event_type]++;\n\n    switch (event.event_type) {\n      case 'skill_invoked':\n        skillsUsed.add(event.payload.name);\n        break;\n      case 'agent_spawned':\n        agentsSpawned.add(event.payload.name);\n        break;\n      case 'hook_triggered':\n        hooksTriggered.add(event.payload.name);\n        break;\n      case 'session_start':\n        startTime = event.identity.timestamp;\n        break;\n      case 'session_end':\n        endTime = event.identity.timestamp;\n        break;\n    }\n  }\n\n  const durationMs =\n    startTime && endTime\n      ? new Date(endTime).getTime() - new Date(startTime).getTime()\n      : undefined;\n\n  return {\n    session_id: sessionId || identity.session_id,\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    start_time: startTime,\n    end_time: endTime,\n    duration_ms: durationMs,\n    event_counts: eventCounts,\n    skills_used: [...skillsUsed],\n    agents_spawned: [...agentsSpawned],\n    hooks_triggered: [...hooksTriggered],\n    decisions_made: eventCounts.decision_made,\n    problems_reported: eventCounts.problem_reported,\n    solutions_found: eventCounts.solution_found,\n  };\n}\n\n// =============================================================================\n// CROSS-SESSION QUERIES\n// =============================================================================\n\n/**\n * List all session IDs for this project\n */\nexport function listSessionIds(): string[] {\n  const sessionsDir = `${getProjectDir()}/.claude/memory/sessions`;\n\n  if (!existsSync(sessionsDir)) {\n    return [];\n  }\n\n  try {\n    return readdirSync(sessionsDir, { withFileTypes: true })\n      .filter(dirent => dirent.isDirectory())\n      .map(dirent => dirent.name);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get recent sessions for a user\n */\nexport function getRecentUserSessions(\n  userId: string,\n  limit: number = 10\n): SessionSummary[] {\n  const sessionIds = listSessionIds();\n  const summaries: SessionSummary[] = [];\n\n  for (const sessionId of sessionIds) {\n    const summary = generateSessionSummary(sessionId);\n    if (summary.user_id === userId) {\n      summaries.push(summary);\n    }\n    if (summaries.length >= limit * 2) break; // Stop early if we have enough candidates\n  }\n\n  // Sort by start_time descending and take limit\n  return summaries\n    .sort((a, b) => {\n      const timeA = a.start_time ? new Date(a.start_time).getTime() : 0;\n      const timeB = b.start_time ? new Date(b.start_time).getTime() : 0;\n      return timeB - timeA;\n    })\n    .slice(0, limit);\n}\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Truncate string to max length\n */\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - 3) + '...';\n}\n\n/**\n * Sanitize object for storage (remove sensitive data, truncate)\n */\nfunction sanitizeForStorage(\n  obj: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!obj) return undefined;\n\n  const sanitized: Record<string, unknown> = {};\n  const sensitiveKeys = ['password', 'secret', 'token', 'key', 'credential', 'auth'];\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip sensitive keys\n    if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {\n      sanitized[key] = '[REDACTED]';\n      continue;\n    }\n\n    // Truncate long strings\n    if (typeof value === 'string' && value.length > 500) {\n      sanitized[key] = truncate(value, 500);\n      continue;\n    }\n\n    // Recursively sanitize objects\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      sanitized[key] = sanitizeForStorage(value as Record<string, unknown>);\n      continue;\n    }\n\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n}\n", "/**\n * User Identity System\n * Resolves and manages user identity across sessions for multi-user decision capture.\n *\n * Identity Resolution Order:\n * 1. Explicit config (.claude/.user_identity.json)\n * 2. Git config (user.email, user.name)\n * 3. Environment variables (USER, USERNAME)\n * 4. Anonymous (machine-based hash)\n *\n * Privacy: User controls what gets shared via privacy settings.\n * Storage: User profiles stored locally in .claude/memory/users/\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport * as os from 'node:os';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * User identity source - where the identity was resolved from\n */\nexport type IdentitySource = 'config' | 'git' | 'env' | 'anonymous';\n\n/**\n * Resolved user identity\n */\nexport interface UserIdentity {\n  /** Unique user identifier (email, username, or anonymous hash) */\n  user_id: string;\n  /** Human-readable display name */\n  display_name: string;\n  /** Optional team/org identifier */\n  team_id?: string;\n  /** Machine identifier (hostname) */\n  machine_id: string;\n  /** How the identity was resolved */\n  source: IdentitySource;\n  /** Anonymous hash for global sharing (privacy-preserving) */\n  anonymous_id: string;\n  /** Email if available */\n  email?: string;\n}\n\n/**\n * User privacy settings - controls what gets shared\n */\nexport interface PrivacySettings {\n  /** Share patterns with team (same project) */\n  share_with_team: boolean;\n  /** Share patterns globally (anonymized) */\n  share_globally: boolean;\n  /** Share decisions */\n  share_decisions: boolean;\n  /** Share preferences */\n  share_preferences: boolean;\n  /** Share skill usage statistics */\n  share_skill_usage: boolean;\n  /** Share prompt content (usually false for privacy) */\n  share_prompts: boolean;\n  /** Anonymize user_id when sharing globally */\n  anonymize_globally: boolean;\n}\n\n/**\n * User identity configuration file format\n */\nexport interface UserIdentityConfig {\n  /** Explicit user ID */\n  user_id?: string;\n  /** Display name */\n  display_name?: string;\n  /** Team identifier */\n  team_id?: string;\n  /** Privacy settings */\n  privacy?: Partial<PrivacySettings>;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst IDENTITY_CONFIG_FILE = '.claude/.user_identity.json';\nconst SALT = 'orchestkit-user-identity-v1';\n\n/** Default privacy settings (conservative) */\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  share_with_team: true,\n  share_globally: false, // Opt-in\n  share_decisions: true,\n  share_preferences: true,\n  share_skill_usage: false, // Might reveal workflow\n  share_prompts: false, // Privacy sensitive\n  anonymize_globally: true,\n};\n\n// =============================================================================\n// CACHING\n// =============================================================================\n\nlet cachedIdentity: UserIdentity | null = null;\nlet cachedPrivacy: PrivacySettings | null = null;\n\n/**\n * Clear cached identity (for testing)\n */\nexport function clearIdentityCache(): void {\n  cachedIdentity = null;\n  cachedPrivacy = null;\n}\n\n// =============================================================================\n// IDENTITY RESOLUTION\n// =============================================================================\n\n/**\n * Generate anonymous hash from input\n */\nfunction generateAnonymousId(input: string): string {\n  return createHash('sha256')\n    .update(input + SALT)\n    .digest('hex')\n    .slice(0, 16);\n}\n\n/**\n * Get machine identifier\n */\nfunction getMachineId(): string {\n  try {\n    return os.hostname();\n  } catch {\n    return 'unknown-machine';\n  }\n}\n\n/**\n * Try to read explicit user config\n */\nfunction readUserConfig(projectDir: string): UserIdentityConfig | null {\n  const configPath = `${projectDir}/${IDENTITY_CONFIG_FILE}`;\n\n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    logHook('user-identity', `Failed to read user config: ${error}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Try to get identity from git config\n */\nfunction getGitIdentity(projectDir: string): { email?: string; name?: string } {\n  const result: { email?: string; name?: string } = {};\n\n  try {\n    result.email = execSync('git config user.email', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git email not configured\n  }\n\n  try {\n    result.name = execSync('git config user.name', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git name not configured\n  }\n\n  return result;\n}\n\n/**\n * Get identity from environment variables\n */\nfunction getEnvIdentity(): { username?: string } {\n  const username = process.env.USER || process.env.USERNAME || process.env.LOGNAME;\n  return { username };\n}\n\n/**\n * Resolve user identity using fallback chain\n *\n * Resolution order:\n * 1. Explicit config file\n * 2. Git config\n * 3. Environment username\n * 4. Anonymous (machine-based)\n */\nexport function resolveUserIdentity(projectDir?: string): UserIdentity {\n  // Return cached if available\n  if (cachedIdentity) {\n    return cachedIdentity;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const machineId = getMachineId();\n\n  // 1. Try explicit config\n  const config = readUserConfig(dir);\n  if (config?.user_id) {\n    cachedIdentity = {\n      user_id: config.user_id,\n      display_name: config.display_name || config.user_id,\n      team_id: config.team_id,\n      machine_id: machineId,\n      source: 'config',\n      anonymous_id: generateAnonymousId(config.user_id),\n      email: config.user_id.includes('@') ? config.user_id : undefined,\n    };\n    logHook('user-identity', `Resolved from config: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 2. Try git config\n  const git = getGitIdentity(dir);\n  if (git.email) {\n    cachedIdentity = {\n      user_id: git.email,\n      display_name: git.name || git.email.split('@')[0],\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'git',\n      anonymous_id: generateAnonymousId(git.email),\n      email: git.email,\n    };\n    logHook('user-identity', `Resolved from git: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 3. Try environment\n  const env = getEnvIdentity();\n  if (env.username) {\n    const userId = `${env.username}@${machineId}`;\n    cachedIdentity = {\n      user_id: userId,\n      display_name: env.username,\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'env',\n      anonymous_id: generateAnonymousId(userId),\n    };\n    logHook('user-identity', `Resolved from env: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 4. Anonymous fallback\n  const anonId = generateAnonymousId(machineId + process.pid);\n  cachedIdentity = {\n    user_id: `anon-${anonId.slice(0, 8)}`,\n    display_name: 'Anonymous',\n    team_id: config?.team_id,\n    machine_id: machineId,\n    source: 'anonymous',\n    anonymous_id: anonId,\n  };\n  logHook('user-identity', `Resolved as anonymous: ${cachedIdentity.user_id}`, 'debug');\n  return cachedIdentity;\n}\n\n// =============================================================================\n// PRIVACY SETTINGS\n// =============================================================================\n\n/**\n * Get user's privacy settings\n */\nexport function getPrivacySettings(projectDir?: string): PrivacySettings {\n  if (cachedPrivacy) {\n    return cachedPrivacy;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const config = readUserConfig(dir);\n\n  cachedPrivacy = {\n    ...DEFAULT_PRIVACY,\n    ...config?.privacy,\n  };\n\n  return cachedPrivacy;\n}\n\n/**\n * Check if user allows sharing a specific type of data\n */\nexport function canShare(\n  dataType: 'decisions' | 'preferences' | 'skill_usage' | 'prompts',\n  scope: 'team' | 'global'\n): boolean {\n  const privacy = getPrivacySettings();\n\n  // Check scope permission first\n  if (scope === 'team' && !privacy.share_with_team) return false;\n  if (scope === 'global' && !privacy.share_globally) return false;\n\n  // Check data type permission\n  switch (dataType) {\n    case 'decisions':\n      return privacy.share_decisions;\n    case 'preferences':\n      return privacy.share_preferences;\n    case 'skill_usage':\n      return privacy.share_skill_usage;\n    case 'prompts':\n      return privacy.share_prompts;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get user ID for sharing (applies anonymization if needed)\n */\nexport function getUserIdForScope(scope: 'local' | 'team' | 'global'): string {\n  const identity = resolveUserIdentity();\n  const privacy = getPrivacySettings();\n\n  if (scope === 'global' && privacy.anonymize_globally) {\n    return identity.anonymous_id;\n  }\n\n  return identity.user_id;\n}\n\n// =============================================================================\n// IDENTITY PERSISTENCE\n// =============================================================================\n\n/**\n * Save user identity config (creates or updates)\n */\nexport function saveUserIdentityConfig(\n  config: UserIdentityConfig,\n  projectDir?: string\n): boolean {\n  const dir = projectDir || getProjectDir();\n  const configPath = `${dir}/${IDENTITY_CONFIG_FILE}`;\n  const configDir = `${dir}/.claude`;\n\n  try {\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n    // Clear cache to pick up new config\n    clearIdentityCache();\n\n    logHook('user-identity', `Saved identity config to ${configPath}`, 'info');\n    return true;\n  } catch (error) {\n    logHook('user-identity', `Failed to save identity config: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// CONTEXT HELPERS\n// =============================================================================\n\n/**\n * Get full identity context for session events\n */\nexport interface IdentityContext {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  machine_id: string;\n  identity_source: IdentitySource;\n  timestamp: string;\n}\n\n/**\n * Get identity context for tagging events\n */\nexport function getIdentityContext(): IdentityContext {\n  const identity = resolveUserIdentity();\n\n  return {\n    session_id: getSessionId(),\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    machine_id: identity.machine_id,\n    identity_source: identity.source,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Get project-scoped user ID for mem0 storage\n * Format: {project}-{scope} (e.g., \"my-app-decisions\")\n */\nexport function getProjectUserId(scope: string): string {\n  const projectDir = getProjectDir();\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  const sanitized = projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  return `${sanitized}-${scope}`;\n}\n\n/**\n * Get user-scoped ID for mem0 storage\n * Format: {user_id}-{scope} (e.g., \"alice@company.com-preferences\")\n */\nexport function getUserScopedId(scope: string): string {\n  const identity = resolveUserIdentity();\n  const sanitizedUserId = identity.user_id.toLowerCase().replace(/[^a-z0-9@.-]/g, '-');\n  return `${sanitizedUserId}-${scope}`;\n}\n\n/**\n * Get global scope ID (for cross-project best practices)\n */\nexport function getGlobalScopeId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n", "/**\n * Satisfaction Detector - UserPromptSubmit Hook\n * Detects user satisfaction signals from conversation patterns\n * CC 2.1.7 Compliant\n *\n * Strategy:\n * - Analyze user prompt for positive/negative signals\n * - Track satisfaction per session\n * - Log to feedback system for reporting\n *\n * Performance optimization:\n * - Sampling mode: only analyzes every Nth prompt to reduce overhead\n * - Configure via SATISFACTION_SAMPLE_RATE (default: 3)\n *\n * Part of Feedback System (#57)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\nimport { trackEvent } from '../lib/session-tracker.js';\nimport { existsSync, readFileSync, writeFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// Configuration\nconst MIN_PROMPT_LENGTH = 2;\n\n// Positive signal patterns\nconst POSITIVE_PATTERNS = [\n  /\\bthank/i,\n  /\\bgreat\\b/i,\n  /\\bperfect\\b/i,\n  /\\bexcellent\\b/i,\n  /\\bawesome\\b/i,\n  /\\bworks?\\b.*\\b(well|great|perfectly)/i,\n  /\\bthat('s| is) (exactly|just) what/i,\n  /\\bnice\\b/i,\n  /\\bgood job\\b/i,\n  /\\bwell done\\b/i,\n  /\\blooks? good\\b/i,\n  /\\blgtm\\b/i,\n  /\\bship it\\b/i,\n];\n\n// Negative signal patterns\nconst NEGATIVE_PATTERNS = [\n  /\\bno(t| ).*right/i,\n  /\\bwrong\\b/i,\n  /\\bdoesn't work/i,\n  /\\bbroken\\b/i,\n  /\\bfailed\\b/i,\n  /\\btry again\\b/i,\n  /\\bstart over\\b/i,\n  /\\bundo\\b/i,\n  /\\brevert\\b/i,\n  /\\bfrustrat/i,\n  /\\bannoy/i,\n  /\\bconfus/i,\n  /\\bstill (not|doesn't)/i,\n  /\\bdidn't (work|help)/i,\n  /\\bthat's not/i,\n];\n\n/**\n * Detect satisfaction from prompt\n */\nfunction detectSatisfaction(prompt: string): 'positive' | 'negative' | 'neutral' {\n  // Check positive patterns\n  for (const pattern of POSITIVE_PATTERNS) {\n    if (pattern.test(prompt)) {\n      return 'positive';\n    }\n  }\n\n  // Check negative patterns\n  for (const pattern of NEGATIVE_PATTERNS) {\n    if (pattern.test(prompt)) {\n      return 'negative';\n    }\n  }\n\n  return 'neutral';\n}\n\n/**\n * Get counter file path\n */\nfunction getCounterFilePath(projectDir: string): string {\n  return join(projectDir, '.claude', '.satisfaction-counter');\n}\n\n/**\n * Get or increment counter for sampling\n */\nfunction getAndIncrementCounter(projectDir: string): number {\n  const counterFile = getCounterFilePath(projectDir);\n\n  // Ensure directory exists\n  const dir = dirname(counterFile);\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n\n  let counter = 0;\n  if (existsSync(counterFile)) {\n    try {\n      counter = parseInt(readFileSync(counterFile, 'utf8').trim(), 10) || 0;\n    } catch {\n      // Ignore\n    }\n  }\n\n  counter++;\n\n  try {\n    writeFileSync(counterFile, String(counter));\n  } catch {\n    // Ignore\n  }\n\n  return counter;\n}\n\n/**\n * Log satisfaction signal to feedback file\n */\nfunction logSatisfaction(sessionId: string, sentiment: string, context: string, projectDir: string): void {\n  const feedbackDir = join(projectDir, '.claude', 'feedback');\n  const logFile = join(feedbackDir, 'satisfaction.log');\n\n  // Ensure directory exists\n  if (!existsSync(feedbackDir)) {\n    try {\n      mkdirSync(feedbackDir, { recursive: true });\n    } catch {\n      return;\n    }\n  }\n\n  const timestamp = new Date().toISOString();\n  const logEntry = `${timestamp} | ${sessionId} | ${sentiment} | ${context}\\n`;\n\n  try {\n    appendFileSync(logFile, logEntry);\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n/**\n * Satisfaction detector hook\n */\nexport function satisfactionDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionId = input.session_id || getSessionId();\n\n  // Get sample rate from environment (default: 3)\n  const sampleRate = parseInt(process.env.SATISFACTION_SAMPLE_RATE || '3', 10);\n\n  // Get and increment counter for sampling\n  const counter = getAndIncrementCounter(projectDir);\n\n  // Skip if not on sampling interval (for performance)\n  if (sampleRate > 1 && counter % sampleRate !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('satisfaction-detector', `Satisfaction detector hook starting (sample ${counter})`);\n\n  // Skip empty prompts\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  // Skip very short prompts (likely commands)\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Skip prompts that look like commands (start with /)\n  if (prompt.startsWith('/')) {\n    return outputSilentSuccess();\n  }\n\n  // Detect satisfaction\n  const sentiment = detectSatisfaction(prompt);\n\n  // Only log non-neutral signals to avoid noise\n  if (sentiment !== 'neutral') {\n    // Truncate context for logging\n    let context = prompt.slice(0, 50);\n    if (prompt.length > 50) {\n      context += '...';\n    }\n\n    // Log the satisfaction signal\n    logSatisfaction(sessionId, sentiment, context, projectDir);\n\n    // Track in session tracker for user profile aggregation\n    try {\n      trackEvent('preference_stated' as any, sentiment, {\n        context,\n        success: true,\n      });\n    } catch {\n      // Ignore tracking errors\n    }\n\n    logHook('satisfaction-detector', `Detected ${sentiment} satisfaction signal`);\n  }\n\n  // Output CC 2.1.7 compliant JSON (silent success)\n  return outputSilentSuccess();\n}\n", "/**\n * Todo Enforcer - UserPromptSubmit Hook\n * Reminds about todo tracking for complex tasks\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\n// Complex task indicators (regex patterns)\nconst COMPLEX_PATTERNS = [\n  /implement/i,\n  /refactor/i,\n  /add feature/i,\n  /create.*component/i,\n  /build.*system/i,\n  /fix.*multiple/i,\n  /update.*across/i,\n  /migrate/i,\n];\n\n// Threshold for long prompts (often indicate complex tasks)\nconst LONG_PROMPT_THRESHOLD = 500;\n\n/**\n * Todo enforcer hook - detects complex tasks\n */\nexport function todoEnforcer(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const promptLength = prompt.length;\n\n  logHook('todo-enforcer', `Prompt length: ${promptLength} chars`);\n\n  let isComplex = false;\n\n  // Check for complex task patterns\n  for (const pattern of COMPLEX_PATTERNS) {\n    if (pattern.test(prompt)) {\n      isComplex = true;\n      break;\n    }\n  }\n\n  // Long prompts often indicate complex tasks\n  if (promptLength > LONG_PROMPT_THRESHOLD) {\n    isComplex = true;\n  }\n\n  if (isComplex) {\n    logHook('todo-enforcer', 'Complex task detected - todo tracking recommended');\n  }\n\n  // Output systemMessage for user visibility\n  // Currently outputs silent success - could be enhanced to inject context\n  return outputSilentSuccess();\n}\n", "/**\n * Agent Auto-Suggest - UserPromptSubmit Hook\n * Proactive agent dispatch suggestion based on prompt analysis\n * Issue #197: Agent Orchestration Layer\n *\n * NOW USES: Intent Classifier for hybrid semantic+keyword scoring\n * Target: 85%+ accuracy vs ~60% regex baseline\n *\n * This is the LEGACY hook maintained for backward compatibility.\n * The new agent-orchestrator.ts provides full orchestration with\n * task integration. This hook provides simple suggestions only.\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport { getAdjustments } from '../lib/calibration-engine.js';\nimport { getPromptHistory, loadConfig } from '../lib/orchestration-state.js';\nimport type { AgentMatch } from '../lib/orchestration-types.js';\nimport { THRESHOLDS } from '../lib/orchestration-types.js';\n\n// Maximum number of agents to suggest\nconst MAX_SUGGESTIONS = 2;\n\n/**\n * Build suggestion message based on confidence level\n * (Backward compatible message format)\n */\nfunction buildSuggestionMessage(matches: AgentMatch[]): string {\n  if (matches.length === 0) return '';\n\n  const topMatch = matches[0];\n  let message = '';\n\n  if (topMatch.confidence >= THRESHOLDS.AUTO_DISPATCH) {\n    // HIGH CONFIDENCE - Strong directive\n    message = `## \uD83C\uDFAF AGENT DISPATCH RECOMMENDED\n\n**Agent:** \\`${topMatch.agent}\\` (${topMatch.confidence}% confidence)\n\nThis task strongly matches the agent's specialization. **Spawn this agent:**\n\n\\`\\`\\`\nTask tool with subagent_type: \"${topMatch.agent}\"\n\\`\\`\\`\n\nMatched: ${topMatch.matchedKeywords.slice(0, 5).join(', ')}`;\n\n  } else if (topMatch.confidence >= THRESHOLDS.STRONG_RECOMMEND) {\n    // MEDIUM-HIGH - Recommendation\n    message = `## Agent Recommendation\n\n**RECOMMENDED:** \\`${topMatch.agent}\\` (${topMatch.confidence}% match)\n${topMatch.description}\n\nMatched keywords: ${topMatch.matchedKeywords.slice(0, 4).join(', ')}\n\nConsider spawning with: \\`Task tool, subagent_type: \"${topMatch.agent}\"\\``;\n\n  } else if (topMatch.confidence >= THRESHOLDS.SUGGEST) {\n    // MEDIUM - Suggestion\n    message = `## Agent Suggestion\n\n**Consider:** \\`${topMatch.agent}\\` (${topMatch.confidence}% match)\n\nThis agent specializes in: ${topMatch.matchedKeywords.slice(0, 3).join(', ')}`;\n  }\n\n  // Add second match if exists and significant\n  if (matches.length > 1 && matches[1].confidence >= THRESHOLDS.SUGGEST) {\n    const second = matches[1];\n    message += `\\n\\n**Alternative:** \\`${second.agent}\\` (${second.confidence}% match)`;\n  }\n\n  return message;\n}\n\n/**\n * Agent auto-suggest hook\n *\n * Uses the new intent classifier for improved accuracy:\n * - Hybrid keyword + phrase + context scoring\n * - Calibration adjustments from outcome learning\n * - Negation detection to reduce false positives\n */\nexport function agentAutoSuggest(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filter using classifier's shouldClassify\n  if (!shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  // Skip if agent-orchestrator is enabled (let it handle classification)\n  const config = loadConfig();\n  if (config.enableAutoDispatch) {\n    // agent-orchestrator.ts will handle this\n    logHook('agent-auto-suggest', 'Deferring to agent-orchestrator (auto-dispatch enabled)');\n    return outputSilentSuccess();\n  }\n\n  logHook('agent-auto-suggest', 'Analyzing prompt with intent classifier...');\n\n  // Get context for classification\n  const history = getPromptHistory();\n  const adjustments = getAdjustments();\n\n  // Run classification\n  const result = classifyIntent(prompt, history, adjustments);\n\n  // Filter to top suggestions\n  const matches = result.agents.slice(0, MAX_SUGGESTIONS);\n\n  if (matches.length === 0) {\n    logHook('agent-auto-suggest', 'No agent matches found');\n    return outputSilentSuccess();\n  }\n\n  logHook(\n    'agent-auto-suggest',\n    `Found matches: ${matches.map(m => `${m.agent}:${m.confidence}`).join(', ')}`\n  );\n\n  // Build suggestion message (backward compatible format)\n  const suggestionMessage = buildSuggestionMessage(matches);\n\n  if (suggestionMessage) {\n    logHook('agent-auto-suggest', `Suggesting ${matches[0].agent} at ${matches[0].confidence}%`);\n    return outputPromptContext(suggestionMessage);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Agent Orchestrator - Main UserPromptSubmit Hook for Auto-Dispatch\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * At confidence >= 85%: AUTO-DISPATCH directive\n * At confidence 70-84%: Strong recommendation\n * At confidence 50-69%: Suggestion\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n * CC 2.1.16 Compliant: Outputs TaskCreate instructions for task management\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport {\n  loadConfig,\n  addToPromptHistory,\n  cacheClassification,\n  isAgentDispatched,\n  trackDispatchedAgent,\n  getPromptHistory,\n} from '../lib/orchestration-state.js';\nimport type {\n  ClassificationResult,\n  AgentMatch,\n  TaskMetadata,\n} from '../lib/orchestration-types.js';\nimport { THRESHOLDS } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Message Builders\n// -----------------------------------------------------------------------------\n\n/**\n * Build auto-dispatch directive message (conf >= 85%)\n */\nfunction buildAutoDispatchMessage(match: AgentMatch, taskMeta: TaskMetadata): string {\n  return `## \uD83C\uDFAF AUTO-DISPATCH: ${match.agent}\n\n**Confidence:** ${match.confidence}% (auto-dispatch threshold: ${THRESHOLDS.AUTO_DISPATCH}%)\n\nThis task strongly matches the agent's specialization. **IMMEDIATELY spawn this agent:**\n\n\\`\\`\\`\nTask tool with subagent_type: \"${match.agent}\"\n\\`\\`\\`\n\n**Matched Keywords:** ${match.matchedKeywords.slice(0, 5).join(', ')}\n\n### CC 2.1.16 Task Instruction\nBefore spawning, create a task to track this work:\n\n\\`\\`\\`json\nTaskCreate:\n{\n  \"subject\": \"${match.agent.replace(/-/g, ' ')} implementation\",\n  \"description\": \"Agent dispatched automatically at ${match.confidence}% confidence\",\n  \"activeForm\": \"Working on ${match.description.toLowerCase()}\",\n  \"metadata\": ${JSON.stringify(taskMeta)}\n}\n\\`\\`\\`\n\nAfter creating the task, spawn the agent with the task ID in the prompt.`;\n}\n\n/**\n * Build strong recommendation message (conf 70-84%)\n */\nfunction buildStrongRecommendMessage(match: AgentMatch): string {\n  return `## Agent Recommendation\n\n**RECOMMENDED:** \\`${match.agent}\\` (${match.confidence}% confidence)\n\n${match.description}\n\n**Matched:** ${match.matchedKeywords.slice(0, 4).join(', ')}\n\n**Spawn with:**\n\\`\\`\\`\nTask tool with subagent_type: \"${match.agent}\"\n\\`\\`\\``;\n}\n\n/**\n * Build suggestion message (conf 50-69%)\n */\nfunction buildSuggestionMessage(match: AgentMatch): string {\n  return `## Agent Suggestion\n\n**Consider:** \\`${match.agent}\\` (${match.confidence}% match)\n\nThis agent specializes in: ${match.matchedKeywords.slice(0, 3).join(', ')}`;\n}\n\n/**\n * Build alternative agent note\n */\nfunction buildAlternativeNote(match: AgentMatch): string {\n  return `\\n\\n**Alternative:** \\`${match.agent}\\` (${match.confidence}% match)`;\n}\n\n/**\n * Build the complete orchestration message\n */\nfunction buildOrchestrationMessage(\n  result: ClassificationResult,\n  config: ReturnType<typeof loadConfig>\n): string {\n  if (result.agents.length === 0) {\n    return '';\n  }\n\n  const topMatch = result.agents[0];\n  let message = '';\n\n  // Check if already dispatched\n  if (isAgentDispatched(topMatch.agent)) {\n    logHook('agent-orchestrator', `Agent ${topMatch.agent} already dispatched, skipping`);\n    return '';\n  }\n\n  // Auto-dispatch at high confidence\n  if (\n    config.enableAutoDispatch &&\n    topMatch.confidence >= THRESHOLDS.AUTO_DISPATCH\n  ) {\n    const taskMeta: TaskMetadata = {\n      source: 'orchestration',\n      dispatchedAgent: topMatch.agent,\n      dispatchConfidence: topMatch.confidence,\n      relatedSkills: result.skills.slice(0, 3).map(s => s.skill),\n      dispatchSignals: topMatch.signals.slice(0, 5),\n    };\n\n    // Track the dispatch\n    trackDispatchedAgent(topMatch.agent, topMatch.confidence);\n\n    message = buildAutoDispatchMessage(topMatch, taskMeta);\n\n  } else if (topMatch.confidence >= THRESHOLDS.STRONG_RECOMMEND) {\n    // Strong recommendation\n    message = buildStrongRecommendMessage(topMatch);\n\n  } else if (topMatch.confidence >= THRESHOLDS.SUGGEST) {\n    // Suggestion\n    message = buildSuggestionMessage(topMatch);\n  }\n\n  // Add alternative if significant\n  if (\n    result.agents.length > 1 &&\n    result.agents[1].confidence >= THRESHOLDS.SUGGEST\n  ) {\n    message += buildAlternativeNote(result.agents[1]);\n  }\n\n  return message;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Agent orchestrator hook - main entry point\n *\n * Analyzes user prompts and either:\n * 1. Auto-dispatches agents at 85%+ confidence\n * 2. Strongly recommends agents at 70-84%\n * 3. Suggests agents at 50-69%\n *\n * Also integrates with CC 2.1.16 task management.\n */\nexport function agentOrchestrator(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filter\n  if (!shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('agent-orchestrator', 'Classifying intent for orchestration...');\n\n  // Load config and state\n  const config = loadConfig();\n  const history = getPromptHistory();\n\n  // Run classification\n  const result = classifyIntent(prompt, history);\n\n  // Cache classification for later use\n  cacheClassification(result);\n\n  // Add to prompt history\n  addToPromptHistory(prompt.slice(0, 500)); // Truncate for storage\n\n  // Log classification\n  logHook(\n    'agent-orchestrator',\n    `Classification: intent=${result.intent}, ` +\n    `agents=[${result.agents.map(a => `${a.agent}:${a.confidence}`).join(', ')}], ` +\n    `autoDispatch=${result.shouldAutoDispatch}`\n  );\n\n  // No matches\n  if (result.agents.length === 0) {\n    logHook('agent-orchestrator', 'No agent matches found');\n    return outputSilentSuccess();\n  }\n\n  // Build orchestration message\n  const message = buildOrchestrationMessage(result, config);\n\n  if (message) {\n    return outputPromptContext(message);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Pipeline Detector - UserPromptSubmit Hook for Multi-Agent Workflows\n * Issue #197: Agent Orchestration Layer\n *\n * Detects multi-agent pipeline triggers in prompts:\n * - Product thinking: \"should we build...\"\n * - Full-stack feature: \"build a full-stack feature...\"\n * - AI integration: \"add RAG/LLM...\"\n * - Security audit: \"security audit...\"\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport { loadConfig } from '../lib/orchestration-state.js';\nimport {\n  detectPipeline,\n  createPipelineExecution,\n  registerPipelineExecution,\n  formatPipelinePlan,\n} from '../lib/multi-agent-coordinator.js';\nimport { getActivePipeline } from '../lib/task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Minimum prompt length to consider for pipeline detection */\nconst MIN_PROMPT_LENGTH = 15;\n\n/** Words that indicate this is NOT a pipeline request */\nconst EXCLUSION_WORDS = [\n  'what is',\n  'explain',\n  'how does',\n  'tell me about',\n  'describe',\n  'list',\n  'show me',\n];\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Check if prompt is asking a question rather than requesting action\n */\nfunction isQuestionNotRequest(prompt: string): boolean {\n  const promptLower = prompt.toLowerCase();\n\n  for (const exclusion of EXCLUSION_WORDS) {\n    if (promptLower.startsWith(exclusion)) {\n      return true;\n    }\n  }\n\n  // Ends with question mark and is short\n  if (prompt.endsWith('?') && prompt.length < 100) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Check if user is already in a pipeline\n */\nfunction isInActivePipeline(): boolean {\n  const active = getActivePipeline();\n  return active !== undefined && active.status === 'running';\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Pipeline detector hook\n *\n * Detects multi-agent workflow patterns:\n * 1. Checks if prompt matches pipeline triggers\n * 2. Creates pipeline execution plan\n * 3. Outputs task creation instructions\n */\nexport function pipelineDetector(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  // Quick filters\n  if (prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  if (isQuestionNotRequest(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  // Check config\n  const config = loadConfig();\n  if (!config.enablePipelines) {\n    return outputSilentSuccess();\n  }\n\n  // Check if already in pipeline\n  if (isInActivePipeline()) {\n    logHook('pipeline-detector', 'Already in active pipeline, skipping detection');\n    return outputSilentSuccess();\n  }\n\n  logHook('pipeline-detector', 'Checking for pipeline triggers...');\n\n  // Detect pipeline\n  const pipeline = detectPipeline(prompt);\n\n  if (!pipeline) {\n    logHook('pipeline-detector', 'No pipeline triggers detected');\n    return outputSilentSuccess();\n  }\n\n  logHook('pipeline-detector', `Detected pipeline: ${pipeline.type}`);\n\n  // Create pipeline execution\n  const { execution, tasks } = createPipelineExecution(pipeline);\n\n  // Register with tracking systems\n  registerPipelineExecution(execution, tasks);\n\n  // Format plan message\n  const message = formatPipelinePlan(pipeline, execution, tasks);\n\n  logHook(\n    'pipeline-detector',\n    `Created pipeline ${execution.pipelineId} with ${tasks.length} steps`\n  );\n\n  return outputPromptContext(message);\n}\n", "/**\n * Skill Resolver - Unified UserPromptSubmit Hook\n * Merges skill-auto-suggest + skill-injector into a single hook.\n *\n * Runs classifyIntent() once and applies tiered response:\n * - confidence >= 80%: inject full (compressed) skill content\n * - confidence 50-79%: output lightweight suggestion list\n * - confidence < 50%: silent success\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getPluginRoot, estimateTokenCount } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport {\n  loadConfig,\n  isSkillInjected,\n  trackInjectedSkill,\n  getLastClassification,\n} from '../lib/orchestration-state.js';\nimport { classifyIntent, shouldClassify } from '../lib/intent-classifier.js';\nimport type { ClassificationResult, SkillMatch } from '../lib/orchestration-types.js';\nimport { findMatchingSkills as findKeywordSkills } from './skill-auto-suggest.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum tokens for full skill content injection */\nconst MAX_INJECTION_TOKENS = 800;\n\n/** Maximum skills to inject per prompt (full tier) */\nconst MAX_FULL_INJECT = 2;\n\n/** Maximum skills to suggest (hint/summary tier) */\nconst MAX_SUGGESTIONS = 3;\n\n/** Confidence tiers */\nconst TIER_FULL = 80;\nconst TIER_SUMMARY = 70;\nconst TIER_HINT = 50;\n\n// -----------------------------------------------------------------------------\n// Skill Content Loading & Compression\n// -----------------------------------------------------------------------------\n\n/**\n * Load and compress skill content from SKILL.md.\n * Strips: frontmatter, ## References sections, excessive blanks,\n * and truncates code blocks >10 lines.\n */\nfunction loadCompressedSkillContent(skillName: string, maxTokens: number): string | null {\n  const pluginRoot = getPluginRoot();\n  const skillFile = join(pluginRoot, 'skills', skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) {\n    logHook('skill-resolver', 'Skill file not found: ' + skillFile);\n    return null;\n  }\n\n  try {\n    let content = readFileSync(skillFile, 'utf8');\n\n    // Remove frontmatter\n    const frontmatterMatch = content.match(/^---\\n[\\s\\S]*?\\n---\\n/);\n    if (frontmatterMatch) {\n      content = content.slice(frontmatterMatch[0].length);\n    }\n\n    // Strip ## References sections (just file links)\n    content = content.replace(/^## References[\\s\\S]*?(?=^## |\\Z)/gm, '');\n\n    // Truncate code blocks >10 lines to 5 lines + notice\n    content = content.replace(/```[\\s\\S]*?```/g, (block) => {\n      const lines = block.split('\\n');\n      if (lines.length > 12) {\n        const truncated = lines.slice(0, 7).join('\\n');\n        return truncated + '\\n# ... truncated\\n```';\n      }\n      return block;\n    });\n\n    // Collapse excessive blank lines\n    content = content.replace(/\\n{3,}/g, '\\n\\n');\n    content = content.trim();\n\n    // Truncate to token budget\n    const maxChars = Math.floor(maxTokens * 3.5);\n    if (content.length > maxChars) {\n      const truncated = content.slice(0, maxChars);\n      const lastParagraph = truncated.lastIndexOf('\\n\\n');\n      if (lastParagraph > maxChars * 0.6) {\n        content = truncated.slice(0, lastParagraph) + '\\n\\n[... truncated for context budget]';\n      } else {\n        content = truncated + '\\n\\n[... truncated for context budget]';\n      }\n    }\n\n    return content;\n  } catch (err) {\n    logHook('skill-resolver', 'Failed to load skill: ' + String(err));\n    return null;\n  }\n}\n\n/**\n * Get skill description from SKILL.md frontmatter\n */\nfunction getSkillDescription(skillName: string): string {\n  const pluginRoot = getPluginRoot();\n  const skillFile = join(pluginRoot, 'skills', skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) return '';\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (frontmatterMatch) {\n      const descMatch = frontmatterMatch[1].match(/^description:\\s*(.+)$/m);\n      if (descMatch) return descMatch[1].trim();\n    }\n  } catch {\n    // Ignore\n  }\n  return '';\n}\n\n/**\n * Extract 3 key bullet points from skill content for summary tier\n */\nfunction extractKeyBullets(skillName: string): string[] {\n  const pluginRoot = getPluginRoot();\n  const skillFile = join(pluginRoot, 'skills', skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) return [];\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n    const bullets: string[] = [];\n    const headings = content.match(/^## .+$/gm) || [];\n    for (const h of headings.slice(0, 3)) {\n      const text = h.replace(/^## /, '').trim();\n      if (text && text !== 'References' && text.length < 80) {\n        bullets.push(text);\n      }\n    }\n    return bullets.slice(0, 3);\n  } catch {\n    return [];\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Message Building\n// -----------------------------------------------------------------------------\n\nfunction buildHintMessage(skills: SimpleSkillMatch[]): string {\n  if (skills.length === 0) return '';\n  const lines = skills.map(s => '- **' + s.skill + '** \\u2014 Use `/ork:' + s.skill + '` to load');\n  return '## Skill Hints\\n\\n' + lines.join('\\n');\n}\n\nfunction buildSummaryMessage(skills: SimpleSkillMatch[]): string {\n  if (skills.length === 0) return '';\n  let message = '## Relevant Skills\\n\\n';\n  for (const { skill, confidence } of skills) {\n    const desc = getSkillDescription(skill);\n    const bullets = extractKeyBullets(skill);\n    message += '### ' + skill + ' (' + confidence + '% match)\\n';\n    if (desc) message += desc + '\\n';\n    if (bullets.length > 0) {\n      message += bullets.map(b => '- ' + b).join('\\n') + '\\n';\n    }\n    message += 'Use `/ork:' + skill + '` to load full content.\\n\\n';\n  }\n  return message.trim();\n}\n\nfunction buildFullInjectionMessage(skills: Array<{ skill: string; content: string }>): string {\n  if (skills.length === 0) return '';\n  let message = '## Skill Knowledge Injected\\n\\nAuto-loaded based on your prompt:\\n\\n';\n  for (const { skill, content } of skills) {\n    message += '### ' + skill + '\\n\\n' + content + '\\n\\n---\\n\\n';\n  }\n  return message.trim();\n}\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ninterface SimpleSkillMatch {\n  skill: string;\n  confidence: number;\n}\n\n// -----------------------------------------------------------------------------\n// Unified Resolver\n// -----------------------------------------------------------------------------\n\n/**\n * Skill resolver hook - unified replacement for skill-auto-suggest + skill-injector.\n */\nexport function skillResolver(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n\n  if (!prompt || !shouldClassify(prompt)) {\n    return outputSilentSuccess();\n  }\n\n  const config = loadConfig();\n  logHook('skill-resolver', 'Analyzing prompt for skill resolution...');\n\n  // Single classification pass (reuse cached if available)\n  let result: ClassificationResult | undefined = getLastClassification();\n  if (!result) {\n    result = classifyIntent(prompt);\n  }\n\n  // Also check keyword-based matches for broader coverage\n  const keywordMatches = findKeywordSkills(prompt);\n\n  // Merge: prefer intent classifier results, supplement with keyword matches\n  const allSkills = mergeSkillMatches(result.skills, keywordMatches);\n\n  if (allSkills.length === 0) {\n    logHook('skill-resolver', 'No skill matches found');\n    return outputSilentSuccess();\n  }\n\n  logHook('skill-resolver',\n    'Found ' + allSkills.length + ' skills: ' + allSkills.map(s => s.skill + ':' + s.confidence).join(', '));\n\n  // Partition into tiers\n  const fullTier = allSkills.filter(s => s.confidence >= TIER_FULL);\n  const summaryTier = allSkills.filter(s => s.confidence >= TIER_SUMMARY && s.confidence < TIER_FULL);\n  const hintTier = allSkills.filter(s => s.confidence >= TIER_HINT && s.confidence < TIER_SUMMARY);\n\n  const parts: string[] = [];\n\n  // Full tier: inject compressed content (if injection enabled)\n  if (fullTier.length > 0 && config.enableSkillInjection) {\n    const maxTotalTokens = config.maxSkillInjectionTokens || MAX_INJECTION_TOKENS;\n    const skillCount = Math.min(fullTier.length, MAX_FULL_INJECT);\n    const tokensPerSkill = Math.floor(maxTotalTokens / skillCount);\n\n    const loadedSkills: Array<{ skill: string; content: string }> = [];\n    let totalTokens = 0;\n\n    for (const match of fullTier.slice(0, MAX_FULL_INJECT)) {\n      if (isSkillInjected(match.skill)) continue;\n\n      const remainingTokens = maxTotalTokens - totalTokens;\n      if (remainingTokens < 100) break;\n\n      const content = loadCompressedSkillContent(\n        match.skill,\n        Math.min(tokensPerSkill, remainingTokens)\n      );\n\n      if (content) {\n        const tokens = estimateTokenCount(content);\n        totalTokens += tokens;\n        loadedSkills.push({ skill: match.skill, content });\n        trackInjectedSkill(match.skill);\n        logHook('skill-resolver', 'Full inject: ' + match.skill + ' (~' + tokens + 't)');\n      }\n    }\n\n    if (loadedSkills.length > 0) {\n      parts.push(buildFullInjectionMessage(loadedSkills));\n    }\n  }\n\n  // Summary tier\n  if (summaryTier.length > 0) {\n    const summarySkills = summaryTier.slice(0, MAX_SUGGESTIONS);\n    parts.push(buildSummaryMessage(summarySkills));\n    logHook('skill-resolver', 'Summary: ' + summarySkills.map(s => s.skill).join(', '));\n  }\n\n  // Hint tier\n  if (hintTier.length > 0) {\n    const hintSkills = hintTier.slice(0, MAX_SUGGESTIONS);\n    parts.push(buildHintMessage(hintSkills));\n    logHook('skill-resolver', 'Hints: ' + hintSkills.map(s => s.skill).join(', '));\n  }\n\n  if (parts.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  const message = parts.join('\\n\\n');\n  logHook('skill-resolver', 'Outputting ' + parts.length + ' tiers (~' + estimateTokenCount(message) + 't)');\n\n  return outputPromptContext(message);\n}\n\n// -----------------------------------------------------------------------------\n// Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Merge intent-classifier skill matches with keyword-based matches.\n * Deduplicates by skill name, keeping highest confidence.\n */\nfunction mergeSkillMatches(\n  classifierMatches: SkillMatch[],\n  keywordMatches: SimpleSkillMatch[]\n): SimpleSkillMatch[] {\n  const map = new Map<string, number>();\n\n  for (const m of classifierMatches) {\n    const current = map.get(m.skill) || 0;\n    if (m.confidence > current) map.set(m.skill, m.confidence);\n  }\n\n  for (const m of keywordMatches) {\n    const current = map.get(m.skill) || 0;\n    if (m.confidence > current) map.set(m.skill, m.confidence);\n  }\n\n  return Array.from(map.entries())\n    .map(([skill, confidence]) => ({ skill, confidence }))\n    .sort((a, b) => b.confidence - a.confidence);\n}\n", "/**\n * Skill Auto-Suggest - UserPromptSubmit Hook\n * Proactive skill suggestion based on prompt analysis\n * Issue #123: Skill Auto-Suggest Hook\n *\n * Analyzes user prompts for task keywords and suggests relevant skills\n * from the skills/ directory via CC 2.1.9 additionalContext injection.\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for suggestions\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook, getPluginRoot } from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n// Maximum number of skills to suggest\nconst MAX_SUGGESTIONS = 3;\n\n// Minimum confidence score (0-100) to include a skill\nconst MIN_CONFIDENCE = 30;\n\n// Keyword-to-Skill mapping\n// Format: [keyword, skillName, confidenceBoost]\nconst KEYWORD_MAPPINGS: Array<[string, string, number]> = [\n  // API & Backend\n  ['api', 'api-design-framework', 80],\n  ['endpoint', 'api-design-framework', 70],\n  ['rest', 'api-design-framework', 75],\n  ['graphql', 'api-design-framework', 75],\n  ['route', 'api-design-framework', 60],\n  ['fastapi', 'fastapi-advanced', 90],\n  ['uvicorn', 'fastapi-advanced', 70],\n  ['starlette', 'fastapi-advanced', 60],\n  ['middleware', 'fastapi-advanced', 50],\n  ['pydantic', 'fastapi-advanced', 60],\n\n  // Database\n  ['database', 'database-schema-designer', 80],\n  ['schema', 'database-schema-designer', 70],\n  ['table', 'database-schema-designer', 50],\n  ['migration', 'alembic-migrations', 85],\n  ['alembic', 'alembic-migrations', 95],\n  ['sql', 'database-schema-designer', 60],\n  ['postgres', 'database-schema-designer', 70],\n  ['query', 'database-schema-designer', 40],\n  ['index', 'database-schema-designer', 50],\n  ['sqlalchemy', 'sqlalchemy-2-async', 85],\n  ['async.*database', 'sqlalchemy-2-async', 80],\n  ['orm', 'sqlalchemy-2-async', 60],\n  ['connection.*pool', 'connection-pooling', 90],\n  ['pool', 'connection-pooling', 60],\n  ['pgvector', 'pgvector-search', 95],\n  ['vector.*search', 'pgvector-search', 85],\n  ['embedding', 'embeddings', 80],\n\n  // Authentication & Security\n  ['auth', 'auth-patterns', 85],\n  ['login', 'auth-patterns', 75],\n  ['jwt', 'auth-patterns', 80],\n  ['oauth', 'auth-patterns', 85],\n  ['passkey', 'auth-patterns', 90],\n  ['webauthn', 'auth-patterns', 90],\n  ['session', 'auth-patterns', 60],\n  ['password', 'auth-patterns', 70],\n  ['security', 'owasp-top-10', 75],\n  ['owasp', 'owasp-top-10', 95],\n  ['xss', 'owasp-top-10', 80],\n  ['injection', 'owasp-top-10', 80],\n  ['csrf', 'owasp-top-10', 80],\n  ['validation', 'input-validation', 70],\n  ['sanitiz', 'input-validation', 80],\n  ['defense.*depth', 'defense-in-depth', 95],\n\n  // Testing\n  ['test', 'integration-testing', 60],\n  ['unit.*test', 'pytest-advanced', 80],\n  ['pytest', 'pytest-advanced', 90],\n  ['integration.*test', 'integration-testing', 85],\n  ['e2e', 'e2e-testing', 90],\n  ['playwright', 'e2e-testing', 80],\n  ['mock', 'msw-mocking', 75],\n  ['msw', 'msw-mocking', 95],\n  ['fixture', 'test-data-management', 80],\n  ['test.*data', 'test-data-management', 85],\n  ['coverage', 'pytest-advanced', 60],\n  ['property.*test', 'property-based-testing', 90],\n  ['hypothesis', 'property-based-testing', 95],\n  ['contract.*test', 'contract-testing', 95],\n  ['pact', 'contract-testing', 95],\n  ['golden.*dataset', 'golden-dataset-validation', 90],\n  ['performance.*test', 'performance-testing', 90],\n  ['load.*test', 'performance-testing', 85],\n  ['k6', 'performance-testing', 95],\n  ['locust', 'performance-testing', 95],\n\n  // Frontend & React\n  ['react', 'react-server-components-framework', 70],\n  ['component', 'react-server-components-framework', 50],\n  ['server.*component', 'react-server-components-framework', 95],\n  ['nextjs', 'react-server-components-framework', 85],\n  ['next\\\\.js', 'react-server-components-framework', 85],\n  ['suspense', 'react-server-components-framework', 70],\n  ['streaming.*ssr', 'react-server-components-framework', 90],\n  ['form', 'form-state-patterns', 70],\n  ['react.*hook.*form', 'form-state-patterns', 95],\n  ['zod', 'form-state-patterns', 60],\n  ['zustand', 'zustand-patterns', 95],\n  ['state.*management', 'zustand-patterns', 70],\n  ['tanstack', 'tanstack-query-advanced', 90],\n  ['react.*query', 'tanstack-query-advanced', 85],\n  ['radix', 'radix-primitives', 95],\n  ['shadcn', 'radix-primitives', 80],\n  ['tailwind', 'design-system-starter', 60],\n  ['design.*system', 'design-system-starter', 85],\n  ['animation', 'motion-animation-patterns', 80],\n  ['framer', 'motion-animation-patterns', 90],\n  ['core.*web.*vital', 'core-web-vitals', 95],\n  ['lcp', 'core-web-vitals', 80],\n  ['cls', 'core-web-vitals', 80],\n  ['inp', 'core-web-vitals', 80],\n  ['i18n', 'i18n-date-patterns', 90],\n  ['internationalization', 'i18n-date-patterns', 95],\n  ['locale', 'i18n-date-patterns', 70],\n\n  // Accessibility\n  ['accessibility', 'a11y-testing', 85],\n  ['a11y', 'a11y-testing', 95],\n  ['wcag', 'a11y-testing', 95],\n  ['screen.*reader', 'focus-management', 80],\n  ['keyboard.*nav', 'focus-management', 90],\n  ['focus', 'focus-management', 60],\n  ['aria', 'focus-management', 70],\n\n  // AI/LLM\n  ['llm', 'function-calling', 70],\n  ['openai', 'function-calling', 60],\n  ['anthropic', 'function-calling', 60],\n  ['function.*call', 'function-calling', 90],\n  ['tool.*use', 'function-calling', 85],\n  ['stream', 'llm-streaming', 70],\n  ['rag', 'rag-retrieval', 95],\n  ['retrieval', 'rag-retrieval', 75],\n  ['context', 'contextual-retrieval', 60],\n  ['chunk', 'embeddings', 70],\n  ['vector', 'embeddings', 75],\n  ['semantic.*search', 'embeddings', 85],\n  ['langfuse', 'langfuse-observability', 95],\n  ['llm.*observ', 'langfuse-observability', 90],\n  ['langgraph', 'langgraph-state', 85],\n  ['agent', 'agent-loops', 70],\n  ['workflow', 'langgraph-state', 60],\n  ['supervisor', 'langgraph-supervisor', 90],\n  ['human.*in.*loop', 'langgraph-human-in-loop', 95],\n  ['checkpoint', 'langgraph-checkpoints', 90],\n  ['prompt.*cache', 'prompt-caching', 95],\n  ['cache.*llm', 'semantic-caching', 85],\n  ['eval', 'llm-evaluation', 70],\n  ['llm.*test', 'llm-testing', 85],\n  ['ollama', 'ollama-local', 95],\n\n  // DevOps & Infrastructure\n  ['deploy', 'devops-deployment', 75],\n  ['ci', 'devops-deployment', 60],\n  ['cd', 'devops-deployment', 60],\n  ['github.*action', 'github-operations', 85],\n  ['release', 'release-management', 80],\n  ['changelog', 'release-management', 70],\n  ['version', 'release-management', 50],\n  ['observ', 'observability-monitoring', 80],\n  ['monitor', 'observability-monitoring', 70],\n  ['log', 'observability-monitoring', 50],\n  ['metric', 'observability-monitoring', 60],\n  ['trace', 'observability-monitoring', 70],\n  ['alert', 'observability-monitoring', 60],\n\n  // Git & GitHub\n  ['git', 'git-workflow', 70],\n  ['branch', 'git-workflow', 60],\n  ['commit', 'commit', 80],\n  ['rebase', 'git-workflow', 70],\n  ['stacked.*pr', 'stacked-prs', 95],\n  ['pr', 'create-pr', 60],\n  ['pull.*request', 'create-pr', 75],\n  ['recovery', 'git-recovery-command', 80],\n  ['reflog', 'git-recovery-command', 95],\n  ['milestone', 'github-operations', 80],\n  ['issue', 'github-operations', 50],\n\n  // Event-Driven & Messaging\n  ['event.*sourc', 'event-sourcing', 95],\n  ['kafka', 'message-queues', 85],\n  ['rabbitmq', 'message-queues', 85],\n  ['queue', 'message-queues', 75],\n  ['pub.*sub', 'message-queues', 80],\n  ['outbox', 'outbox-pattern', 95],\n  ['saga', 'event-sourcing', 70],\n  ['cqrs', 'event-sourcing', 80],\n\n  // Async & Concurrency\n  ['async', 'asyncio-advanced', 70],\n  ['asyncio', 'asyncio-advanced', 90],\n  ['taskgroup', 'asyncio-advanced', 95],\n  ['concurrent', 'asyncio-advanced', 60],\n  ['background.*job', 'background-jobs', 90],\n  ['celery', 'background-jobs', 95],\n  ['worker', 'background-jobs', 60],\n  ['distributed.*lock', 'distributed-locks', 95],\n  ['redis.*lock', 'distributed-locks', 85],\n  ['idempoten', 'idempotency-patterns', 95],\n\n  // Architecture & Patterns\n  ['clean.*architecture', 'clean-architecture', 95],\n  ['ddd', 'domain-driven-design', 95],\n  ['domain.*driven', 'domain-driven-design', 90],\n  ['aggregate', 'aggregate-patterns', 90],\n  ['adr', 'architecture-decision-record', 95],\n  ['decision.*record', 'architecture-decision-record', 85],\n\n  // Code Quality\n  ['lint', 'biome-linting', 70],\n  ['biome', 'biome-linting', 95],\n  ['eslint', 'biome-linting', 60],\n  ['format', 'biome-linting', 50],\n  ['code.*review', 'code-review-playbook', 90],\n  ['review', 'code-review-playbook', 60],\n  ['quality.*gate', 'quality-gates', 90],\n\n  // Error Handling\n  ['error.*handl', 'error-handling-rfc9457', 85],\n  ['rfc.*9457', 'error-handling-rfc9457', 95],\n  ['problem.*detail', 'error-handling-rfc9457', 90],\n];\n\ninterface SkillMatch {\n  skill: string;\n  confidence: number;\n}\n\n/**\n * Find matching skills based on prompt keywords.\n * Exported for use by skill-resolver.ts.\n */\nexport function findMatchingSkills(prompt: string): SkillMatch[] {\n  const promptLower = prompt.toLowerCase();\n  const skillScores = new Map<string, number>();\n\n  for (const [keyword, skill, confidence] of KEYWORD_MAPPINGS) {\n    // Convert keyword to regex pattern\n    const regex = new RegExp(keyword, 'i');\n\n    if (regex.test(promptLower)) {\n      const currentScore = skillScores.get(skill) || 0;\n      if (confidence > currentScore) {\n        skillScores.set(skill, confidence);\n      }\n    }\n  }\n\n  // Convert to array and sort by confidence\n  const matches: SkillMatch[] = Array.from(skillScores.entries())\n    .map(([skill, confidence]) => ({ skill, confidence }))\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, MAX_SUGGESTIONS);\n\n  return matches;\n}\n\n/**\n * Get skill description from SKILL.md frontmatter\n */\nfunction getSkillDescription(skillName: string, skillsDir: string): string {\n  const skillFile = join(skillsDir, skillName, 'SKILL.md');\n\n  if (!existsSync(skillFile)) {\n    return '';\n  }\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n\n    // Extract description from YAML frontmatter\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (frontmatterMatch) {\n      const frontmatter = frontmatterMatch[1];\n      const descriptionMatch = frontmatter.match(/^description:\\s*(.+)$/m);\n      if (descriptionMatch) {\n        return descriptionMatch[1].trim();\n      }\n    }\n  } catch {\n    // Ignore\n  }\n\n  return '';\n}\n\n/**\n * Build suggestion message for Claude\n */\nfunction buildSuggestionMessage(matches: SkillMatch[], skillsDir: string): string {\n  if (matches.length === 0) {\n    return '';\n  }\n\n  let message = `## Relevant Skills Detected\n\nBased on your prompt, the following skills may be helpful:\n\n`;\n\n  for (const { skill, confidence } of matches) {\n    if (confidence >= MIN_CONFIDENCE) {\n      const description = getSkillDescription(skill, skillsDir);\n      if (description) {\n        message += `- **${skill}** (${confidence}% match): ${description}\\n`;\n      } else {\n        message += `- **${skill}** (${confidence}% match)\\n`;\n      }\n    }\n  }\n\n  message += `\nUse \\`/ork:<skill-name>\\` to invoke a user-invocable skill, or read the skill with \\`Read skills/<skill-name>/SKILL.md\\` for patterns and guidance.`;\n\n  return message;\n}\n\n/**\n * Skill auto-suggest hook\n */\nexport function skillAutoSuggest(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const pluginRoot = getPluginRoot();\n  const skillsDir = join(pluginRoot, 'skills');\n\n  if (!prompt) {\n    return outputSilentSuccess();\n  }\n\n  logHook('skill-auto-suggest', 'Analyzing prompt for skill suggestions...');\n\n  // Find matching skills\n  const matches = findMatchingSkills(prompt);\n\n  if (matches.length === 0) {\n    logHook('skill-auto-suggest', 'No skill matches found');\n    return outputSilentSuccess();\n  }\n\n  logHook(\n    'skill-auto-suggest',\n    `Found matches: ${matches.map((m) => `${m.skill}:${m.confidence}`).join(', ')}`\n  );\n\n  // Build suggestion message\n  const suggestionMessage = buildSuggestionMessage(matches, skillsDir);\n\n  if (suggestionMessage) {\n    logHook('skill-auto-suggest', 'Injecting skill suggestions via additionalContext');\n    return outputPromptContext(suggestionMessage);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * User Intent Detector - Smart extraction of decisions, preferences, and problems from user prompts\n *\n * Part of Intelligent Decision Capture System\n *\n * Purpose:\n * - Detect when users make decisions (\"let's use X\", \"chose Y over Z\")\n * - Extract preferences (\"I prefer X\", \"always use Y\")\n * - Identify problems being stated (\"not working\", \"error with\")\n * - Capture rationale (\"because\", \"since\", \"to avoid\")\n * - Extract mentioned entities (technologies, patterns, tools)\n *\n * CC 2.1.16 Compliant\n */\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport type IntentType = 'decision' | 'preference' | 'problem' | 'question' | 'instruction';\n\n/**\n * Extracted user intent with confidence scoring\n */\nexport interface UserIntent {\n  /** Type of intent detected */\n  type: IntentType;\n  /** Confidence score 0-1 */\n  confidence: number;\n  /** The matched text segment */\n  text: string;\n  /** Technologies, patterns, tools mentioned */\n  entities: string[];\n  /** Rationale if \"because/since/to avoid\" clause present */\n  rationale?: string;\n  /** For decisions: what was chosen over what */\n  alternatives?: string[];\n  /** Original match position */\n  position: number;\n}\n\n/**\n * Result of intent detection on a prompt\n */\nexport interface IntentDetectionResult {\n  /** All detected intents */\n  intents: UserIntent[];\n  /** High-confidence decisions (>=0.7) */\n  decisions: UserIntent[];\n  /** All preferences */\n  preferences: UserIntent[];\n  /** Questions asked */\n  questions: UserIntent[];\n  /** Problems/issues mentioned */\n  problems: UserIntent[];\n  /** Summary for logging */\n  summary: string;\n}\n\n// =============================================================================\n// PATTERN DEFINITIONS\n// =============================================================================\n\n/**\n * Decision patterns - when user makes a choice\n * Group 1: verb, Group 2: what was chosen, Group 3: alternative (if present)\n */\nconst DECISION_PATTERNS: RegExp[] = [\n  // Active choices - simple form\n  /\\b(let'?s use|let'?s go with|going with|will use|should use)\\s+([^.,!?\\n]+)/gi,\n  /\\b(decided on|decided to use|decided to go with|decided to)\\s+([^.,!?\\n]+)/gi,\n  /\\b(chose|choose|selected|opting for|picked)\\s+([^.,!?\\n]+)/gi,\n  // Using X for Y\n  /\\b(using)\\s+([^.,!?\\n]+)\\s+for\\s+/gi,\n  // Comparison choices: \"X over Y\" or \"X instead of Y\"\n  /\\b(chose|prefer|selected|going with)\\s+([\\w][\\w\\s-]*?)\\s+over\\s+([\\w][\\w\\s-]*)/gi,\n  /\\b(chose|prefer|selected|going with)\\s+([\\w][\\w\\s-]*?)\\s+instead of\\s+([\\w][\\w\\s-]*)/gi,\n  // Implementation decisions\n  /\\b(implementing|implement)\\s+([^.,!?\\n]+?)\\s+(?:approach|pattern|solution)/gi,\n  /\\b(?:the|our)\\s+(?:approach|decision|choice)\\s+is\\s+([^.,!?\\n]+)/gi,\n  // I/We decided\n  /\\bI\\s+(decided|chose)\\s+([^.,!?\\n]+)/gi,\n];\n\n/**\n * Preference patterns - user stating preferences\n */\nconst PREFERENCE_PATTERNS: RegExp[] = [\n  /\\bi (prefer|like|always use|never use|want|favor)\\s+([^.,!?\\n]+)/gi,\n  /\\bi'd prefer\\s+([^.,!?\\n]+)/gi,\n  /\\b(my preference is|I'd rather|rather use)\\s+([^.,!?\\n]+)/gi,\n  /\\b(style should be|convention is|naming should)\\s+([^.,!?\\n]+)/gi,\n  /\\b(always|never)\\s+(use|do|add|include)\\s+([^.,!?\\n]+)/gi,\n  /\\bdon't\\s+(use|like|want)\\s+([^.,!?\\n]+)/gi,\n];\n\n/**\n * Problem patterns - user describing issues\n */\nconst PROBLEM_PATTERNS: RegExp[] = [\n  /\\b(issue|problem|error|bug|doesn't work|isn't working|can't|failing|broken)\\b[^.!?\\n]*[.!?]?/gi,\n  /\\bthe (\\w[\\w\\s-]*) (is broken|isn't working|fails|errors|crashes)/gi,\n  /\\b(getting|seeing|having)\\s+(an error|errors|issues|problems)\\s+(with|in|when)\\s+([^.,!?\\n]+)/gi,\n  /\\b(fails|failed|failing)\\s+(to|when|with)\\s+([^.,!?\\n]+)/gi,\n  /\\b(not working|doesn't work|won't work)\\s*([^.,!?\\n]*)/gi,\n  /\\b(timeout|exception|crash|hang|freeze)\\s+(in|with|when|on)\\s+([^.,!?\\n]+)/gi,\n];\n\n\n/**\n * Question patterns - user asking questions\n */\nconst QUESTION_PATTERNS: RegExp[] = [\n  /\\bhow do I\\s+([^?.\\n]+)/gi,\n  /\\bhow can I\\s+([^?.\\n]+)/gi,\n  /\\bhow to\\s+([^?.\\n]+)/gi,\n  /\\bwhat is\\s+([^?.\\n]+)/gi,\n  /\\bwhat are\\s+([^?.\\n]+)/gi,\n  /\\bwhat does\\s+([^?.\\n]+)/gi,\n  /\\bwhy does\\s+([^?.\\n]+)/gi,\n  /\\bwhy is\\s+([^?.\\n]+)/gi,\n  /\\bwhy do\\s+([^?.\\n]+)/gi,\n  /\\bcan you\\s+(explain|show|help)\\s+([^?.\\n]+)/gi,\n  /\\bwhere (is|are|do|does|can)\\s+([^?.\\n]+)/gi,\n  /\\bwhen (should|do|does|can)\\s+([^?.\\n]+)/gi,\n];\n\n/**\n * Rationale patterns - extract \"because/since\" clauses\n * Each pattern should have the rationale in group 1\n */\nconst RATIONALE_PATTERNS: RegExp[] = [\n  /\\bbecause\\s+([^.,!?\\n]+)/i,\n  /\\bsince\\s+([^.,!?\\n]+)/i,\n  /\\bdue to\\s+([^.,!?\\n]+)/i,\n  /\\bto avoid\\s+([^.,!?\\n]+)/i,\n  /\\bfor\\s+(?:better|improved|faster|easier|simpler)\\s+([^.,!?\\n]+)/i,\n  /\\bso that\\s+([^.,!?\\n]+)/i,\n  /\\bin order to\\s+([^.,!?\\n]+)/i,\n  /\\bas it\\s+([^.,!?\\n]+)/i,\n];\n\n/**\n * Known entities for extraction\n */\nconst KNOWN_TECHNOLOGIES = [\n  // Databases\n  'postgresql', 'postgres', 'pgvector', 'redis', 'mongodb', 'sqlite', 'mysql', 'dynamodb',\n  // Frameworks\n  'fastapi', 'django', 'flask', 'express', 'nextjs', 'nest', 'spring', 'rails',\n  // Frontend\n  'react', 'vue', 'angular', 'svelte', 'solid', 'qwik', 'astro',\n  // Languages\n  'typescript', 'python', 'javascript', 'rust', 'go', 'java', 'kotlin',\n  // Auth\n  'jwt', 'oauth', 'oauth2', 'passkeys', 'saml', 'oidc',\n  // AI/ML\n  'langchain', 'langgraph', 'langfuse', 'openai', 'anthropic', 'llama',\n  // Infrastructure\n  'docker', 'kubernetes', 'k8s', 'terraform', 'aws', 'gcp', 'azure',\n  // Testing\n  'pytest', 'jest', 'vitest', 'playwright', 'cypress', 'msw',\n  // Tools\n  'webpack', 'vite', 'esbuild', 'turbopack', 'bun', 'pnpm', 'yarn',\n];\n\nconst KNOWN_PATTERNS = [\n  'cursor-pagination', 'offset-pagination', 'keyset-pagination',\n  'repository-pattern', 'service-layer', 'clean-architecture',\n  'dependency-injection', 'event-sourcing', 'cqrs', 'saga-pattern',\n  'circuit-breaker', 'rate-limiting', 'retry-pattern',\n  'cache-aside', 'write-through', 'read-through',\n  'rag', 'semantic-search', 'vector-search',\n  'tdd', 'bdd', 'ddd',\n  'microservices', 'monolith', 'serverless',\n  'rest', 'graphql', 'grpc', 'websocket', 'sse',\n];\n\nconst KNOWN_TOOLS = [\n  'grep', 'read', 'write', 'edit', 'glob', 'bash', 'task',\n  'git', 'gh', 'npm', 'yarn', 'pnpm',\n  'claude', 'cursor', 'vscode', 'vim', 'neovim',\n];\n\n// =============================================================================\n// EXTRACTION FUNCTIONS\n// =============================================================================\n\n/**\n * Extract entities (technologies, patterns, tools) from text\n */\nexport function extractEntities(text: string): string[] {\n  const textLower = text.toLowerCase();\n  const entities: Set<string> = new Set();\n\n  for (const tech of KNOWN_TECHNOLOGIES) {\n    if (textLower.includes(tech)) {\n      entities.add(tech);\n    }\n  }\n\n  for (const pattern of KNOWN_PATTERNS) {\n    // Handle hyphenated and space-separated versions\n    const normalized = pattern.replace(/-/g, '[- ]?');\n    if (new RegExp(normalized, 'i').test(text)) {\n      entities.add(pattern);\n    }\n  }\n\n  for (const tool of KNOWN_TOOLS) {\n    if (textLower.includes(tool)) {\n      entities.add(tool);\n    }\n  }\n\n  return [...entities];\n}\n\n/**\n * Extract rationale from text near a match position\n */\nexport function extractRationale(text: string, matchIndex: number): string | undefined {\n  // Look in a window around the match\n  const windowStart = Math.max(0, matchIndex - 50);\n  const windowEnd = Math.min(text.length, matchIndex + 300);\n  const window = text.slice(windowStart, windowEnd);\n\n  for (const pattern of RATIONALE_PATTERNS) {\n    const match = window.match(pattern);\n    if (match && match[1]) {\n      return match[1].trim().slice(0, 200); // Cap at 200 chars\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Calculate confidence based on match quality and context\n */\nfunction calculateConfidence(\n  matchText: string,\n  hasRationale: boolean,\n  hasAlternatives: boolean,\n  entityCount: number\n): number {\n  let confidence = 0.5; // Base confidence\n\n  // Strong patterns boost confidence\n  if (/\\b(decided|chose|selected)\\b/i.test(matchText)) {\n    confidence += 0.2;\n  }\n\n  // Rationale significantly boosts confidence\n  if (hasRationale) {\n    confidence += 0.15;\n  }\n\n  // Having alternatives shows explicit comparison\n  if (hasAlternatives) {\n    confidence += 0.1;\n  }\n\n  // More entities = more specific\n  if (entityCount >= 1) confidence += 0.05;\n  if (entityCount >= 2) confidence += 0.05;\n\n  // Very short matches are less confident\n  if (matchText.length < 20) {\n    confidence -= 0.1;\n  }\n\n  return Math.min(0.99, Math.max(0.1, confidence));\n}\n\n// =============================================================================\n// MAIN DETECTION FUNCTION\n// =============================================================================\n\n/**\n * Detect user intents from prompt text\n *\n * @param prompt - The user's input text\n * @returns IntentDetectionResult with all detected intents\n */\nexport function detectUserIntent(prompt: string): IntentDetectionResult {\n  const intents: UserIntent[] = [];\n\n  // Skip very short prompts\n  if (!prompt || prompt.length < 10) {\n    return {\n      intents: [],\n      decisions: [],\n      preferences: [],\n      questions: [],\n      problems: [],\n      summary: 'No intents detected (prompt too short)',\n    };\n  }\n\n  // ==========================================================================\n  // Detect Decisions\n  // ==========================================================================\n  for (const pattern of DECISION_PATTERNS) {\n    const matches = prompt.matchAll(pattern);\n    for (const match of matches) {\n      const matchText = match[0];\n      const position = match.index || 0;\n\n      // Extract what was chosen and alternatives\n      let choice = '';\n      let alternatives: string[] | undefined;\n\n      if (match[3]) {\n        // Pattern with alternatives (X over Y)\n        choice = match[2]?.trim() || '';\n        alternatives = [match[3].trim()];\n      } else if (match[2]) {\n        choice = match[2].trim();\n      }\n\n      if (!choice || choice.length < 2) continue;\n\n      const rationale = extractRationale(prompt, position);\n      const entities = extractEntities(matchText + (rationale || ''));\n\n      const confidence = calculateConfidence(\n        matchText,\n        !!rationale,\n        !!alternatives,\n        entities.length\n      );\n\n      intents.push({\n        type: 'decision',\n        confidence,\n        text: matchText.slice(0, 300),\n        entities,\n        rationale,\n        alternatives,\n        position,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Detect Preferences\n  // ==========================================================================\n  for (const pattern of PREFERENCE_PATTERNS) {\n    const matches = prompt.matchAll(pattern);\n    for (const match of matches) {\n      const matchText = match[0];\n      const position = match.index || 0;\n\n      const entities = extractEntities(matchText);\n\n      intents.push({\n        type: 'preference',\n        confidence: entities.length > 0 ? 0.8 : 0.6,\n        text: matchText.slice(0, 300),\n        entities,\n        position,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Detect Problems\n  // ==========================================================================\n  for (const pattern of PROBLEM_PATTERNS) {\n    const matches = prompt.matchAll(pattern);\n    for (const match of matches) {\n      const matchText = match[0];\n      const position = match.index || 0;\n\n      const entities = extractEntities(matchText);\n\n      intents.push({\n        type: 'problem',\n        confidence: 0.75,\n        text: matchText.slice(0, 300),\n        entities,\n        position,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Detect Questions\n  // ==========================================================================\n  for (const pattern of QUESTION_PATTERNS) {\n    const matches = prompt.matchAll(pattern);\n    for (const match of matches) {\n      const matchText = match[0];\n      const position = match.index || 0;\n\n      const entities = extractEntities(matchText);\n\n      intents.push({\n        type: 'question',\n        confidence: 0.8,\n        text: matchText.slice(0, 300),\n        entities,\n        position,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Deduplicate overlapping intents\n  // ==========================================================================\n  const uniqueIntents = deduplicateIntents(intents);\n\n  // Categorize\n  const decisions = uniqueIntents.filter(i => i.type === 'decision' && i.confidence >= 0.7);\n  const preferences = uniqueIntents.filter(i => i.type === 'preference');\n  const problems = uniqueIntents.filter(i => i.type === 'problem');\n  const questions = uniqueIntents.filter(i => i.type === 'question');\n\n  const summary = buildSummary(decisions, preferences, problems, questions);\n\n  return {\n    intents: uniqueIntents,\n    decisions,\n    preferences,\n    questions,\n    problems,\n    summary,\n  };\n}\n\n/**\n * Remove overlapping intents, keeping higher confidence ones\n */\nfunction deduplicateIntents(intents: UserIntent[]): UserIntent[] {\n  if (intents.length <= 1) return intents;\n\n  // Sort by position\n  const sorted = [...intents].sort((a, b) => a.position - b.position);\n  const result: UserIntent[] = [];\n\n  for (const intent of sorted) {\n    // Check if this overlaps with any existing intent\n    const overlaps = result.some(existing => {\n      const existingEnd = existing.position + existing.text.length;\n      const intentEnd = intent.position + intent.text.length;\n      return (\n        (intent.position >= existing.position && intent.position < existingEnd) ||\n        (existing.position >= intent.position && existing.position < intentEnd)\n      );\n    });\n\n    if (!overlaps) {\n      result.push(intent);\n    } else {\n      // Keep the one with higher confidence if same type\n      const overlappingIndex = result.findIndex(existing => {\n        const existingEnd = existing.position + existing.text.length;\n        const intentEnd = intent.position + intent.text.length;\n        return (\n          existing.type === intent.type &&\n          ((intent.position >= existing.position && intent.position < existingEnd) ||\n            (existing.position >= intent.position && existing.position < intentEnd))\n        );\n      });\n\n      if (overlappingIndex >= 0 && intent.confidence > result[overlappingIndex].confidence) {\n        result[overlappingIndex] = intent;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Build summary string for logging\n */\nfunction buildSummary(\n  decisions: UserIntent[],\n  preferences: UserIntent[],\n  problems: UserIntent[],\n  questions: UserIntent[]\n): string {\n  const parts: string[] = [];\n\n  if (decisions.length > 0) {\n    parts.push(`${decisions.length} decision${decisions.length > 1 ? 's' : ''}`);\n  }\n  if (preferences.length > 0) {\n    parts.push(`${preferences.length} preference${preferences.length > 1 ? 's' : ''}`);\n  }\n  if (problems.length > 0) {\n    parts.push(`${problems.length} problem${problems.length > 1 ? 's' : ''}`);\n  }\n  if (questions.length > 0) {\n    parts.push(`${questions.length} question${questions.length > 1 ? 's' : ''}`);\n  }\n\n  if (parts.length === 0) {\n    return 'No intents detected';\n  }\n\n  return `Detected: ${parts.join(', ')}`;\n}\n\n// =============================================================================\n// UTILITY EXPORTS\n// =============================================================================\n\n/**\n * Check if prompt contains decision-like language\n */\nexport function hasDecisionLanguage(prompt: string): boolean {\n  const decisionKeywords = [\n    'decided', 'chose', 'selected', 'let\\'s use', 'going with',\n    'will use', 'opting for', 'picked', 'prefer',\n  ];\n  const lower = prompt.toLowerCase();\n  return decisionKeywords.some(k => lower.includes(k));\n}\n\n/**\n * Check if prompt contains problem/issue language\n */\nexport function hasProblemLanguage(prompt: string): boolean {\n  const problemKeywords = [\n    'error', 'bug', 'issue', 'problem', 'failing', 'broken',\n    'not working', 'doesn\\'t work', 'crash', 'timeout',\n  ];\n  const lower = prompt.toLowerCase();\n  return problemKeywords.some(k => lower.includes(k));\n}\n\n/**\n * Check if prompt contains question-like language\n */\nexport function hasQuestionLanguage(prompt: string): boolean {\n  const questionKeywords = [\n    'how do i', 'how can i', 'how to',\n    'what is', 'what are', 'what does',\n    'why does', 'why is', 'why do',\n    'where is', 'where are',\n    'when should', 'can you explain', 'can you help',\n  ];\n  const lower = prompt.toLowerCase();\n  return questionKeywords.some(k => lower.includes(k));\n}\n", "/**\n * Capture User Intent Hook - Extract decisions and preferences from user prompts\n *\n * Part of Intelligent Decision Capture System\n * Hook: UserPromptSubmit\n *\n * Purpose:\n * - Capture decisions when users say \"let's use X\" or \"chose Y over Z\"\n * - Extract preferences when users express \"I prefer X\"\n * - Track problems/issues for later solution pairing\n * - Store with rationale (\"because...\") when present\n *\n * Storage:\n * - Decisions \u2192 .claude/memory/pending-decisions.jsonl\n * - Preferences \u2192 .claude/memory/user-preferences.jsonl\n * - Problems \u2192 .claude/memory/open-problems.jsonl\n *\n * CC 2.1.16 Compliant - Uses outputSilentSuccess for non-blocking capture\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  getProjectDir,\n  getSessionId,\n  logHook,\n} from '../lib/common.js';\nimport {\n  detectUserIntent,\n  type UserIntent,\n  type IntentDetectionResult,\n} from '../lib/user-intent-detector.js';\nimport {\n  trackDecisionMade,\n  trackPreferenceStated,\n  trackProblemReported,\n} from '../lib/session-tracker.js';\nimport { existsSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst HOOK_NAME = 'capture-user-intent';\nconst MIN_PROMPT_LENGTH = 15; // Skip very short prompts\nconst MIN_CONFIDENCE_FOR_STORAGE = 0.6; // Only store reasonably confident intents\n\n// =============================================================================\n// STORAGE\n// =============================================================================\n\n/**\n * Stored decision record\n */\ninterface StoredDecision {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  type: 'decision';\n  text: string;\n  confidence: number;\n  entities: string[];\n  rationale?: string;\n  alternatives?: string[];\n  project: string;\n  status: 'pending' | 'confirmed' | 'applied';\n}\n\n/**\n * Stored preference record\n */\ninterface StoredPreference {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  type: 'preference';\n  text: string;\n  confidence: number;\n  entities: string[];\n  project: string;\n}\n\n/**\n * Stored problem record for solution pairing\n */\ninterface StoredProblem {\n  id: string;\n  timestamp: string;\n  session_id: string;\n  type: 'problem';\n  text: string;\n  confidence: number;\n  entities: string[];\n  project: string;\n  status: 'open' | 'solved' | 'abandoned';\n}\n\n/**\n * Generate unique ID\n */\nfunction generateId(prefix: string): string {\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).slice(2, 8);\n  return `${prefix}-${timestamp}-${random}`;\n}\n\n/**\n * Get project name from directory\n */\nfunction getProjectName(): string {\n  const projectDir = getProjectDir();\n  return projectDir.split('/').pop() || 'unknown';\n}\n\n/**\n * Append record to JSONL file\n */\nfunction appendToJsonl(filePath: string, record: unknown): boolean {\n  try {\n    const dir = dirname(filePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    const line = JSON.stringify(record) + '\\n';\n    appendFileSync(filePath, line);\n    return true;\n  } catch (err) {\n    logHook(HOOK_NAME, `Failed to write to ${filePath}: ${err}`, 'warn');\n    return false;\n  }\n}\n\n/**\n * Store decisions to pending file\n */\nfunction storeDecisions(decisions: UserIntent[], sessionId: string): number {\n  if (decisions.length === 0) return 0;\n\n  const projectDir = getProjectDir();\n  const filePath = join(projectDir, '.claude', 'memory', 'pending-decisions.jsonl');\n  const project = getProjectName();\n  const timestamp = new Date().toISOString();\n  let stored = 0;\n\n  for (const decision of decisions) {\n    if (decision.confidence < MIN_CONFIDENCE_FOR_STORAGE) continue;\n\n    const record: StoredDecision = {\n      id: generateId('dec'),\n      timestamp,\n      session_id: sessionId,\n      type: 'decision',\n      text: decision.text,\n      confidence: decision.confidence,\n      entities: decision.entities,\n      rationale: decision.rationale,\n      alternatives: decision.alternatives,\n      project,\n      status: 'pending',\n    };\n\n    if (appendToJsonl(filePath, record)) {\n      stored++;\n    }\n  }\n\n  return stored;\n}\n\n/**\n * Store preferences\n */\nfunction storePreferences(preferences: UserIntent[], sessionId: string): number {\n  if (preferences.length === 0) return 0;\n\n  const projectDir = getProjectDir();\n  const filePath = join(projectDir, '.claude', 'memory', 'user-preferences.jsonl');\n  const project = getProjectName();\n  const timestamp = new Date().toISOString();\n  let stored = 0;\n\n  for (const pref of preferences) {\n    if (pref.confidence < MIN_CONFIDENCE_FOR_STORAGE) continue;\n\n    const record: StoredPreference = {\n      id: generateId('pref'),\n      timestamp,\n      session_id: sessionId,\n      type: 'preference',\n      text: pref.text,\n      confidence: pref.confidence,\n      entities: pref.entities,\n      project,\n    };\n\n    if (appendToJsonl(filePath, record)) {\n      stored++;\n    }\n  }\n\n  return stored;\n}\n\n/**\n * Store problems for later solution pairing\n */\nfunction storeProblems(problems: UserIntent[], sessionId: string): number {\n  if (problems.length === 0) return 0;\n\n  const projectDir = getProjectDir();\n  const filePath = join(projectDir, '.claude', 'memory', 'open-problems.jsonl');\n  const project = getProjectName();\n  const timestamp = new Date().toISOString();\n  let stored = 0;\n\n  for (const problem of problems) {\n    const record: StoredProblem = {\n      id: generateId('prob'),\n      timestamp,\n      session_id: sessionId,\n      type: 'problem',\n      text: problem.text,\n      confidence: problem.confidence,\n      entities: problem.entities,\n      project,\n      status: 'open',\n    };\n\n    if (appendToJsonl(filePath, record)) {\n      stored++;\n    }\n  }\n\n  return stored;\n}\n\n// =============================================================================\n// SESSION TRACKING INTEGRATION\n// =============================================================================\n\n/**\n * Track detected intents in the session tracker for user profile aggregation.\n * This bridges the intent detection to the centralized session event tracking.\n */\nfunction trackIntentsInSession(result: IntentDetectionResult): void {\n  try {\n    // Track decisions with rationale\n    for (const decision of result.decisions) {\n      trackDecisionMade(\n        decision.text,\n        decision.rationale,\n        decision.confidence\n      );\n    }\n\n    // Track preferences\n    for (const preference of result.preferences) {\n      trackPreferenceStated(\n        preference.text,\n        preference.confidence\n      );\n    }\n\n    // Track problems for later solution pairing\n    for (const problem of result.problems) {\n      trackProblemReported(problem.text);\n    }\n  } catch (err) {\n    logHook(HOOK_NAME, `Session tracking failed: ${err}`, 'warn');\n  }\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Capture user intent from prompts\n *\n * This hook runs on UserPromptSubmit and extracts:\n * - Decisions: \"let's use X\", \"chose Y over Z\"\n * - Preferences: \"I prefer X\", \"always use Y\"\n * - Problems: \"error with X\", \"not working\"\n *\n * All storage is fire-and-forget to avoid blocking the prompt.\n */\nexport function captureUserIntent(input: HookInput): HookResult {\n  const prompt = input.prompt;\n\n  // Skip if no prompt\n  if (!prompt || prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Get session ID\n  const sessionId = input.session_id || getSessionId();\n\n  // Detect intents\n  let result: IntentDetectionResult;\n  try {\n    result = detectUserIntent(prompt);\n  } catch (err) {\n    logHook(HOOK_NAME, `Intent detection failed: ${err}`, 'warn');\n    return outputSilentSuccess();\n  }\n\n  // Nothing detected\n  if (result.intents.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  // Store intents (non-blocking, fire-and-forget)\n  const decisionsStored = storeDecisions(result.decisions, sessionId);\n  const preferencesStored = storePreferences(result.preferences, sessionId);\n  const problemsStored = storeProblems(result.problems, sessionId);\n\n  // Track intents in session tracker for user profile aggregation\n  trackIntentsInSession(result);\n\n  const totalStored = decisionsStored + preferencesStored + problemsStored;\n\n  if (totalStored > 0) {\n    logHook(\n      HOOK_NAME,\n      `Captured: ${decisionsStored} decisions, ${preferencesStored} preferences, ${problemsStored} problems`,\n      'info'\n    );\n  }\n\n  // Always silent success - this is a background capture hook\n  return outputSilentSuccess();\n}\n", "/**\n * User Profile Management\n * Aggregates session data into user profiles for learning patterns across sessions.\n *\n * Profiles track:\n * - Skill usage patterns\n * - Agent preferences\n * - Decision history\n * - Workflow patterns\n * - Tool preferences\n *\n * Storage: ~/.claude/orchestkit/users/{user_id}/profile.json (cross-project)\n *\n * Migration: Profiles are migrated from old project-local path on first access\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getProjectDir, logHook } from './common.js';\nimport { resolveUserIdentity } from './user-identity.js';\nimport { generateSessionSummary, type SessionSummary } from './session-tracker.js';\nimport { analyzeDecisionFlow, type WorkflowPattern as FlowWorkflowPattern } from './decision-flow-tracker.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Usage statistics for a skill/agent/tool\n */\nexport interface UsageStats {\n  /** Total times used */\n  count: number;\n  /** Success rate (0-1) */\n  success_rate: number;\n  /** Average duration in ms */\n  avg_duration_ms?: number;\n  /** First used timestamp */\n  first_used: string;\n  /** Last used timestamp */\n  last_used: string;\n}\n\n/**\n * Recorded decision\n */\nexport interface RecordedDecision {\n  /** What was decided */\n  what: string;\n  /** Alternatives considered */\n  alternatives?: string[];\n  /** Rationale provided */\n  rationale?: string;\n  /** Confidence score */\n  confidence: number;\n  /** When decided */\n  timestamp: string;\n  /** Project where decision was made */\n  project?: string;\n}\n\n/**\n * Recorded preference\n */\nexport interface RecordedPreference {\n  /** Category (e.g., \"file_search\", \"testing\", \"language\") */\n  category: string;\n  /** What is preferred */\n  preference: string;\n  /** Confidence score */\n  confidence: number;\n  /** When recorded */\n  timestamp: string;\n  /** How many times this preference was observed */\n  observation_count: number;\n}\n\n/**\n * Detected workflow pattern\n */\nexport interface WorkflowPattern {\n  /** Pattern name */\n  name: string;\n  /** Pattern description */\n  description: string;\n  /** How often this pattern is observed (0-1) */\n  frequency: number;\n  /** Tool sequences that indicate this pattern */\n  tool_sequences: string[][];\n}\n\n/**\n * Descriptions for workflow pattern names\n */\nconst WORKFLOW_PATTERN_DESCRIPTIONS: Record<FlowWorkflowPattern, string> = {\n  'test-first': 'Writes tests before implementation (TDD)',\n  'explore-first': 'Reads existing code before making changes',\n  'iterate-fast': 'Makes quick write \u2192 test iterations',\n  'big-bang': 'Writes multiple files then tests',\n  'agent-delegate': 'Delegates tasks to specialized agents',\n  'mixed': 'Varies approach by task',\n};\n\n/**\n * Convert decision-flow-tracker pattern to user-profile WorkflowPattern\n */\nfunction convertFlowPattern(flowPattern: FlowWorkflowPattern, existingPatterns: WorkflowPattern[]): WorkflowPattern {\n  const existing = existingPatterns.find(p => p.name === flowPattern);\n  const frequency = existing ? Math.min(1, existing.frequency + 0.1) : 0.1;\n\n  return {\n    name: flowPattern,\n    description: WORKFLOW_PATTERN_DESCRIPTIONS[flowPattern],\n    frequency,\n    tool_sequences: [], // Populated by detailed analysis if needed\n  };\n}\n\n/**\n * Complete user profile\n */\nexport interface UserProfile {\n  /** User identifier */\n  user_id: string;\n  /** Anonymous identifier for global sharing */\n  anonymous_id: string;\n  /** Display name */\n  display_name: string;\n  /** Team/org if known */\n  team_id?: string;\n  /** Total sessions analyzed */\n  sessions_count: number;\n  /** First seen timestamp */\n  first_seen: string;\n  /** Last seen timestamp */\n  last_seen: string;\n  /** Profile version for migrations */\n  version: number;\n\n  /** Skill usage statistics */\n  skill_usage: Record<string, UsageStats>;\n  /** Agent usage statistics */\n  agent_usage: Record<string, UsageStats>;\n  /** Tool usage statistics */\n  tool_usage: Record<string, UsageStats>;\n\n  /** Tool preferences by category (Phase 4: Tool Usage Tracking)\n   * Maps category \u2192 preferred tool name based on usage frequency\n   * e.g., { search: 'Grep', file_read: 'Read' }\n   */\n  tool_preferences?: Record<string, string>;\n\n  /** Tool usage by category (Phase 4: Tool Usage Tracking)\n   * Maps category \u2192 { tool \u2192 count }\n   * e.g., { search: { Grep: 10, Glob: 3 } }\n   */\n  tool_usage_by_category?: Record<string, Record<string, number>>;\n\n  /** Recorded decisions */\n  decisions: RecordedDecision[];\n  /** Recorded preferences */\n  preferences: RecordedPreference[];\n\n  /** Detected workflow patterns */\n  workflow_patterns: WorkflowPattern[];\n\n  /** Session IDs that have been aggregated */\n  aggregated_sessions: string[];\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst PROFILE_VERSION = 1;\nconst MAX_DECISIONS = 100;\nconst MAX_PREFERENCES = 50;\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/**\n * Get the home directory for cross-project storage\n */\nfunction getHomeDir(): string {\n  return process.env.HOME || process.env.USERPROFILE || '/tmp';\n}\n\n/**\n * Get the cross-project OrchestKit directory\n */\nfunction getOrchestKitDir(): string {\n  return join(getHomeDir(), '.claude', 'orchestkit');\n}\n\n/**\n * Get user profile directory (cross-project, in home directory)\n */\nfunction getUserProfileDir(userId: string): string {\n  const sanitizedUserId = userId.replace(/[^a-zA-Z0-9@._-]/g, '_');\n  return join(getOrchestKitDir(), 'users', sanitizedUserId);\n}\n\n/**\n * Get user profile file path\n */\nfunction getUserProfilePath(userId: string): string {\n  return join(getUserProfileDir(userId), 'profile.json');\n}\n\n/**\n * Get the OLD project-local profile path (for migration)\n */\nfunction getLegacyProfilePath(userId: string): string {\n  const sanitizedUserId = userId.replace(/[^a-zA-Z0-9@._-]/g, '_');\n  return join(getProjectDir(), '.claude', 'memory', 'users', sanitizedUserId, 'profile.json');\n}\n\n/**\n * Migrate profile from old project-local path to new cross-project path\n * Returns true if migration occurred\n */\nfunction migrateProfileIfNeeded(userId: string): boolean {\n  const legacyPath = getLegacyProfilePath(userId);\n  const newPath = getUserProfilePath(userId);\n\n  // If new path exists, no migration needed\n  if (existsSync(newPath)) {\n    return false;\n  }\n\n  // If legacy path exists, migrate it\n  if (existsSync(legacyPath)) {\n    try {\n      const newDir = dirname(newPath);\n      if (!existsSync(newDir)) {\n        mkdirSync(newDir, { recursive: true });\n      }\n\n      // Read legacy profile\n      const content = readFileSync(legacyPath, 'utf8');\n      const profile = JSON.parse(content);\n\n      // Write to new location\n      writeFileSync(newPath, JSON.stringify(profile, null, 2));\n\n      logHook('user-profile', `Migrated profile for ${userId} to cross-project storage`, 'info');\n      return true;\n    } catch (error) {\n      logHook('user-profile', `Failed to migrate profile: ${error}`, 'warn');\n      return false;\n    }\n  }\n\n  return false;\n}\n\n// =============================================================================\n// PROFILE LOADING/SAVING\n// =============================================================================\n\n/**\n * Create empty profile for a user\n */\nfunction createEmptyProfile(userId: string): UserProfile {\n  const identity = resolveUserIdentity();\n  const now = new Date().toISOString();\n\n  return {\n    user_id: userId,\n    anonymous_id: identity.anonymous_id,\n    display_name: identity.display_name,\n    team_id: identity.team_id,\n    sessions_count: 0,\n    first_seen: now,\n    last_seen: now,\n    version: PROFILE_VERSION,\n    skill_usage: {},\n    agent_usage: {},\n    tool_usage: {},\n    decisions: [],\n    preferences: [],\n    workflow_patterns: [],\n    aggregated_sessions: [],\n  };\n}\n\n/**\n * Load user profile from disk\n */\nexport function loadUserProfile(userId?: string): UserProfile {\n  // Attempt migration from legacy project-local path\n  const uid = userId || resolveUserIdentity().user_id;\n  migrateProfileIfNeeded(uid);\n\n  const profilePath = getUserProfilePath(uid);\n\n\n  if (!existsSync(profilePath)) {\n    return createEmptyProfile(uid);\n  }\n\n  try {\n    const content = readFileSync(profilePath, 'utf8');\n    const profile = JSON.parse(content) as UserProfile;\n\n    // Handle version migrations here if needed\n    if (profile.version < PROFILE_VERSION) {\n      // Migrate profile\n      profile.version = PROFILE_VERSION;\n    }\n\n    return profile;\n  } catch (error) {\n    logHook('user-profile', `Failed to load profile: ${error}`, 'warn');\n    return createEmptyProfile(uid);\n  }\n}\n\n/**\n * Save user profile to disk\n */\nexport function saveUserProfile(profile: UserProfile): boolean {\n  const profileDir = getUserProfileDir(profile.user_id);\n  const profilePath = getUserProfilePath(profile.user_id);\n\n  try {\n    if (!existsSync(profileDir)) {\n      mkdirSync(profileDir, { recursive: true });\n    }\n\n    profile.last_seen = new Date().toISOString();\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n\n    logHook('user-profile', `Saved profile for ${profile.user_id}`, 'debug');\n    return true;\n  } catch (error) {\n    logHook('user-profile', `Failed to save profile: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// PROFILE AGGREGATION\n// =============================================================================\n\n/**\n * Update usage stats with new data\n */\nfunction updateUsageStats(\n  existing: UsageStats | undefined,\n  success: boolean,\n  durationMs?: number\n): UsageStats {\n  const now = new Date().toISOString();\n\n  if (!existing) {\n    return {\n      count: 1,\n      success_rate: success ? 1 : 0,\n      avg_duration_ms: durationMs,\n      first_used: now,\n      last_used: now,\n    };\n  }\n\n  const newCount = existing.count + 1;\n  const successCount = Math.round(existing.success_rate * existing.count) + (success ? 1 : 0);\n  const newSuccessRate = successCount / newCount;\n\n  let newAvgDuration = existing.avg_duration_ms;\n  if (durationMs !== undefined) {\n    if (existing.avg_duration_ms !== undefined) {\n      newAvgDuration =\n        (existing.avg_duration_ms * existing.count + durationMs) / newCount;\n    } else {\n      newAvgDuration = durationMs;\n    }\n  }\n\n  return {\n    count: newCount,\n    success_rate: newSuccessRate,\n    avg_duration_ms: newAvgDuration,\n    first_used: existing.first_used,\n    last_used: now,\n  };\n}\n\n/**\n * Aggregate a session into the user profile\n */\nexport function aggregateSession(\n  profile: UserProfile,\n  summary: SessionSummary\n): UserProfile {\n  // Skip if already aggregated\n  if (profile.aggregated_sessions.includes(summary.session_id)) {\n    logHook('user-profile', `Session ${summary.session_id} already aggregated`, 'debug');\n    return profile;\n  }\n\n  // Update session count\n  profile.sessions_count++;\n  profile.aggregated_sessions.push(summary.session_id);\n\n  // Aggregate skill usage\n  for (const skill of summary.skills_used) {\n    profile.skill_usage[skill] = updateUsageStats(\n      profile.skill_usage[skill],\n      true // We don't have per-skill success in summary\n    );\n  }\n\n  // Aggregate agent usage\n  for (const agent of summary.agents_spawned) {\n    profile.agent_usage[agent] = updateUsageStats(\n      profile.agent_usage[agent],\n      true\n    );\n  }\n\n  // Aggregate workflow pattern from decision flow (Issue #245 Phase 4)\n  try {\n    const flow = analyzeDecisionFlow(summary.session_id);\n    if (flow?.inferred_pattern && flow.inferred_pattern !== 'mixed') {\n      // Convert to WorkflowPattern interface and add to profile\n      const patternName = flow.inferred_pattern;\n      const existingIndex = profile.workflow_patterns.findIndex(p => p.name === patternName);\n\n      if (existingIndex !== -1) {\n        // Update existing pattern: increase frequency and move to front\n        const existing = profile.workflow_patterns[existingIndex];\n        existing.frequency = Math.min(1, existing.frequency + 0.1);\n        profile.workflow_patterns.splice(existingIndex, 1);\n        profile.workflow_patterns.unshift(existing);\n      } else {\n        // Add new pattern\n        const newPattern = convertFlowPattern(patternName, profile.workflow_patterns);\n        profile.workflow_patterns.unshift(newPattern);\n      }\n\n      // Keep only last 10 workflow patterns\n      if (profile.workflow_patterns.length > 10) {\n        profile.workflow_patterns = profile.workflow_patterns.slice(0, 10);\n      }\n      logHook('user-profile', `Aggregated workflow pattern: ${patternName}`, 'debug');\n    }\n  } catch (error) {\n    // Non-blocking: workflow pattern aggregation failure shouldn't stop profile aggregation\n    logHook('user-profile', `Failed to aggregate workflow pattern: ${error}`, 'debug');\n  }\n\n  // Keep only last N sessions to prevent unbounded growth\n  const MAX_AGGREGATED_SESSIONS = 100;\n  if (profile.aggregated_sessions.length > MAX_AGGREGATED_SESSIONS) {\n    profile.aggregated_sessions = profile.aggregated_sessions.slice(\n      -MAX_AGGREGATED_SESSIONS\n    );\n  }\n\n  return profile;\n}\n\n/**\n * Aggregate current session and save profile\n */\nexport function aggregateCurrentSession(): UserProfile {\n  const identity = resolveUserIdentity();\n  const profile = loadUserProfile(identity.user_id);\n  const summary = generateSessionSummary();\n\n  const updatedProfile = aggregateSession(profile, summary);\n  saveUserProfile(updatedProfile);\n\n  return updatedProfile;\n}\n\n// =============================================================================\n// DECISION/PREFERENCE RECORDING\n// =============================================================================\n\n/**\n * Add a decision to user profile\n */\nexport function addDecision(\n  profile: UserProfile,\n  decision: Omit<RecordedDecision, 'timestamp'>\n): UserProfile {\n  const newDecision: RecordedDecision = {\n    ...decision,\n    timestamp: new Date().toISOString(),\n  };\n\n  profile.decisions.unshift(newDecision);\n\n  // Keep only last N decisions\n  if (profile.decisions.length > MAX_DECISIONS) {\n    profile.decisions = profile.decisions.slice(0, MAX_DECISIONS);\n  }\n\n  return profile;\n}\n\n/**\n * Add or update a preference\n */\nexport function addPreference(\n  profile: UserProfile,\n  category: string,\n  preference: string,\n  confidence: number\n): UserProfile {\n  // Check if preference already exists\n  const existingIdx = profile.preferences.findIndex(\n    p => p.category === category && p.preference === preference\n  );\n\n  if (existingIdx >= 0) {\n    // Update existing\n    const existing = profile.preferences[existingIdx];\n    existing.observation_count++;\n    existing.confidence = Math.max(existing.confidence, confidence);\n    existing.timestamp = new Date().toISOString();\n  } else {\n    // Add new\n    profile.preferences.push({\n      category,\n      preference,\n      confidence,\n      timestamp: new Date().toISOString(),\n      observation_count: 1,\n    });\n\n    // Keep only top N preferences\n    if (profile.preferences.length > MAX_PREFERENCES) {\n      profile.preferences.sort((a, b) => b.observation_count - a.observation_count);\n      profile.preferences = profile.preferences.slice(0, MAX_PREFERENCES);\n    }\n  }\n\n  return profile;\n}\n\n// =============================================================================\n// PROFILE QUERIES\n// =============================================================================\n\n/**\n * Get top N used skills for a user\n */\nexport function getTopSkills(profile: UserProfile, limit: number = 5): Array<{\n  skill: string;\n  stats: UsageStats;\n}> {\n  return Object.entries(profile.skill_usage)\n    .map(([skill, stats]) => ({ skill, stats }))\n    .sort((a, b) => b.stats.count - a.stats.count)\n    .slice(0, limit);\n}\n\n/**\n * Get top N used agents for a user\n */\nexport function getTopAgents(profile: UserProfile, limit: number = 5): Array<{\n  agent: string;\n  stats: UsageStats;\n}> {\n  return Object.entries(profile.agent_usage)\n    .map(([agent, stats]) => ({ agent, stats }))\n    .sort((a, b) => b.stats.count - a.stats.count)\n    .slice(0, limit);\n}\n\n/**\n * Get user's preferred tool for a category\n */\nexport function getPreferredTool(\n  profile: UserProfile,\n  category: string\n): string | undefined {\n  const pref = profile.preferences.find(p => p.category === category);\n  return pref?.preference;\n}\n\n/**\n * Get recent decisions for a user\n */\nexport function getRecentDecisions(\n  profile: UserProfile,\n  limit: number = 10\n): RecordedDecision[] {\n  return profile.decisions.slice(0, limit);\n}\n\n/**\n * Check if user has made a specific type of decision before\n */\nexport function hasDecisionAbout(\n  profile: UserProfile,\n  keyword: string\n): RecordedDecision | undefined {\n  const lower = keyword.toLowerCase();\n  return profile.decisions.find(\n    d =>\n      d.what.toLowerCase().includes(lower) ||\n      d.rationale?.toLowerCase().includes(lower)\n  );\n}\n\n// =============================================================================\n// PROFILE EXPORT (for sharing)\n// =============================================================================\n\n/**\n * Export profile for team sharing (respects privacy settings)\n */\nexport function exportForTeam(profile: UserProfile): Partial<UserProfile> {\n  return {\n    user_id: profile.user_id,\n    display_name: profile.display_name,\n    team_id: profile.team_id,\n    skill_usage: profile.skill_usage,\n    agent_usage: profile.agent_usage,\n    decisions: profile.decisions,\n    preferences: profile.preferences,\n  };\n}\n\n/**\n * Export profile for global sharing (anonymized)\n */\nexport function exportForGlobal(profile: UserProfile): {\n  anonymous_id: string;\n  decisions: Array<Omit<RecordedDecision, 'project'>>;\n  preferences: RecordedPreference[];\n} {\n  // Remove project info from decisions for privacy\n  const anonDecisions = profile.decisions.map(d => {\n    const { project, ...rest } = d;\n    return rest;\n  });\n\n  return {\n    anonymous_id: profile.anonymous_id,\n    decisions: anonDecisions,\n    preferences: profile.preferences,\n  };\n}\n", "/**\n * Profile Injector - UserPromptSubmit Hook (Phase 6.1)\n *\n * Loads user profile on first prompt of each session and injects personalized context.\n * Part of Issue #245: Multi-User Intelligent Decision Capture System.\n *\n * This hook runs ONCE per session (configured via `once: true` in hooks.json)\n * and provides Claude with user-specific context including:\n * - User display name\n * - Top skills used (by usage count)\n * - Top agents spawned (by usage count)\n * - Recent architectural decisions\n *\n * Context is kept compact (~200 tokens) to minimize overhead while providing\n * useful personalization hints.\n *\n * @module prompt/profile-injector\n *\n * Storage: ~/.claude/orchestkit/users/{user_id}/profile.json (cross-project)\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for injection\n *\n * @example Output format:\n * ```\n * ## User Profile Context\n * Working with **John** (42 sessions)\n *\n * **Preferred skills:** api-design-framework, fastapi-advanced, database-schema-designer\n *\n * **Frequently used agents:** backend-system-architect, database-engineer\n *\n * **Recent decisions:** Use cursor pagination for large datasets; Adopt clean architecture\n * ```\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputPromptContext, logHook } from '../lib/common.js';\nimport {\n  loadUserProfile,\n  getTopSkills,\n  getTopAgents,\n  getRecentDecisions,\n  type UserProfile,\n} from '../lib/user-profile.js';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/**\n * Maximum context length in characters.\n * Targets ~200 tokens (rough estimate: ~4 chars per token).\n */\nconst MAX_CONTEXT_CHARS = 800;\n\n/**\n * Number of top skills to include in context.\n */\nconst TOP_SKILLS_LIMIT = 3;\n\n/**\n * Number of top agents to include in context.\n */\nconst TOP_AGENTS_LIMIT = 3;\n\n/**\n * Number of recent decisions to include in context.\n */\nconst RECENT_DECISIONS_LIMIT = 2;\n\n/**\n * Maximum length for individual decision text before truncation.\n */\nconst MAX_DECISION_LENGTH = 50;\n\n/**\n * Number of top preferences to include in context.\n */\nconst TOP_PREFERENCES_LIMIT = 2;\n\n// =============================================================================\n// FORMATTERS\n// =============================================================================\n\n/**\n * Formats the user's top skills into a comma-separated string.\n *\n * @param profile - User profile containing skill usage data\n * @param limit - Maximum number of skills to include\n * @returns Comma-separated skill names, or empty string if none\n *\n * @example\n * // Returns: \"api-design-framework, fastapi-advanced, database-schema-designer\"\n * formatTopSkills(profile, 3);\n */\nfunction formatTopSkills(profile: UserProfile, limit: number = TOP_SKILLS_LIMIT): string {\n  const topSkills = getTopSkills(profile, limit);\n  if (topSkills.length === 0) return '';\n\n  return topSkills.map((s) => s.skill).join(', ');\n}\n\n/**\n * Formats the user's top agents into a comma-separated string.\n *\n * @param profile - User profile containing agent usage data\n * @param limit - Maximum number of agents to include\n * @returns Comma-separated agent names, or empty string if none\n *\n * @example\n * // Returns: \"backend-system-architect, database-engineer\"\n * formatTopAgents(profile, 2);\n */\nfunction formatTopAgents(profile: UserProfile, limit: number = TOP_AGENTS_LIMIT): string {\n  const topAgents = getTopAgents(profile, limit);\n  if (topAgents.length === 0) return '';\n\n  return topAgents.map((a) => a.agent).join(', ');\n}\n\n/**\n * Formats recent decisions into a semicolon-separated string.\n * Decision text is truncated if longer than MAX_DECISION_LENGTH.\n *\n * @param profile - User profile containing decision history\n * @param limit - Maximum number of decisions to include\n * @returns Semicolon-separated decision summaries, or empty string if none\n *\n * @example\n * // Returns: \"Use cursor pagination for large datasets; Adopt clean architecture\"\n * formatRecentDecisions(profile, 2);\n */\nfunction formatRecentDecisions(\n  profile: UserProfile,\n  limit: number = RECENT_DECISIONS_LIMIT\n): string {\n  const decisions = getRecentDecisions(profile, limit);\n  if (decisions.length === 0) return '';\n\n  return decisions\n    .map((d) => d.what)\n    .map((what) => (what.length > MAX_DECISION_LENGTH ? what.slice(0, MAX_DECISION_LENGTH - 3) + '...' : what))\n    .join('; ');\n}\n\n/**\n * Formats user preferences into a compact string.\n *\n * @param profile - User profile containing preferences\n * @param limit - Maximum number of preferences to include\n * @returns Comma-separated \"category: preference\" pairs, or empty string if none\n *\n * @example\n * // Returns: \"testing: pytest, database: PostgreSQL\"\n * formatPreferences(profile, 2);\n */\nfunction formatPreferences(profile: UserProfile, limit: number = TOP_PREFERENCES_LIMIT): string {\n  if (profile.preferences.length === 0) return '';\n\n  return profile.preferences\n    .slice(0, limit)\n    .map((p) => `${p.category}: ${p.preference}`)\n    .join(', ');\n}\n\n// =============================================================================\n// VALIDATION\n// =============================================================================\n\n/**\n * Checks if the user profile contains meaningful data worth injecting.\n * Returns false for completely new users with no activity.\n *\n * @param profile - User profile to validate\n * @returns true if profile has any meaningful data\n */\nfunction hasProfileData(profile: UserProfile): boolean {\n  return (\n    profile.sessions_count > 0 ||\n    Object.keys(profile.skill_usage).length > 0 ||\n    Object.keys(profile.agent_usage).length > 0 ||\n    profile.decisions.length > 0 ||\n    profile.preferences.length > 0\n  );\n}\n\n// =============================================================================\n// CONTEXT BUILDER\n// =============================================================================\n\n/**\n * Builds a personalized context message from the user profile.\n * The output is formatted as markdown and kept under MAX_CONTEXT_CHARS.\n *\n * Format:\n * ```\n * ## User Profile Context\n * Working with **[display_name]** ([N] sessions)\n *\n * **Preferred skills:** [skill1, skill2, skill3]\n *\n * **Frequently used agents:** [agent1, agent2]\n *\n * **Recent decisions:** [decision1; decision2]\n *\n * **Preferences:** [category1: pref1, category2: pref2]\n * ```\n *\n * @param profile - User profile to build context from\n * @returns Formatted markdown context string, truncated if necessary\n */\nfunction buildProfileContext(profile: UserProfile): string {\n  const parts: string[] = [];\n\n  // Header\n  parts.push('## User Profile Context\\n');\n\n  // User identification with session count\n  const name = profile.display_name || 'User';\n  if (profile.sessions_count > 0) {\n    parts.push(`Working with **${name}** (${profile.sessions_count} sessions)`);\n  } else {\n    parts.push(`Working with **${name}**`);\n  }\n\n  // Top skills\n  const skills = formatTopSkills(profile);\n  if (skills) {\n    parts.push(`\\n\\n**Preferred skills:** ${skills}`);\n  }\n\n  // Top agents\n  const agents = formatTopAgents(profile);\n  if (agents) {\n    parts.push(`\\n\\n**Frequently used agents:** ${agents}`);\n  }\n\n  // Recent decisions\n  const decisions = formatRecentDecisions(profile);\n  if (decisions) {\n    parts.push(`\\n\\n**Recent decisions:** ${decisions}`);\n  }\n\n  // Top preferences\n  const preferences = formatPreferences(profile);\n  if (preferences) {\n    parts.push(`\\n\\n**Preferences:** ${preferences}`);\n  }\n\n  let context = parts.join('');\n\n  // Truncate if exceeding budget\n  if (context.length > MAX_CONTEXT_CHARS) {\n    context = context.slice(0, MAX_CONTEXT_CHARS - 3) + '...';\n    logHook('profile-injector', `Context truncated to ${MAX_CONTEXT_CHARS} chars`, 'debug');\n  }\n\n  return context;\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Profile Injector Hook - Injects user profile context on first prompt.\n *\n * This hook is configured with `once: true` in hooks.json, ensuring it runs\n * only once per session (on the first UserPromptSubmit event).\n *\n * Behavior:\n * 1. Loads user profile from ~/.claude/orchestkit/users/{user_id}/profile.json\n * 2. Checks if profile has meaningful data\n * 3. Builds compact context string (~200 tokens)\n * 4. Injects via additionalContext (CC 2.1.9)\n *\n * Graceful degradation:\n * - Empty profile: Returns silent success (no injection)\n * - Load error: Logs warning and returns silent success\n * - Never crashes the hook chain\n *\n * @param _input - Hook input from Claude Code (prompt and session info)\n * @returns HookResult with additionalContext containing profile summary,\n *          or silent success if profile is empty/unavailable\n *\n * @example\n * // Hook is registered in hooks.json:\n * // {\n * //   \"type\": \"command\",\n * //   \"command\": \"node .../run-hook.mjs prompt/profile-injector\",\n * //   \"once\": true\n * // }\n */\nexport function profileInjector(_input: HookInput): HookResult {\n  logHook('profile-injector', 'Loading user profile for session context');\n\n  try {\n    // Load user profile (handles migration from legacy paths automatically)\n    const profile = loadUserProfile();\n\n    // Skip injection if profile is empty (new user with no history)\n    if (!hasProfileData(profile)) {\n      logHook('profile-injector', 'Empty profile, skipping injection', 'debug');\n      return outputSilentSuccess();\n    }\n\n    // Build personalized context message\n    const context = buildProfileContext(profile);\n\n    logHook(\n      'profile-injector',\n      `Injecting profile context for ${profile.display_name} (${context.length} chars)`,\n      'info'\n    );\n\n    // Inject via additionalContext (CC 2.1.9 compliant)\n    return outputPromptContext(context);\n  } catch (error) {\n    // Never crash the hook - fail gracefully and log warning\n    logHook('profile-injector', `Error loading profile: ${error}`, 'warn');\n    return outputSilentSuccess();\n  }\n}\n\n// =============================================================================\n// EXPORTS (for testing)\n// =============================================================================\n\nexport {\n  formatTopSkills,\n  formatTopAgents,\n  formatRecentDecisions,\n  formatPreferences,\n  hasProfileData,\n  buildProfileContext,\n  MAX_CONTEXT_CHARS,\n  TOP_SKILLS_LIMIT,\n  TOP_AGENTS_LIMIT,\n  RECENT_DECISIONS_LIMIT,\n};\n", "/**\n * Communication Style Tracker - UserPromptSubmit Hook\n * Detects user communication patterns to personalize interactions.\n * CC 2.1.7 Compliant\n *\n * Part of Issue #245: Multi-User Intelligent Decision Capture System (Phase 2.2)\n *\n * Detects:\n * - Verbosity: terse | moderate | detailed\n * - Interaction type: question | command | discussion\n * - Technical level: beginner | intermediate | expert\n *\n * Performance optimization:\n * - Sampling mode: only analyzes every Nth prompt to reduce overhead\n * - Configure via COMM_STYLE_SAMPLE_RATE (default: 5)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { trackCommunicationStyle } from '../lib/session-tracker.js';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\ntype Verbosity = 'terse' | 'moderate' | 'detailed';\ntype InteractionType = 'question' | 'command' | 'discussion';\ntype TechnicalLevel = 'beginner' | 'intermediate' | 'expert';\n\ninterface CommunicationStyle {\n  verbosity: Verbosity;\n  interaction_type: InteractionType;\n  technical_level: TechnicalLevel;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst HOOK_NAME = 'communication-style-tracker';\nconst MIN_PROMPT_LENGTH = 5;\n\n// Verbosity thresholds\nconst TERSE_MAX_LENGTH = 30;\nconst MODERATE_MAX_LENGTH = 150;\n\n// =============================================================================\n// DETECTION PATTERNS\n// =============================================================================\n\n// Question patterns\nconst QUESTION_PATTERNS = [\n  /^(how|what|why|when|where|which|who|can\\s+(you|i)|could\\s+(you|i)|would\\s+(you|i)|is\\s+(it|there|this)|are\\s+(there|these)|do\\s+(you|i)|does|should|will|has|have)\\b/i,\n  /\\?$/,\n  /\\b(explain|tell me|show me|help me understand)\\b/i,\n];\n\n// Command patterns (imperative verbs)\nconst COMMAND_PATTERNS = [\n  /^(fix|add|create|update|remove|delete|run|build|test|deploy|install|configure|set|get|make|write|read|edit|change|modify|implement|refactor)\\b/i,\n  /^(do|just|please|now|quickly)\\s+(fix|add|create|update|run|build)/i,\n  /^[a-z]+\\s+(it|this|that|the)\\b/i, // \"fix it\", \"run this\"\n];\n\n// Discussion patterns\nconst DISCUSSION_PATTERNS = [\n  /^(i think|i believe|maybe|perhaps|i was thinking|let's discuss|what if|consider|i'm wondering|could we|should we|might we)\\b/i,\n  /\\b(alternatively|on the other hand|however|but|although|pros and cons|trade-?off)\\b/i,\n  /\\b(in my experience|from what i've seen|generally|typically|usually)\\b/i,\n];\n\n// Beginner indicators\nconst BEGINNER_PATTERNS = [\n  /\\b(what (is|are|does)|how (do|does) .* work|explain|eli5|basics?|beginner|newbie|starter|learning|tutorial)\\b/i,\n  /\\b(i('m| am) (new|confused|stuck|lost)|don't understand|can you explain)\\b/i,\n  /\\b(step by step|for dummies|simple|easy)\\b/i,\n];\n\n// Expert indicators (technical jargon)\nconst EXPERT_PATTERNS = [\n  /\\b(idempoten|determin|memoiz|currying|monad|functor|polymorphi|closure|hoisting|prototype chain)\\b/i,\n  /\\b(HNSW|pgvector|FAISS|embeddings?|RAG|LLM|transformer|attention|tokeniz)\\b/i,\n  /\\b(sharding|partition|replica|consistency|CAP theorem|ACID|eventual consistency)\\b/i,\n  /\\b(microservic|kubernetes|k8s|helm|istio|service mesh|container orchestrat)\\b/i,\n  /\\b(cursor.based pagination|connection pool|deadlock|race condition|mutex|semaphore)\\b/i,\n  /\\b(dependency injection|inversion of control|SOLID|DRY|KISS|YAGNI)\\b/i,\n  /\\b(async|await|promise|observable|event.loop|coroutine|generator)\\b/i,\n  /\\b(O\\(n\\)|O\\(log n\\)|O\\(1\\)|big.?O|time complexity|space complexity)\\b/i,\n];\n\n// Intermediate indicators (common dev terms)\nconst INTERMEDIATE_PATTERNS = [\n  /\\b(API|REST|GraphQL|JWT|OAuth|middleware|endpoint|route|controller)\\b/i,\n  /\\b(component|hook|state|props|context|redux|store|dispatch)\\b/i,\n  /\\b(migration|schema|model|ORM|query|index|foreign key)\\b/i,\n  /\\b(unit test|integration test|e2e|mock|stub|fixture|coverage)\\b/i,\n  /\\b(git|branch|merge|rebase|commit|PR|pull request)\\b/i,\n];\n\n// =============================================================================\n// DETECTION LOGIC\n// =============================================================================\n\n/**\n * Detect verbosity level from prompt length and structure\n */\nfunction detectVerbosity(prompt: string): Verbosity {\n  const trimmed = prompt.trim();\n  const length = trimmed.length;\n\n  // Check for detailed indicators beyond just length\n  const hasMultipleSentences = (trimmed.match(/[.!?]\\s+[A-Z]/g) || []).length >= 2;\n  const hasExplanation = /\\b(because|since|so that|in order to|the reason)\\b/i.test(trimmed);\n  const hasContext = /\\b(context|background|currently|previously|before)\\b/i.test(trimmed);\n\n  if (length <= TERSE_MAX_LENGTH && !hasExplanation) {\n    return 'terse';\n  }\n\n  if (length > MODERATE_MAX_LENGTH || hasMultipleSentences || hasExplanation || hasContext) {\n    return 'detailed';\n  }\n\n  return 'moderate';\n}\n\n/**\n * Detect interaction type from prompt patterns\n */\nfunction detectInteractionType(prompt: string): InteractionType {\n  const trimmed = prompt.trim();\n\n  // Check discussion patterns first (they can be long questions)\n  for (const pattern of DISCUSSION_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      return 'discussion';\n    }\n  }\n\n  // Check question patterns\n  for (const pattern of QUESTION_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      return 'question';\n    }\n  }\n\n  // Check command patterns\n  for (const pattern of COMMAND_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      return 'command';\n    }\n  }\n\n  // Default based on length - short is command, long is discussion\n  if (trimmed.length < 50) {\n    return 'command';\n  }\n\n  return 'discussion';\n}\n\n/**\n * Detect technical level from vocabulary and patterns\n */\nfunction detectTechnicalLevel(prompt: string): TechnicalLevel {\n  const trimmed = prompt.trim();\n\n  // Count matches for each level\n  let beginnerScore = 0;\n  let intermediateScore = 0;\n  let expertScore = 0;\n\n  // Check beginner patterns\n  for (const pattern of BEGINNER_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      beginnerScore += 2;\n    }\n  }\n\n  // Check expert patterns\n  for (const pattern of EXPERT_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      expertScore += 2;\n    }\n  }\n\n  // Check intermediate patterns\n  for (const pattern of INTERMEDIATE_PATTERNS) {\n    if (pattern.test(trimmed)) {\n      intermediateScore += 1;\n    }\n  }\n\n  // Terse commands with no questions often indicate expert\n  if (trimmed.length < 40 && !trimmed.includes('?') && detectInteractionType(trimmed) === 'command') {\n    expertScore += 1;\n  }\n\n  // Determine level based on scores\n  if (beginnerScore > expertScore && beginnerScore > intermediateScore) {\n    return 'beginner';\n  }\n\n  if (expertScore >= 2 || (expertScore > 0 && intermediateScore >= 2)) {\n    return 'expert';\n  }\n\n  if (intermediateScore >= 2 || expertScore > 0) {\n    return 'intermediate';\n  }\n\n  // Default to intermediate for ambiguous cases\n  return 'intermediate';\n}\n\n/**\n * Detect full communication style\n */\nfunction detectCommunicationStyle(prompt: string): CommunicationStyle {\n  return {\n    verbosity: detectVerbosity(prompt),\n    interaction_type: detectInteractionType(prompt),\n    technical_level: detectTechnicalLevel(prompt),\n  };\n}\n\n// =============================================================================\n// SAMPLING\n// =============================================================================\n\n/**\n * Get counter file path\n */\nfunction getCounterFilePath(projectDir: string): string {\n  return join(projectDir, '.claude', '.comm-style-counter');\n}\n\n/**\n * Get and increment counter for sampling\n */\nfunction getAndIncrementCounter(projectDir: string): number {\n  const counterFile = getCounterFilePath(projectDir);\n\n  // Ensure directory exists\n  const dir = dirname(counterFile);\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n\n  let counter = 0;\n  if (existsSync(counterFile)) {\n    try {\n      counter = parseInt(readFileSync(counterFile, 'utf8').trim(), 10) || 0;\n    } catch {\n      // Ignore\n    }\n  }\n\n  counter++;\n\n  try {\n    writeFileSync(counterFile, String(counter));\n  } catch {\n    // Ignore\n  }\n\n  return counter;\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Communication style tracker hook\n *\n * Analyzes user prompts to detect communication patterns and stores them\n * in the user profile for personalized interactions.\n */\nexport function communicationStyleTracker(input: HookInput): HookResult {\n  const prompt = input.prompt || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Get sample rate from environment (default: 5 - analyze every 5th prompt)\n  const sampleRate = parseInt(process.env.COMM_STYLE_SAMPLE_RATE || '5', 10);\n\n  // Get and increment counter for sampling\n  const counter = getAndIncrementCounter(projectDir);\n\n  // Skip if not on sampling interval (for performance)\n  if (sampleRate > 1 && counter % sampleRate !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook(HOOK_NAME, `Analyzing communication style (sample ${counter})`);\n\n  // Skip empty or very short prompts\n  if (!prompt || prompt.length < MIN_PROMPT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Skip prompts that look like commands (start with /)\n  if (prompt.startsWith('/')) {\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Detect communication style\n    const style = detectCommunicationStyle(prompt);\n\n    // Track in session tracker for user profile aggregation\n    trackCommunicationStyle(style);\n\n    logHook(\n      HOOK_NAME,\n      `Detected: verbosity=${style.verbosity}, type=${style.interaction_type}, level=${style.technical_level}`\n    );\n  } catch (error) {\n    // Never crash the hook chain\n    logHook(HOOK_NAME, `Error tracking communication style: ${error}`, 'warn');\n  }\n\n  return outputSilentSuccess();\n}\n\n// =============================================================================\n// EXPORTS (for testing)\n// =============================================================================\n\nexport {\n  detectVerbosity,\n  detectInteractionType,\n  detectTechnicalLevel,\n  detectCommunicationStyle,\n  type CommunicationStyle,\n  type Verbosity,\n  type InteractionType,\n  type TechnicalLevel,\n  TERSE_MAX_LENGTH,\n  MODERATE_MAX_LENGTH,\n};\n", "/**\n * Prompt Hooks Entry Point\n *\n * Hooks that run on user prompt submission (UserPromptSubmit)\n * Bundle: prompt.mjs (~35 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\n\n// Re-export orchestration modules needed by prompt hooks\nexport * from '../lib/orchestration-types.js';\nexport * from '../lib/intent-classifier.js';\nexport * from '../lib/orchestration-state.js';\nexport * from '../lib/task-integration.js';\nexport * from '../lib/retry-manager.js';\nexport * from '../lib/calibration-engine.js';\nexport * from '../lib/multi-agent-coordinator.js';\n\n// Prompt hooks (11) - UserPromptSubmit\nimport { antipatternDetector } from '../prompt/antipattern-detector.js';\nimport { antipatternWarning } from '../prompt/antipattern-warning.js';\nimport { contextInjector } from '../prompt/context-injector.js';\nimport { contextPruningAdvisor } from '../prompt/context-pruning-advisor.js';\nimport { memoryContext } from '../prompt/memory-context.js';\nimport { satisfactionDetector } from '../prompt/satisfaction-detector.js';\nimport { todoEnforcer } from '../prompt/todo-enforcer.js';\nimport { agentAutoSuggest } from '../prompt/agent-auto-suggest.js';\n\n// Orchestration hooks (Issue #197)\nimport { agentOrchestrator } from '../prompt/agent-orchestrator.js';\nimport { pipelineDetector } from '../prompt/pipeline-detector.js';\n\n// Unified skill resolver (replaces skill-auto-suggest + skill-injector)\nimport { skillResolver } from '../prompt/skill-resolver.js';\n\n// Intelligent Decision Capture System (Issue #245)\nimport { captureUserIntent } from '../prompt/capture-user-intent.js';\n\n// Profile Injection (Issue #245 Phase 6.1)\nimport { profileInjector } from '../prompt/profile-injector.js';\n\n// Communication Style Tracker (Issue #245 Phase 2.2)\nimport { communicationStyleTracker } from '../prompt/communication-style-tracker.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Prompt hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'prompt/antipattern-detector': antipatternDetector,\n  'prompt/antipattern-warning': antipatternWarning,\n  'prompt/context-injector': contextInjector,\n  'prompt/context-pruning-advisor': contextPruningAdvisor,\n  'prompt/memory-context': memoryContext,\n  'prompt/satisfaction-detector': satisfactionDetector,\n  'prompt/todo-enforcer': todoEnforcer,\n  'prompt/agent-auto-suggest': agentAutoSuggest,\n  // Orchestration hooks (Issue #197)\n  'prompt/agent-orchestrator': agentOrchestrator,\n  'prompt/pipeline-detector': pipelineDetector,\n  // Unified skill resolver (replaces skill-auto-suggest + skill-injector)\n  'prompt/skill-resolver': skillResolver,\n  // Intelligent Decision Capture System\n  'prompt/capture-user-intent': captureUserIntent,\n  // Profile Injection (Issue #245 Phase 6.1)\n  'prompt/profile-injector': profileInjector,\n  // Communication Style Tracker (Issue #245 Phase 2.2)\n  'prompt/communication-style-tracker': communicationStyleTracker,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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,0BAA2B,8BAA8B5B,EAAe,KAAK,IAAI,CAAC,EAAE,EAG5F,IAAMoB,EAAaD,GAAoBJ,EAAOf,CAAc,EAE5D,GAAIoB,EAAW,OAAS,EAAG,CACzB,IAAM6B,EAAUlB,GAA2BX,CAAU,EACrD,OAAAQ,EACE,0BACA,gBAAgBR,EAAW,MAAM,qBACnC,EACO4B,EAAoBC,CAAO,CACpC,CAEA,OAAOH,EAAoB,CAC7B,CCtTA,OAAS,cAAAI,GAAY,gBAAAC,OAAoB,UACzC,OAAS,QAAAC,OAAY,YAGrB,IAAMC,GAA0B,CAC9B,MACA,YACA,SACA,QACA,SACA,WACA,SACA,SACA,MACA,SACA,WACA,SACA,WACA,WACA,YACA,SACA,UACA,UACA,WACA,aACA,aACF,EAGMC,GAAyB,CAC7B,eACA,UACA,YACA,UACA,OACA,aACA,uBACA,qBACF,EAGMC,GAAoB,GAK1B,SAASC,GAAmBC,EAAyB,CACnD,IAAMC,EAAcD,EAAO,YAAY,EAEvC,QAAWE,KAAWN,GACpB,GAAIK,EAAY,SAASC,CAAO,EAC9B,MAAO,GAIX,MAAO,EACT,CAKA,SAASC,GAAgBH,EAAyB,CAChD,IAAMC,EAAcD,EAAO,YAAY,EAEvC,QAAWE,KAAWL,GACpB,GAAI,IAAI,OAAOK,EAAS,GAAG,EAAE,KAAKD,CAAW,EAC3C,MAAO,GAIX,MAAO,EACT,CAKA,SAASG,GAAmBJ,EAAwB,CAClD,IAAMK,EAAY,IAAI,IAAI,CACxB,MACA,IACA,KACA,KACA,MACA,KACA,KACA,KACA,KACA,MACA,MACA,OACA,KACA,OACA,QACA,OACA,MACA,MACA,KACA,OACA,MACA,OACA,QACA,QACA,SACA,MACA,MACA,QACA,OACA,QACA,IACA,MACA,KACA,OACA,KACA,OACA,OACA,QACA,QACA,KACA,OACA,MACA,QACA,MACA,MACA,KACA,MACA,KACA,OACA,OACA,OACA,QACA,MACA,OACA,QACA,MACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,SACA,QACF,CAAC,EASD,OAPcL,EACX,YAAY,EACZ,QAAQ,YAAa,GAAG,EACxB,MAAM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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "execSync", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "getCachedBranch", "projectDir", "branch", "getLogLevel", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "estimateTokenCount", "content", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "readHookInput", "chunks", "buf", "bytesRead", "fd", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "THRESHOLDS", "DEFAULT_CONFIG", "existsSync", "readFileSync", "readdirSync", "join", "SIGNAL_WEIGHTS", "NEGATION_PATTERNS", "CONTEXT_BOOST_KEYWORDS", "agentIndex", "agentIndexPath", "getAgentIndex", "agentsDir", "index", "files", "readdirSync", "f", "file", "agentName", "filePath", "join", "frontmatterMatch", "readFileSync", "frontmatter", "descMatch", "description", "activatesMatch", "descPart", "keywords", "phrases", "rawKeywords", "kw", "skillsMatch", "skills", "l", "logHook", "skillIndex", "skillIndexPath", "getSkillIndex", "skillsDir", "dirs", "d", "skillName", "skillFile", "existsSync", "tagsMatch", "t", "descKeywords", "w", "calculateKeywordScore", "promptLower", "score", "matched", "signals", "keyword", "weight", "maxScore", "calculatePhraseScore", "phrase", "calculateContextScore", "history", "continuationWord", "recentHistory", "calculateNegationPenalty", "prompt", "penalty", "pattern", "applyCalibration", "matchedKeywords", "adjustments", "totalAdjustment", "adj", "classifyAgentMatch", "entry", "allSignals", "allMatched", "keywordResult", "phraseResult", "contextResult", "negationResult", "calibrationResult", "THRESHOLDS", "classifySkillMatch", "classifyIntent", "pluginRoot", "getPluginRoot", "agentMatches", "skillMatches", "agentIdx", "match", "skillIdx", "a", "b", "topAgent", "intent", "categorizeIntent", "maxConfidence", "shouldAutoDispatch", "shouldInjectSkills", "agent", "categories", "category", "categoryKeywords", "shouldClassify", "clearCache", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "ensureStateDir", "dir", "existsSync", "mkdirSync", "logHook", "loadState", "stateFile", "data", "readFileSync", "err", "saveState", "state", "writeFileSync", "updateState", "mutate", "trackDispatchedAgent", "agent", "confidence", "taskId", "dispatched", "a", "updateAgentStatus", "status", "entry", "removeAgent", "getActiveAgent", "isAgentDispatched", "trackInjectedSkill", "skill", "isSkillInjected", "getInjectedSkills", "addToPromptHistory", "prompt", "getPromptHistory", "cacheClassification", "result", "getLastClassification", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "saveConfig", "config", "merged", "clearSessionState", "unlinkSync", "cleanupOldStates", "readdirSync", "statSync", "files", "f", "b", "file", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadRegistry", "file", "readFileSync", "saveRegistry", "registry", "writeFileSync", "err", "logHook", "getActiveFormForAgent", "agent", "description", "action", "shortDesc", "generateTaskCreateInstruction", "confidence", "metadata", "agentTitle", "w", "fullMetadata", "generateTaskUpdateInstruction", "taskId", "status", "blockedBy", "blocks", "instruction", "formatTaskCreateForClaude", "generateTaskDeleteInstruction", "_reason", "formatTaskDeleteForClaude", "reason", "formatTaskUpdateForClaude", "md", "registerTask", "pipelineId", "pipelineStep", "t", "updateTaskStatus", "task", "getTaskByAgent", "getTaskById", "getTasksBlockedBy", "failedTaskId", "getOrphanedTasks", "failedIds", "id", "getPipelineTasks", "a", "b", "registerPipeline", "pipeline", "p", "updatePipeline", "updates", "getActivePipeline", "completePipelineStep", "step", "tasks", "taskStep", "cleanupOldTasks", "maxAgeMs", "cutoff", "DEFAULT_MAX_RETRIES", "DEFAULT_BASE_DELAY_MS", "MAX_DELAY_MS", "ALTERNATIVE_AGENTS", "NON_RETRYABLE_ERRORS", "ALTERNATIVE_SUGGESTING_ERRORS", "calculateBackoffDelay", "attemptNumber", "baseDelayMs", "exponentialDelay", "jitter", "isRetryableError", "error", "pattern", "suggestsAlternative", "getAlternativeAgent", "agent", "triedAgents", "alternatives", "alt", "makeRetryDecision", "maxRetries", "logHook", "alternative", "delayMs", "createAttempt", "taskId", "completeAttempt", "attempt", "outcome", "completedAt", "durationMs", "analyzeAttemptHistory", "attempts", "successRate", "durations", "avgDuration", "b", "errorCounts", "normalized", "commonErrors", "prepareForRetry", "decision", "formatRetryDecision", "message", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MIN_SAMPLES_FOR_ADJUSTMENT", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "DECAY_FACTOR", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "keyword", "existing", "applyDecay", "now", "dayMs", "adj", "age", "a", "records", "successful", "r", "avgConf", "sum", "agentStats", "stat", "b", "getAdjustments", "getAgentSuccessRate", "agentRecords", "getCalibrationStats", "hasMinimalCalibrationData", "PIPELINES", "detectPipeline", "prompt", "promptLower", "pipeline", "trigger", "logHook", "getPipelineByType", "type", "p", "createPipelineExecution", "pipelineId", "tasks", "taskIds", "i", "step", "taskId", "metadata", "blockedBy", "dep", "registerPipelineExecution", "execution", "registerPipeline", "task", "registerTask", "formatPipelinePlan", "md", "deps", "d", "IMPLEMENTATION_KEYWORDS", "detectCategory", "prompt", "promptLower", "getMem0UserId", "scope", "projectDir", "getGlobalUserId", "antipatternDetector", "input", "getProjectDir", "outputSilentSuccess", "matchedKeyword", "keyword", "logHook", "category", "projectUserId", "globalUserId", "existsSync", "readFileSync", "join", "IMPLEMENTATION_KEYWORDS", "KNOWN_ANTIPATTERNS", "isImplementationPrompt", "prompt", "promptLower", "keyword", "detectCategory", "searchLocalAntipatterns", "projectDir", "warnings", "pattern", "warning", "patternsFile", "failedPatterns", "p", "firstWord", "globalPatternsFile", "data", "getMem0UserId", "scope", "buildMem0SearchHint", "category", "userId", "antipatternWarning", "input", "getProjectDir", "outputSilentSuccess", "logHook", "mem0SearchHints", "warningMessage", "w", "outputPromptContext", "existsSync", "join", "contextInjector", "input", "prompt", "projectDir", "getProjectDir", "logHook", "contextHints", "issueDocsDir", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "CONTEXT_TRIGGER", "CONTEXT_CRITICAL", "PRUNE_THRESHOLD_HIGH", "PRUNE_THRESHOLD_MED", "MAX_RECOMMENDATIONS", "calculateRecencyScore", "lastAccessed", "currentTime", "lastEpoch", "ageMinutes", "calculateFrequencyScore", "count", "calculateRelevanceScore", "itemKeywords", "promptKeywords", "itemSet", "k", "promptSet", "overlap", "keyword", "overlapRatio", "extractPromptKeywords", "prompt", "stopwords", "word", "getStateFilePath", "getSessionId", "loadOrInitState", "stateFile", "state", "getContextUsagePercentage", "envPercent", "parsed", "analyzeAndRecommend", "candidates", "item", "accessCount", "keywords", "recencyScore", "frequencyScore", "relevanceScore", "totalScore", "logHook", "a", "b", "buildRecommendationMessage", "totalSavings", "lines", "i", "priority", "itemId", "score", "tokens", "displayName", "contextPruningAdvisor", "input", "projectDir", "getProjectDir", "logDir", "contextUsage", "outputSilentSuccess", "criticalMsg", "outputPromptContext", "message", "existsSync", "readFileSync", "join", "MEMORY_TRIGGER_KEYWORDS", "GRAPH_TRIGGER_KEYWORDS", "MIN_PROMPT_LENGTH", "shouldSearchMemory", "prompt", "promptLower", "keyword", "hasGraphTrigger", "extractSearchTerms", "stopwords", "word", "getMem0UserId", "scope", "projectDir", "getAgentContext", "agentId", "trackingFile", "memoryContext", "input", "getProjectDir", "isMem0Available", "logHook", "outputSilentSuccess", "useGlobal", "useGraph", "agentContext", "searchTerms", "scopeDesc", "userIdDecisions", "systemMsg", "existsSync", "appendFileSync", "mkdirSync", "readFileSync", "readdirSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "createHash", "os", "IDENTITY_CONFIG_FILE", "SALT", "cachedIdentity", "generateAnonymousId", "input", "createHash", "SALT", "getMachineId", "readUserConfig", "projectDir", "configPath", "IDENTITY_CONFIG_FILE", "existsSync", "content", "readFileSync", "error", "logHook", "getGitIdentity", "result", "execSync", "getEnvIdentity", "resolveUserIdentity", "cachedIdentity", "dir", "getProjectDir", "machineId", "config", "git", "env", "userId", "anonId", "getIdentityContext", "identity", "resolveUserIdentity", "getSessionId", "SESSION_ID_PATTERN", "isValidSessionId", "sessionId", "getSessionDir", "sid", "getSessionId", "getProjectDir", "getEventsPath", "ensureSessionDir", "dir", "existsSync", "mkdirSync", "eventCounter", "generateEventId", "trackEvent", "eventType", "name", "options", "event", "getIdentityContext", "sanitizeForStorage", "truncate", "eventsPath", "appendFileSync", "logHook", "error", "trackDecisionMade", "decision", "rationale", "confidence", "trackEvent", "trackPreferenceStated", "preference", "trackProblemReported", "problem", "trackCommunicationStyle", "style", "trackEvent", "truncate", "str", "maxLen", "sanitizeForStorage", "obj", "sanitized", "sensitiveKeys", "key", "value", "existsSync", "readFileSync", "writeFileSync", "appendFileSync", "mkdirSync", "join", "dirname", "MIN_PROMPT_LENGTH", "POSITIVE_PATTERNS", "NEGATIVE_PATTERNS", "detectSatisfaction", "prompt", "pattern", "getCounterFilePath", "projectDir", "getAndIncrementCounter", "counterFile", "dir", "counter", "logSatisfaction", "sessionId", "sentiment", "context", "feedbackDir", "logFile", "logEntry", "satisfactionDetector", "input", "getProjectDir", "getSessionId", "sampleRate", "outputSilentSuccess", "logHook", "trackEvent", "COMPLEX_PATTERNS", "LONG_PROMPT_THRESHOLD", "todoEnforcer", "input", "prompt", "promptLength", "logHook", "isComplex", "pattern", "outputSilentSuccess", "MAX_SUGGESTIONS", "buildSuggestionMessage", "matches", "topMatch", "message", "THRESHOLDS", "second", "agentAutoSuggest", "input", "prompt", "shouldClassify", "outputSilentSuccess", "loadConfig", "logHook", "history", "getPromptHistory", "adjustments", "getAdjustments", "classifyIntent", "m", "suggestionMessage", "outputPromptContext", "buildAutoDispatchMessage", "match", "taskMeta", "THRESHOLDS", "buildStrongRecommendMessage", "buildSuggestionMessage", "buildAlternativeNote", "buildOrchestrationMessage", "result", "config", "topMatch", "message", "isAgentDispatched", "logHook", "trackDispatchedAgent", "agentOrchestrator", "input", "prompt", "shouldClassify", "outputSilentSuccess", "loadConfig", "history", "getPromptHistory", "classifyIntent", "cacheClassification", "addToPromptHistory", "a", "outputPromptContext", "MIN_PROMPT_LENGTH", "EXCLUSION_WORDS", "isQuestionNotRequest", "prompt", "promptLower", "exclusion", "isInActivePipeline", "active", "getActivePipeline", "pipelineDetector", "input", "outputSilentSuccess", "loadConfig", "logHook", "pipeline", "detectPipeline", "execution", "tasks", "createPipelineExecution", "registerPipelineExecution", "message", "formatPipelinePlan", "outputPromptContext", "existsSync", "readFileSync", "join", "MAX_SUGGESTIONS", "KEYWORD_MAPPINGS", "findMatchingSkills", "prompt", "promptLower", "skillScores", "keyword", "skill", "confidence", "currentScore", "a", "b", "MAX_SUGGESTIONS", "MAX_INJECTION_TOKENS", "MAX_FULL_INJECT", "MAX_SUGGESTIONS", "TIER_FULL", "TIER_SUMMARY", "TIER_HINT", "loadCompressedSkillContent", "skillName", "maxTokens", "pluginRoot", "getPluginRoot", "skillFile", "join", "existsSync", "logHook", "content", "readFileSync", "frontmatterMatch", "block", "lines", "maxChars", "truncated", "lastParagraph", "err", "getSkillDescription", "descMatch", "extractKeyBullets", "bullets", "headings", "h", "text", "buildHintMessage", "skills", "s", "buildSummaryMessage", "message", "skill", "confidence", "desc", "b", "buildFullInjectionMessage", "skillResolver", "input", "prompt", "shouldClassify", "outputSilentSuccess", "config", "loadConfig", "result", "getLastClassification", "classifyIntent", "keywordMatches", "findMatchingSkills", "allSkills", "mergeSkillMatches", "fullTier", "summaryTier", "hintTier", "parts", "maxTotalTokens", "skillCount", "tokensPerSkill", "loadedSkills", "totalTokens", "match", "isSkillInjected", "remainingTokens", "tokens", "estimateTokenCount", "trackInjectedSkill", "summarySkills", "hintSkills", "outputPromptContext", "classifierMatches", "map", "m", "current", "a", "DECISION_PATTERNS", "PREFERENCE_PATTERNS", "PROBLEM_PATTERNS", "QUESTION_PATTERNS", "RATIONALE_PATTERNS", "KNOWN_TECHNOLOGIES", "KNOWN_PATTERNS", "KNOWN_TOOLS", "extractEntities", "text", "textLower", "entities", "tech", "pattern", "normalized", "tool", "extractRationale", "matchIndex", "windowStart", "windowEnd", "window", "match", "calculateConfidence", "matchText", "hasRationale", "hasAlternatives", "entityCount", "confidence", "detectUserIntent", "prompt", "intents", "matches", "position", "choice", "alternatives", "rationale", "uniqueIntents", "deduplicateIntents", "decisions", "i", "preferences", "problems", "questions", "summary", "buildSummary", "sorted", "a", "b", "result", "intent", "existing", "existingEnd", "intentEnd", "overlappingIndex", "parts", "existsSync", "appendFileSync", "mkdirSync", "join", "dirname", "HOOK_NAME", "MIN_PROMPT_LENGTH", "MIN_CONFIDENCE_FOR_STORAGE", "generateId", "prefix", "timestamp", "random", "getProjectName", "getProjectDir", "appendToJsonl", "filePath", "record", "dir", "line", "err", "logHook", "storeDecisions", "decisions", "sessionId", "projectDir", "project", "stored", "decision", "storePreferences", "preferences", "pref", "storeProblems", "problems", "problem", "trackIntentsInSession", "result", "trackDecisionMade", "preference", "trackPreferenceStated", "trackProblemReported", "captureUserIntent", "input", "prompt", "outputSilentSuccess", "getSessionId", "detectUserIntent", "decisionsStored", "preferencesStored", "problemsStored", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "PROFILE_VERSION", "getHomeDir", "getOrchestKitDir", "join", "getUserProfileDir", "userId", "sanitizedUserId", "getUserProfilePath", "getLegacyProfilePath", "getProjectDir", "migrateProfileIfNeeded", "legacyPath", "newPath", "existsSync", "newDir", "dirname", "mkdirSync", "content", "readFileSync", "profile", "writeFileSync", "logHook", "error", "createEmptyProfile", "identity", "resolveUserIdentity", "now", "PROFILE_VERSION", "loadUserProfile", "uid", "profilePath", "getTopSkills", "profile", "limit", "skill", "stats", "a", "b", "getTopAgents", "agent", "getRecentDecisions", "profile", "limit", "MAX_CONTEXT_CHARS", "TOP_SKILLS_LIMIT", "TOP_AGENTS_LIMIT", "RECENT_DECISIONS_LIMIT", "MAX_DECISION_LENGTH", "TOP_PREFERENCES_LIMIT", "formatTopSkills", "profile", "limit", "topSkills", "getTopSkills", "s", "formatTopAgents", "topAgents", "getTopAgents", "a", "formatRecentDecisions", "decisions", "getRecentDecisions", "d", "what", "formatPreferences", "p", "hasProfileData", "buildProfileContext", "parts", "name", "skills", "agents", "preferences", "context", "logHook", "profileInjector", "_input", "loadUserProfile", "outputSilentSuccess", "outputPromptContext", "error", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "HOOK_NAME", "MIN_PROMPT_LENGTH", "TERSE_MAX_LENGTH", "MODERATE_MAX_LENGTH", "QUESTION_PATTERNS", "COMMAND_PATTERNS", "DISCUSSION_PATTERNS", "BEGINNER_PATTERNS", "EXPERT_PATTERNS", "INTERMEDIATE_PATTERNS", "detectVerbosity", "prompt", "trimmed", "length", "hasMultipleSentences", "hasExplanation", "hasContext", "detectInteractionType", "pattern", "detectTechnicalLevel", "beginnerScore", "intermediateScore", "expertScore", "detectCommunicationStyle", "getCounterFilePath", "projectDir", "getAndIncrementCounter", "counterFile", "dir", "counter", "communicationStyleTracker", "input", "getProjectDir", "sampleRate", "outputSilentSuccess", "logHook", "style", "trackCommunicationStyle", "error", "hooks", "antipatternDetector", "antipatternWarning", "contextInjector", "contextPruningAdvisor", "memoryContext", "satisfactionDetector", "todoEnforcer", "agentAutoSuggest", "agentOrchestrator", "pipelineDetector", "skillResolver", "captureUserIntent", "profileInjector", "communicationStyleTracker", "getHook", "name", "listHooks"]
}
