{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/git.ts", "../src/posttool/audit-logger.ts", "../src/posttool/unified-error-handler.ts", "../src/posttool/auto-lint.ts", "../src/posttool/context-budget-monitor.ts", "../src/posttool/coordination-heartbeat.ts", "../src/posttool/mem0-webhook-handler.ts", "../src/posttool/memory-bridge.ts", "../src/posttool/realtime-sync.ts", "../src/lib/session-tracker.ts", "../src/lib/user-identity.ts", "../src/lib/tool-categories.ts", "../src/posttool/user-tracking.ts", "../src/posttool/session-metrics.ts", "../src/posttool/skill-edit-tracker.ts", "../src/lib/calibration-engine.ts", "../src/lib/task-integration.ts", "../src/lib/orchestration-state.ts", "../src/posttool/calibration-tracker.ts", "../src/posttool/bash/pattern-extractor.ts", "../src/posttool/write/code-style-learner.ts", "../src/posttool/write/naming-convention-learner.ts", "../src/posttool/skill/skill-usage-optimizer.ts", "../src/posttool/bash/issue-progress-commenter.ts", "../src/posttool/bash/issue-subtask-updater.ts", "../src/posttool/unified-dispatcher.ts", "../src/posttool/write/coverage-predictor.ts", "../src/posttool/write/readme-sync.ts", "../src/posttool/write/release-lock-on-commit.ts", "../src/posttool/write-edit/file-lock-release.ts", "../src/lib/problem-tracker.ts", "../src/posttool/solution-detector.ts", "../src/posttool/tool-preference-learner.ts", "../src/entries/posttool.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME || process.env.USERPROFILE || '/tmp'}/.claude/logs/ork`;\n  }\n  return `${getProjectDir()}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n * Read dynamically to support testing\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory\n * Read dynamically to support testing\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability, but we add\n * a defensive fallback to prevent hook crashes during edge cases.\n * Read dynamically to support testing.\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}-${Date.now()}`;\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker && budgetChecker.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Git utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh git functions\n */\n\nimport { execSync } from 'node:child_process';\nimport { getProjectDir } from './common.js';\n\n/**\n * Get the current git branch\n */\nexport function getCurrentBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Check if on a protected branch (dev, main, master)\n */\nexport function isProtectedBranch(branch?: string): boolean {\n  const currentBranch = branch || getCurrentBranch();\n  return ['dev', 'main', 'master'].includes(currentBranch);\n}\n\n/**\n * Get the repository root directory\n */\nexport function getRepoRoot(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return dir;\n  }\n}\n\n/**\n * Check if path is inside a git repository\n */\nexport function isGitRepo(projectDir?: string): boolean {\n  const dir = projectDir || getProjectDir();\n  try {\n    execSync('git rev-parse --git-dir', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get git status (short format)\n */\nexport function getGitStatus(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git status --short', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Check if there are uncommitted changes\n */\nexport function hasUncommittedChanges(projectDir?: string): boolean {\n  return getGitStatus(projectDir).length > 0;\n}\n\n/**\n * Get the default branch (main or master)\n */\nexport function getDefaultBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    // Check if 'main' exists\n    execSync('git rev-parse --verify main', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return 'main';\n  } catch {\n    try {\n      // Check if 'master' exists\n      execSync('git rev-parse --verify master', {\n        cwd: dir,\n        encoding: 'utf8',\n        timeout: 5000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n      return 'master';\n    } catch {\n      return 'main'; // Default to main\n    }\n  }\n}\n\n/**\n * Extract issue number from branch name\n * Supports patterns like: issue/123-description, feature/123, fix-123\n */\nexport function extractIssueNumber(branch: string): number | null {\n  // Match common patterns\n  const patterns = [\n    /issue\\/(\\d+)/i,\n    /feature\\/(\\d+)/i,\n    /fix\\/(\\d+)/i,\n    /bug\\/(\\d+)/i,\n    /feat\\/(\\d+)/i,\n    /^(\\d+)-/,\n    /-(\\d+)$/,\n    /#(\\d+)/,\n  ];\n\n  for (const pattern of patterns) {\n    const match = branch.match(pattern);\n    if (match) {\n      return parseInt(match[1], 10);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Validate branch name format\n * Returns error message if invalid, null if valid\n */\nexport function validateBranchName(branch: string): string | null {\n  // Skip validation for protected branches\n  if (isProtectedBranch(branch)) {\n    return null;\n  }\n\n  // Valid prefixes\n  const validPrefixes = [\n    'issue/',\n    'feature/',\n    'fix/',\n    'bug/',\n    'feat/',\n    'chore/',\n    'docs/',\n    'refactor/',\n    'test/',\n    'ci/',\n    'perf/',\n    'style/',\n    'release/',\n    'hotfix/',\n  ];\n\n  const hasValidPrefix = validPrefixes.some((prefix) => branch.startsWith(prefix));\n  if (!hasValidPrefix) {\n    return `Branch name should start with a valid prefix: ${validPrefixes.join(', ')}`;\n  }\n\n  // Check for issue number in issue/ branches\n  if (branch.startsWith('issue/') && !extractIssueNumber(branch)) {\n    return 'issue/ branches should include an issue number (e.g., issue/123-description)';\n  }\n\n  return null;\n}\n", "/**\n * Audit Logger - Logs all tool executions for audit trail\n * Hook: PostToolUse (*)\n * CC 2.1.7 Compliant\n */\n\nimport { appendFileSync, existsSync, mkdirSync, statSync, renameSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir, getField } from '../lib/common.js';\n\n// Track read count across invocations (per-session in memory)\nconst readCountFile = '/tmp/claude-read-count';\n\n/**\n * Log tool execution to audit file\n */\nexport function auditLogger(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Skip logging for high-frequency read operations to reduce noise\n  if (['Read', 'Glob', 'Grep'].includes(toolName)) {\n    try {\n      const { readFileSync, writeFileSync } = require('node:fs');\n      let readCount = 0;\n      try {\n        readCount = parseInt(readFileSync(readCountFile, 'utf8').trim(), 10) || 0;\n      } catch {\n        // File doesn't exist yet\n      }\n      readCount++;\n      writeFileSync(readCountFile, String(readCount));\n\n      if (readCount % 10 !== 0) {\n        return outputSilentSuccess();\n      }\n    } catch {\n      // Ignore count tracking errors\n    }\n  }\n\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || '.';\n  const auditLog = `${projectDir}/.claude/logs/audit.log`;\n\n  try {\n    // Ensure log directory exists\n    const logDir = `${projectDir}/.claude/logs`;\n    if (!existsSync(logDir)) {\n      mkdirSync(logDir, { recursive: true });\n    }\n\n    // Rotate if needed (200KB limit)\n    rotateLogFile(auditLog, 200 * 1024);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n\n    // Get relevant details based on tool type\n    let details = '';\n    switch (toolName) {\n      case 'Bash': {\n        const cmd = getField<string>(input, 'tool_input.command') || '';\n        details = cmd.substring(0, 100);\n        break;\n      }\n      case 'Write':\n      case 'Edit': {\n        details = getField<string>(input, 'tool_input.file_path') || '';\n        break;\n      }\n      case 'Task': {\n        details = getField<string>(input, 'tool_input.subagent_type') || '';\n        break;\n      }\n    }\n\n    const logEntry = details\n      ? `[${timestamp}] ${toolName} | ${details}\\n`\n      : `[${timestamp}] ${toolName}\\n`;\n\n    appendFileSync(auditLog, logEntry);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxBytes: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxBytes) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n", "/**\n * Unified Error Handler - Consolidated error handling hook\n * Combines: error-collector + error-tracker + error-solution-suggester\n *\n * Hook: PostToolUse (*)\n *\n * Purpose:\n * 1. Detect errors from any tool (exit code, tool_error, output patterns)\n * 2. Log structured errors to JSONL for analysis\n * 3. Suggest solutions via additionalContext when patterns match\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n * Version: 2.0.0 - Consolidated from 3 hooks (~500 LOC \u2192 ~200 LOC)\n */\n\nimport { existsSync, appendFileSync, readFileSync, writeFileSync, mkdirSync, statSync, renameSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getPluginRoot, getSessionId, getField, logHook } from '../lib/common.js';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n// Error detection regex (shared across all detection)\nconst ERROR_PATTERN = /error:|Error:|ERROR|FATAL|exception|failed|denied|not found|does not exist|connection refused|timeout|ENOENT|EACCES|EPERM/i;\n\n// Trivial commands that don't need tracking\nconst TRIVIAL_COMMANDS = /^(echo |ls |ls$|pwd|cat |head |tail |wc |date|whoami)/;\n\n// Configuration\nconst MAX_CONTEXT_CHARS = 2000;\nconst DEDUP_PROMPT_THRESHOLD = 10;\nconst MAX_SKILLS = 3;\nconst MAX_LOG_BYTES = 1000 * 1024; // 1MB\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\ninterface ErrorPattern {\n  id: string;\n  regex: string;\n  category?: string;\n  severity?: string;\n  skills?: string[];\n  solution?: {\n    brief?: string;\n    steps?: string[];\n  };\n}\n\ninterface SolutionsFile {\n  patterns: ErrorPattern[];\n  categories?: Record<string, { related_skills?: string[] }>;\n}\n\ninterface DedupFile {\n  suggestions: Record<string, { pattern_id: string; prompt_count: number }>;\n  prompt_count: number;\n}\n\ninterface ErrorInfo {\n  isError: boolean;\n  errorType: string;\n  errorMessage: string;\n  errorText: string;\n}\n\n// =============================================================================\n// ERROR DETECTION (from error-collector + error-tracker)\n// =============================================================================\n\nfunction detectError(input: HookInput): ErrorInfo {\n  const toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n  const toolError = String(input.tool_error || getField<string>(input, 'error') || '');\n  const exitCode = input.exit_code ?? 0;\n\n  let isError = false;\n  let errorType = '';\n  let errorMessage = '';\n\n  // Signal 1: Explicit non-zero exit code\n  if (exitCode !== 0 && exitCode !== undefined) {\n    isError = true;\n    errorType = 'exit_code';\n    errorMessage = `Exit code: ${exitCode}`;\n  }\n\n  // Signal 2: Error field present\n  if (toolError) {\n    isError = true;\n    errorType = errorType || 'tool_error';\n    errorMessage = errorMessage || toolError;\n  }\n\n  // Signal 3: Error patterns in output\n  if (ERROR_PATTERN.test(toolOutput)) {\n    isError = true;\n    errorType = errorType || 'output_pattern';\n    const errorLines = toolOutput.split('\\n').filter(line => ERROR_PATTERN.test(line));\n    errorMessage = errorMessage || errorLines[0] || '';\n  }\n\n  return {\n    isError,\n    errorType,\n    errorMessage,\n    errorText: toolError || toolOutput,\n  };\n}\n\n// =============================================================================\n// ERROR LOGGING (from error-collector)\n// =============================================================================\n\nfunction rotateLogFile(logFile: string): void {\n  if (!existsSync(logFile)) return;\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > MAX_LOG_BYTES) {\n      renameSync(logFile, `${logFile}.old.${Date.now()}`);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\nfunction logError(input: HookInput, errorInfo: ErrorInfo): void {\n  const projectDir = getProjectDir();\n  const errorLog = `${projectDir}/.claude/logs/errors.jsonl`;\n  const metricsFile = '/tmp/claude-session-errors.json';\n\n  try {\n    mkdirSync(`${projectDir}/.claude/logs`, { recursive: true });\n    rotateLogFile(errorLog);\n\n    const inputHash = createHash('md5').update(JSON.stringify(input.tool_input || {})).digest('hex');\n\n    const errorRecord = {\n      timestamp: new Date().toISOString(),\n      tool: input.tool_name,\n      session_id: getSessionId(),\n      error_type: errorInfo.errorType,\n      error_message: errorInfo.errorMessage.substring(0, 500),\n      input_hash: inputHash,\n      tool_input: input.tool_input,\n      output_preview: errorInfo.errorText.substring(0, 1000),\n    };\n\n    appendFileSync(errorLog, JSON.stringify(errorRecord) + '\\n');\n\n    // Update session metrics\n    try {\n      let metrics = { error_count: 0, last_error_tool: '', last_error_time: '' };\n      if (existsSync(metricsFile)) {\n        metrics = JSON.parse(readFileSync(metricsFile, 'utf8'));\n      }\n      metrics.error_count = (metrics.error_count || 0) + 1;\n      metrics.last_error_tool = input.tool_name || '';\n      metrics.last_error_time = new Date().toISOString();\n      writeFileSync(metricsFile, JSON.stringify(metrics, null, 2));\n    } catch {\n      // Ignore metrics errors\n    }\n\n    logHook('unified-error-handler', `ERROR: ${input.tool_name} - ${errorInfo.errorType}`);\n  } catch {\n    logHook('unified-error-handler', `ERROR (fallback): ${input.tool_name}`);\n  }\n}\n\n// =============================================================================\n// SOLUTION SUGGESTIONS (from error-solution-suggester)\n// =============================================================================\n\nfunction matchErrorPattern(errorText: string, solutionsFile: string): ErrorPattern | null {\n  if (!existsSync(solutionsFile)) return null;\n\n  try {\n    const content: SolutionsFile = JSON.parse(readFileSync(solutionsFile, 'utf8'));\n    const errorLower = errorText.toLowerCase();\n\n    for (const pattern of content.patterns || []) {\n      if (pattern.regex) {\n        try {\n          if (new RegExp(pattern.regex, 'i').test(errorLower)) {\n            return pattern;\n          }\n        } catch {\n          // Invalid regex\n        }\n      }\n    }\n  } catch {\n    // Parse error\n  }\n  return null;\n}\n\nfunction shouldSuggest(patternId: string, errorContext: string, dedupFile: string): boolean {\n  if (!existsSync(dedupFile)) {\n    try {\n      mkdirSync(require('path').dirname(dedupFile), { recursive: true });\n      writeFileSync(dedupFile, JSON.stringify({ suggestions: {}, prompt_count: 0 }));\n    } catch {\n      return true;\n    }\n  }\n\n  try {\n    const dedup: DedupFile = JSON.parse(readFileSync(dedupFile, 'utf8'));\n    const suggestionHash = createHash('md5')\n      .update(`${patternId}|${errorContext.substring(0, 100)}`)\n      .digest('hex');\n\n    const currentCount = (dedup.prompt_count || 0) + 1;\n    dedup.prompt_count = currentCount;\n\n    const lastSuggestedAt = dedup.suggestions[suggestionHash]?.prompt_count || 0;\n\n    if (lastSuggestedAt === 0 || (currentCount - lastSuggestedAt) >= DEDUP_PROMPT_THRESHOLD) {\n      dedup.suggestions[suggestionHash] = { pattern_id: patternId, prompt_count: currentCount };\n      writeFileSync(dedupFile, JSON.stringify(dedup, null, 2));\n      return true;\n    }\n\n    writeFileSync(dedupFile, JSON.stringify(dedup, null, 2));\n    return false;\n  } catch {\n    return true;\n  }\n}\n\nfunction getSkillDescription(skillName: string, skillsDir: string): string {\n  const skillFile = `${skillsDir}/${skillName}/SKILL.md`;\n  if (!existsSync(skillFile)) return '';\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (frontmatterMatch) {\n      const descMatch = frontmatterMatch[1].match(/description:\\s*(.+)/);\n      if (descMatch) return descMatch[1].trim();\n    }\n  } catch {\n    // Ignore\n  }\n  return '';\n}\n\nfunction buildSuggestionMessage(pattern: ErrorPattern, solutionsFile: string, skillsDir: string): string {\n  const brief = pattern.solution?.brief || 'An error was detected.';\n  const steps = pattern.solution?.steps || [];\n\n  let msg = '## Error Solution\\n\\n';\n  msg += `**${brief}**\\n\\n`;\n\n  if (steps.length > 0) {\n    msg += '### Quick Fixes\\n\\n';\n    steps.forEach((step, i) => {\n      msg += `  ${i + 1}. ${step}\\n`;\n    });\n    msg += '\\n';\n  }\n\n  // Get skills\n  const patternSkills = pattern.skills || [];\n  let categorySkills: string[] = [];\n  if (pattern.category && existsSync(solutionsFile)) {\n    try {\n      const content: SolutionsFile = JSON.parse(readFileSync(solutionsFile, 'utf8'));\n      categorySkills = content.categories?.[pattern.category]?.related_skills || [];\n    } catch {\n      // Ignore\n    }\n  }\n\n  const allSkills = [...new Set([...patternSkills, ...categorySkills])].slice(0, MAX_SKILLS);\n\n  if (allSkills.length > 0) {\n    msg += '### Related Skills\\n\\n';\n    for (const skill of allSkills) {\n      const desc = getSkillDescription(skill, skillsDir);\n      msg += desc ? `- **${skill}**: ${desc}\\n` : `- **${skill}**\\n`;\n    }\n    msg += '\\nUse `/ork:<skill-name>` or `Read skills/<skill-name>/SKILL.md`';\n  }\n\n  return msg.length > MAX_CONTEXT_CHARS ? msg.substring(0, MAX_CONTEXT_CHARS - 20) + '...\\n\\n(truncated)' : msg;\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\nexport function unifiedErrorHandler(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Skip trivial bash commands\n  if (toolName === 'Bash') {\n    const command = getField<string>(input, 'tool_input.command') || '';\n    if (TRIVIAL_COMMANDS.test(command)) {\n      return outputSilentSuccess();\n    }\n  }\n\n  // Detect if this was an error\n  const errorInfo = detectError(input);\n\n  if (!errorInfo.isError) {\n    return outputSilentSuccess();\n  }\n\n  // Log the error (always)\n  logError(input, errorInfo);\n\n  // Try to suggest solutions (Bash only, with dedup)\n  if (toolName === 'Bash') {\n    const pluginRoot = getPluginRoot();\n    const solutionsFile = `${pluginRoot}/.claude/rules/error_solutions.json`;\n    const skillsDir = `${pluginRoot}/skills`;\n    const dedupFile = `/tmp/claude-error-suggestions-${getSessionId()}.json`;\n\n    const matchedPattern = matchErrorPattern(errorInfo.errorText.substring(0, 2000), solutionsFile);\n\n    if (matchedPattern && shouldSuggest(matchedPattern.id, errorInfo.errorText, dedupFile)) {\n      const suggestionMessage = buildSuggestionMessage(matchedPattern, solutionsFile, skillsDir);\n\n      if (suggestionMessage) {\n        logHook('unified-error-handler', `Suggesting solution for pattern: ${matchedPattern.id}`);\n        return {\n          continue: true,\n          hookSpecificOutput: {\n            additionalContext: suggestionMessage,\n          },\n        };\n      }\n    }\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Auto-Lint Hook - PostToolUse hook for Write/Edit\n * CC 2.1.7 Compliant\n *\n * Automatically runs linters after file writes:\n * - Python: ruff check + format (Astral toolchain)\n * - JS/TS: biome check (Rust-based)\n * - JSON/CSS: biome format\n */\n\nimport { existsSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, logHook } from '../lib/common.js';\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py':\n      return 'python';\n    case 'ts':\n    case 'tsx':\n      return 'typescript';\n    case 'js':\n    case 'jsx':\n      return 'javascript';\n    case 'json':\n      return 'json';\n    case 'css':\n    case 'scss':\n      return 'css';\n    default:\n      return null;\n  }\n}\n\n/**\n * Check if a command exists\n */\nfunction commandExists(cmd: string): boolean {\n  try {\n    execSync(`which ${cmd}`, { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Run auto-lint on written files\n */\nexport function autoLint(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Check if file exists\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || '.';\n  const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n  if (!existsSync(fullPath)) {\n    return outputSilentSuccess();\n  }\n\n  // Skip if SKIP_AUTO_LINT is set\n  if (process.env.SKIP_AUTO_LINT === '1') {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  let lintIssues = 0;\n  let fixesApplied = false;\n\n  try {\n    switch (language) {\n      case 'python':\n        if (commandExists('ruff')) {\n          try {\n            const ruffCheck = execSync(`timeout 5s ruff check --output-format=concise \"${fullPath}\" 2>&1`, {\n              encoding: 'utf8',\n              stdio: ['pipe', 'pipe', 'pipe'],\n            });\n            if (ruffCheck) {\n              lintIssues = ruffCheck.split('\\n').filter(Boolean).length;\n              execSync(`timeout 5s ruff check --fix --unsafe-fixes=false \"${fullPath}\" 2>/dev/null`, {\n                stdio: 'ignore',\n              });\n              fixesApplied = true;\n            }\n          } catch {\n            // ruff check returns non-zero when issues found\n          }\n          try {\n            execSync(`timeout 5s ruff format \"${fullPath}\" 2>/dev/null`, { stdio: 'ignore' });\n          } catch {\n            // Ignore format errors\n          }\n        }\n        break;\n\n      case 'typescript':\n      case 'javascript':\n        if (commandExists('biome')) {\n          try {\n            const biomeOut = execSync(`timeout 5s biome check --write \"${fullPath}\" 2>&1`, {\n              encoding: 'utf8',\n              stdio: ['pipe', 'pipe', 'pipe'],\n            });\n            if (biomeOut.includes('Fixed')) {\n              fixesApplied = true;\n            }\n            if (biomeOut.includes('error')) {\n              lintIssues = (biomeOut.match(/error/g) || []).length;\n            }\n          } catch {\n            // Ignore biome errors\n          }\n        }\n        break;\n\n      case 'json':\n      case 'css':\n        if (commandExists('biome')) {\n          try {\n            execSync(`timeout 5s biome format --write \"${fullPath}\" 2>/dev/null`, {\n              stdio: 'ignore',\n            });\n            fixesApplied = true;\n          } catch {\n            // Ignore format errors\n          }\n        }\n        break;\n    }\n  } catch (error) {\n    logHook('auto-lint', `Error: ${error}`);\n  }\n\n  // Build output message\n  if (fixesApplied && lintIssues > 0) {\n    const basename = filePath.split('/').pop();\n    return {\n      continue: true,\n      systemMessage: `Auto-lint: fixed issues, ${lintIssues} remaining in ${basename}`,\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Context Budget Monitor - After Tool Use Hook\n * Monitors context usage and triggers compression when threshold exceeded\n *\n * Triggers compression at 70% budget utilization\n * Target after compression: 50%\n *\n * Version: 2.0.0\n * Part of Context Engineering 2.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getSessionId, logHook, estimateTokenCount } from '../lib/common.js';\n\n// Configuration\nconst BUDGET_TOTAL = 2200; // Total token budget for context layer\nconst COMPRESS_TRIGGER = 0.70; // Trigger compression at 70%\nconst COMPRESS_TARGET = 0.50; // Target 50% after compression\nconst MCP_DEFER_TRIGGER = 0.10; // Defer MCP tools when context >10% of effective window\n\n/**\n * Estimate tokens from file content using content-aware estimation\n */\nfunction estimateTokens(filePath: string): number {\n  if (!existsSync(filePath)) return 0;\n\n  try {\n    const content = readFileSync(filePath, 'utf8');\n    return estimateTokenCount(content);\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Calculate total loaded context\n */\nfunction calculateUsage(): number {\n  const projectDir = getProjectDir();\n  const contextDir = `${projectDir}/context`;\n\n  const alwaysLoadedFiles = [\n    `${contextDir}/identity.json`,\n    `${contextDir}/session/state.json`,\n    `${contextDir}/knowledge/index.json`,\n    `${contextDir}/knowledge/blockers/current.json`,\n  ];\n\n  let total = 0;\n  for (const file of alwaysLoadedFiles) {\n    total += estimateTokens(file);\n  }\n\n  return total;\n}\n\n/**\n * Get effective context window (actual usable vs static max)\n */\nfunction getEffectiveContextWindow(): number {\n  const baseWindow = parseInt(process.env.CLAUDE_MAX_CONTEXT || '200000', 10);\n  const overheadPercent = 20; // ~20% system overhead\n  return Math.floor(baseWindow * (100 - overheadPercent) / 100);\n}\n\n/**\n * Check if MCP tools should be deferred\n */\nfunction shouldDeferMcp(currentTokens: number): boolean {\n  const effectiveWindow = getEffectiveContextWindow();\n  if (effectiveWindow === 0) return true;\n\n  const usageRatio = currentTokens / effectiveWindow;\n  return usageRatio > MCP_DEFER_TRIGGER;\n}\n\n/**\n * Update MCP deferral state file\n */\nfunction updateMcpDeferState(shouldDefer: boolean, currentTokens: number): void {\n  const sessionId = getSessionId();\n  const stateFile = `/tmp/claude-mcp-defer-state-${sessionId}.json`;\n  const effectiveWindow = getEffectiveContextWindow();\n\n  const state = {\n    mcp_deferred: shouldDefer,\n    context_tokens: currentTokens,\n    effective_window: effectiveWindow,\n    updated_at: new Date().toISOString(),\n    reason: shouldDefer ? 'context > 10% threshold' : 'context within limits',\n  };\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch {\n    // Ignore write errors\n  }\n\n  logHook('context-budget-monitor',\n    `MCP defer state updated: defer=${shouldDefer}, tokens=${currentTokens}, window=${effectiveWindow}`);\n}\n\n/**\n * Compress session state\n */\nfunction compressSession(): void {\n  const projectDir = getProjectDir();\n  const sessionFile = `${projectDir}/context/session/state.json`;\n\n  if (!existsSync(sessionFile)) return;\n\n  try {\n    const content = JSON.parse(readFileSync(sessionFile, 'utf8'));\n\n    const compressed = {\n      session_id: content.session_id,\n      started: content.started,\n      current_task: content.current_task,\n      next_steps: (content.next_steps || []).slice(-3),\n      blockers: content.blockers,\n      _compressed: true,\n      _compressed_at: new Date().toISOString(),\n      _original_files_touched: (content.files_touched || []).length,\n      _original_decisions: (content.decisions_this_session || []).length,\n    };\n\n    writeFileSync(sessionFile, JSON.stringify(compressed, null, 2));\n    logHook('context-budget-monitor', 'Session state compressed');\n  } catch {\n    // Ignore compression errors\n  }\n}\n\n/**\n * Archive old decisions\n */\nfunction archiveOldDecisions(): void {\n  const projectDir = getProjectDir();\n  const decisionsFile = `${projectDir}/context/knowledge/decisions/active.json`;\n\n  if (!existsSync(decisionsFile)) return;\n\n  try {\n    const content = JSON.parse(readFileSync(decisionsFile, 'utf8'));\n    const decisions = content.decisions || [];\n\n    if (decisions.length > 10) {\n      logHook('context-budget-monitor', 'Archiving old decisions (keeping latest 5)...');\n\n      // Create archive directory\n      const archiveDir = `${projectDir}/context/archive/decisions`;\n      mkdirSync(archiveDir, { recursive: true });\n\n      // Archive older decisions\n      const date = new Date();\n      const archiveFile = `${archiveDir}/${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}.json`;\n      writeFileSync(archiveFile, JSON.stringify(decisions.slice(0, -5), null, 2));\n\n      // Keep only latest 5\n      content.decisions = decisions.slice(-5);\n      writeFileSync(decisionsFile, JSON.stringify(content, null, 2));\n\n      logHook('context-budget-monitor', `Archived ${decisions.length - 5} decisions to ${archiveFile}`);\n    }\n  } catch {\n    // Ignore archive errors\n  }\n}\n\n/**\n * Monitor context budget and trigger compression if needed\n */\nexport function contextBudgetMonitor(_input: HookInput): HookResult {\n  try {\n    const currentTokens = calculateUsage();\n\n    // Guard against division by zero\n    const usageRatio = currentTokens / BUDGET_TOTAL;\n    const usagePercent = Math.floor(usageRatio * 100);\n\n    logHook('context-budget-monitor',\n      `Context usage: ${currentTokens} / ${BUDGET_TOTAL} tokens (${usagePercent}%)`);\n\n    // CC 2.1.7: Check and update MCP deferral state\n    const deferMcp = shouldDeferMcp(currentTokens);\n    updateMcpDeferState(deferMcp, currentTokens);\n\n    // Check if compression needed\n    if (usageRatio > COMPRESS_TRIGGER) {\n      logHook('context-budget-monitor',\n        `WARNING: Context usage (${usagePercent}%) exceeds threshold (${COMPRESS_TRIGGER * 100}%)`);\n      logHook('context-budget-monitor', 'Triggering compression...');\n\n      // Compress session state\n      compressSession();\n\n      // Archive old decisions\n      archiveOldDecisions();\n\n      // Recalculate\n      const newTokens = calculateUsage();\n      const newRatio = newTokens / BUDGET_TOTAL;\n      const newPercent = Math.floor(newRatio * 100);\n\n      logHook('context-budget-monitor',\n        `After compression: ${newTokens} / ${BUDGET_TOTAL} tokens (${newPercent}%)`);\n\n      if (newRatio > COMPRESS_TARGET) {\n        logHook('context-budget-monitor',\n          'WARNING: Still above target. Manual review recommended.');\n      } else {\n        logHook('context-budget-monitor', 'Compression successful. Target achieved.');\n      }\n    } else {\n      logHook('context-budget-monitor', 'Context usage within budget. No compression needed.');\n    }\n  } catch (error) {\n    logHook('context-budget-monitor', `Error: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Coordination Heartbeat - Update heartbeat after each tool use\n * Hook: PostToolUse (*)\n * CC 2.1.6 Compliant: ensures JSON output on all code paths\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, logHook } from '../lib/common.js';\n\n/**\n * Update coordination heartbeat\n */\nexport function coordinationHeartbeat(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const coordLib = `${projectDir}/.claude/coordination/lib/coordination.sh`;\n\n  // Check if coordination lib exists\n  if (!existsSync(coordLib)) {\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Load instance ID if available\n    // CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability,\n    // but we add a defensive fallback to prevent crashes.\n    const instanceEnv = `${projectDir}/.claude/.instance_env`;\n    let instanceId = process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}`;\n\n    if (existsSync(instanceEnv)) {\n      const content = readFileSync(instanceEnv, 'utf8');\n      const match = content.match(/CLAUDE_INSTANCE_ID=[\"']?([^\"'\\n]+)/);\n      if (match) {\n        instanceId = match[1];\n      }\n    }\n\n    // Update heartbeat (lightweight operation)\n    if (instanceId) {\n      execSync(\n        `source \"${coordLib}\" && INSTANCE_ID=\"${instanceId}\" coord_heartbeat 2>/dev/null || true`,\n        {\n          shell: '/bin/bash',\n          stdio: 'ignore',\n          timeout: 5000,\n        }\n      );\n    }\n  } catch (error) {\n    // Coordination update failed, but don't block execution\n    logHook('coordination-heartbeat', `Heartbeat update failed: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Mem0 Webhook Handler - Process incoming webhook events\n * Hook: PostToolUse (for bash/webhook-receiver.py calls)\n * CC 2.1.7 Compliant\n *\n * Features:\n * - Processes webhook events from mem0\n * - Routes to appropriate workflows\n * - Triggers auto-sync, decision sync, cleanup\n *\n * Version: 1.0.0\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, logHook } from '../lib/common.js';\n\n/**\n * Handle incoming mem0 webhook events\n */\nexport function mem0WebhookHandler(input: HookInput): HookResult {\n  logHook('mem0-webhook-handler', 'Mem0 webhook handler starting');\n\n  const toolName = input.tool_name || '';\n  const command = getField<string>(input, 'tool_input.command') || '';\n\n  // Only process webhook-receiver.py calls\n  if (toolName !== 'Bash' || !command.includes('webhook-receiver.py')) {\n    return outputSilentSuccess();\n  }\n\n  // Extract event data from command output or tool result\n  const eventDataStr = getField<string>(input, 'tool_result') || '';\n\n  if (!eventDataStr) {\n    logHook('mem0-webhook-handler', 'No event data found in webhook call');\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Parse event data\n    let eventData: Record<string, unknown>;\n    try {\n      eventData = JSON.parse(eventDataStr);\n    } catch {\n      logHook('mem0-webhook-handler', 'Could not parse event data');\n      return outputSilentSuccess();\n    }\n\n    // Parse event type\n    const eventType = (eventData.result as Record<string, unknown>)?.event_type ||\n                     eventData.event_type || '';\n    const memoryId = (eventData.result as Record<string, unknown>)?.memory_id ||\n                    (eventData.memory as Record<string, unknown>)?.id || '';\n\n    logHook('mem0-webhook-handler', `Processing webhook event: ${eventType} (memory: ${memoryId})`);\n\n    // Log event for observability \u2014 actual sync is handled by dedicated hooks\n    // (memory-bridge.ts for graph sync, mem0-pre-compaction-sync.ts for decision sync)\n    // This handler logs webhook events for audit trail purposes.\n    const knownEvents = ['memory.created', 'memory.updated', 'memory.deleted'];\n    if (knownEvents.includes(eventType as string)) {\n      logHook('mem0-webhook-handler', `Received ${eventType} for memory ${memoryId}`);\n    } else {\n      logHook('mem0-webhook-handler', `Received unknown event type: ${eventType}`);\n    }\n  } catch (error) {\n    logHook('mem0-webhook-handler', `Error processing webhook: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Memory Bridge Hook - Graph-First Memory Sync\n * Triggers on PostToolUse for mcp__mem0__add_memory\n *\n * Graph-First Architecture (v2.1):\n * - Graph is AUTHORITATIVE - always the source of truth\n * - When mem0 is used, ALWAYS sync TO graph (preserve in local storage)\n * - When graph is used (default), NO sync needed (already in primary)\n *\n * Sync Direction: Mem0 -> Graph ONLY (one-way)\n * - mcp__mem0__add_memory -> Extract entities, sync to graph\n * - mcp__memory__create_entities -> No action needed (already in primary)\n *\n * Version: 2.1.1 - CC 2.1.9/2.1.11 compliant, Graph-First Architecture\n * Part of Memory Fabric v2.1 - Graph-First Architecture\n */\n\nimport { existsSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getPluginRoot, logHook } from '../lib/common.js';\n\n// Entity type mapping patterns\nconst ENTITY_PATTERNS: Record<string, RegExp> = {\n  Technology: /fastapi|react|typescript|python|postgres|redis|docker|kubernetes|langchain|langgraph|pgvector|qdrant|openai|anthropic|celery|rabbitmq|kafka|nginx|vite|tailwind|prisma|sqlalchemy|alembic|pydantic|zod/i,\n  Pattern: /singleton|factory|repository|service|controller|adapter|facade|strategy|observer|decorator|middleware|dependency.injection|cursor.pagination|rate.limiting|circuit.breaker/i,\n  Decision: /decided|chose|selected|will.use|adopted|standardized|migrated/i,\n  Architecture: /microservice|monolith|event.driven|cqrs|event.sourcing|hexagonal|clean.architecture|ddd|api.gateway|load.balancer/i,\n  Database: /postgresql|mysql|mongodb|sqlite|dynamodb|cassandra|schema|migration|index|query/i,\n  Security: /jwt|oauth|cors|csrf|xss|sql.injection|rate.limit|encryption|authentication|authorization/i,\n};\n\ninterface Entity {\n  name: string;\n  entityType: string;\n  observations: string[];\n}\n\ninterface Relation {\n  from: string;\n  to: string;\n  relationType: string;\n}\n\n/**\n * Extract entities from text (Mem0 -> Graph)\n */\nfunction extractEntitiesFromText(text: string): Entity[] {\n  const textLower = text.toLowerCase();\n  const entities: Entity[] = [];\n\n  for (const [entityType, pattern] of Object.entries(ENTITY_PATTERNS)) {\n    const matches = textLower.match(pattern);\n    if (matches) {\n      for (const match of [...new Set(matches)].slice(0, 5)) {\n        // Capitalize first letter for entity name\n        const entityName = match\n          .split(/[\\s-_]+/)\n          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n          .join('-');\n\n        // Build observation from surrounding context\n        let observation = 'Used in project context';\n        if (/decided.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Decided to use for project';\n        } else if (/chose.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Chosen for implementation';\n        } else if (/will.use.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Will be used in project';\n        }\n\n        entities.push({\n          name: entityName,\n          entityType,\n          observations: [observation],\n        });\n      }\n    }\n  }\n\n  return entities;\n}\n\n/**\n * Extract relations from text\n */\nfunction extractRelationsFromText(text: string, entities: Entity[]): Relation[] {\n  const textLower = text.toLowerCase();\n  const relations: Relation[] = [];\n  const entityNames = entities.map(e => e.name);\n\n  for (const entity1 of entityNames) {\n    const entity1Lower = entity1.toLowerCase().replace(/-/g, '.');\n\n    for (const entity2 of entityNames) {\n      if (entity1 === entity2) continue;\n\n      const entity2Lower = entity2.toLowerCase().replace(/-/g, '.');\n      const relationPattern = new RegExp(\n        `${entity1Lower}.*(with|using|and|integrated|connected|for).*${entity2Lower}`,\n        'i'\n      );\n\n      if (relationPattern.test(textLower)) {\n        relations.push({\n          from: entity1,\n          to: entity2,\n          relationType: 'uses',\n        });\n      }\n    }\n  }\n\n  return relations;\n}\n\n/**\n * Sync memory from Mem0 to knowledge graph\n */\nexport function memoryBridge(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process memory-related tools\n  switch (toolName) {\n    case 'mcp__mem0__add_memory': {\n      // Graph-First: Sync mem0 content TO graph (preserve in primary storage)\n      logHook('memory-bridge', 'Processing mcp__mem0__add_memory - syncing to graph (primary)');\n\n      // Get the text that was added\n      const memoryText = getField<string>(input, 'tool_input.text') || '';\n\n      if (!memoryText || memoryText.length < 20) {\n        logHook('memory-bridge', 'Memory text too short, skipping');\n        return outputSilentSuccess();\n      }\n\n      // Check for Memory Fabric Agent\n      const pluginRoot = getPluginRoot();\n      const memoryAgent = `${pluginRoot}/bin/memory-fabric-agent.py`;\n      const hasAgentSdk = existsSync(memoryAgent);\n\n      if (hasAgentSdk) {\n        logHook('memory-bridge', 'Memory Fabric Agent available for bidirectional sync');\n        // Agent SDK would be invoked here for smart entity extraction\n        // For now, fall through to regex extraction\n      }\n\n      // Fallback: Use regex-based extraction\n      const entities = extractEntitiesFromText(memoryText);\n      const entityCount = entities.length;\n\n      if (entityCount === 0) {\n        logHook('memory-bridge', 'No entities extracted');\n        return outputSilentSuccess();\n      }\n\n      // Extract relations\n      const relations = extractRelationsFromText(memoryText, entities);\n      const relationCount = relations.length;\n\n      logHook('memory-bridge', `Extracted ${entityCount} entities and ${relationCount} relations`);\n\n      // Format suggestion message\n      const entityList = entities\n        .slice(0, 5)\n        .map(e => `- ${e.name} (${e.entityType}): ${e.observations[0] || 'observed'}`)\n        .join('\\n');\n\n      let msg = `[Memory Bridge] Sync to Graph (primary storage)\n\nMem0 content should be synced to the knowledge graph for durability.\nDetected ${entityCount} entities to preserve:\n\n${entityList}\n\nStore in graph with mcp__memory__create_entities:\n\\`\\`\\`json\n{\"entities\": ${JSON.stringify(entities)}}\n\\`\\`\\``;\n\n      if (relationCount > 0) {\n        msg += `\n\nThen call mcp__memory__create_relations with:\n\\`\\`\\`json\n{\"relations\": ${JSON.stringify(relations)}}\n\\`\\`\\``;\n      }\n\n      return {\n        continue: true,\n        systemMessage: msg,\n      };\n    }\n\n    case 'mcp__memory__create_entities':\n      // Graph-First: No sync needed when writing to graph (it's already the primary)\n      logHook('memory-bridge', 'mcp__memory__create_entities - graph is primary, no sync needed');\n      return outputSilentSuccess();\n\n    default:\n      // Not a memory tool, skip\n      return outputSilentSuccess();\n  }\n}\n", "/**\n * Realtime Sync Hook - Graph-First Priority-based immediate memory persistence\n * Triggers on PostToolUse for Bash, Write, and Skill completions\n *\n * Purpose: Sync critical decisions immediately to knowledge graph\n *\n * Graph-First Architecture (v2.1):\n * - IMMEDIATE syncs target knowledge graph (mcp__memory__*) - always works\n * - mem0 cloud sync only if API key present AND critical priority\n *\n * Priority Classification:\n * - IMMEDIATE: \"decided\", \"chose\", \"architecture\", \"security\", \"blocked\", \"breaking\"\n * - BATCHED: \"pattern\", \"convention\", \"preference\"\n * - SESSION_END: Everything else (handled by existing Stop hooks)\n *\n * Version: 2.1.0 - CC 2.1.9/2.1.11 compliant, Graph-First Architecture\n * Part of Memory Fabric v2.1 - Graph-First Architecture\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../lib/common.js';\n\n// Priority keywords\nconst IMMEDIATE_KEYWORDS = /decided|chose|architecture|security|blocked|breaking|critical|must|cannot|deprecated|removed|migration/i;\nconst BATCHED_KEYWORDS = /pattern|convention|preference|style|format|naming/i;\n\n// Minimum content length to consider\nconst MIN_CONTENT_LENGTH = 30;\n\n// Context pressure thresholds\nconst CONTEXT_EMERGENCY_THRESHOLD = 85;\nconst CONTEXT_CRITICAL_THRESHOLD = 90;\n\ninterface PendingItem {\n  content: string;\n  category: string;\n  queued_at: string;\n}\n\ninterface PendingFile {\n  pending: PendingItem[];\n  created_at: string;\n}\n\n/**\n * Get current context usage percentage\n */\nfunction getContextPressure(): number {\n  const pressure = parseInt(process.env.CLAUDE_CONTEXT_USED_PERCENTAGE || '0', 10);\n\n  if (pressure === 0) {\n    const tokensUsed = parseInt(process.env.CLAUDE_CONTEXT_TOKENS_USED || '0', 10);\n    const maxTokens = parseInt(process.env.CLAUDE_CONTEXT_MAX_TOKENS || '0', 10);\n    if (maxTokens > 0) {\n      return Math.floor((tokensUsed * 100) / maxTokens);\n    }\n  }\n\n  return pressure;\n}\n\n/**\n * Classify priority of content\n */\nfunction classifyPriority(content: string): 'IMMEDIATE' | 'BATCHED' | 'SESSION_END' {\n  if (IMMEDIATE_KEYWORDS.test(content)) {\n    return 'IMMEDIATE';\n  }\n  if (BATCHED_KEYWORDS.test(content)) {\n    return 'BATCHED';\n  }\n  return 'SESSION_END';\n}\n\n/**\n * Extract the decision/insight from content\n */\nfunction extractDecision(content: string): string {\n  // Try to extract a meaningful decision statement\n  const patterns = [\n    /[^.]*\\b(decided|chose|selected|will use|must|cannot|blocked|breaking)[^.]*/i,\n    /[^.]*\\b(architecture|security|migration|deprecated)[^.]*/i,\n  ];\n\n  for (const pattern of patterns) {\n    const match = content.match(pattern);\n    if (match) {\n      return match[0].trim().substring(0, 300);\n    }\n  }\n\n  // Final fallback: take first meaningful sentence\n  const sentences = content.match(/^[^.]{30,200}\\./);\n  if (sentences) {\n    return sentences[0].trim();\n  }\n\n  return content.substring(0, 300).trim();\n}\n\n/**\n * Detect category from content\n */\nfunction detectCategory(content: string): string {\n  const contentLower = content.toLowerCase();\n\n  if (/security|auth|jwt|oauth|cors|xss/.test(contentLower)) return 'security';\n  if (/architecture|design|structure|system/.test(contentLower)) return 'architecture';\n  if (/database|schema|migration|postgres|sql/.test(contentLower)) return 'database';\n  if (/blocked|issue|bug|problem|cannot/.test(contentLower)) return 'blocker';\n  if (/breaking|deprecated|removed|migration/.test(contentLower)) return 'breaking-change';\n  if (/api|endpoint|route|rest/.test(contentLower)) return 'api';\n  if (/decided|chose|selected/.test(contentLower)) return 'decision';\n\n  return 'general';\n}\n\n/**\n * Initialize pending sync queue\n */\nfunction initPendingQueue(pendingFile: string): void {\n  if (!existsSync(pendingFile)) {\n    try {\n      mkdirSync(require('path').dirname(pendingFile), { recursive: true });\n      writeFileSync(pendingFile, JSON.stringify({\n        pending: [],\n        created_at: new Date().toISOString(),\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Add to pending queue\n */\nfunction addToPendingQueue(content: string, category: string, pendingFile: string): void {\n  initPendingQueue(pendingFile);\n\n  try {\n    const data: PendingFile = JSON.parse(readFileSync(pendingFile, 'utf8'));\n    data.pending.push({\n      content,\n      category,\n      queued_at: new Date().toISOString(),\n    });\n    writeFileSync(pendingFile, JSON.stringify(data, null, 2));\n    logHook('realtime-sync', `Added to pending queue: category=${category}, length=${content.length}`);\n  } catch {\n    // Ignore queue errors\n  }\n}\n\n/**\n * Get pending count\n */\nfunction getPendingCount(pendingFile: string): number {\n  if (!existsSync(pendingFile)) return 0;\n\n  try {\n    const data: PendingFile = JSON.parse(readFileSync(pendingFile, 'utf8'));\n    return data.pending?.length || 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Sync critical decisions in real-time\n */\nexport function realtimeSync(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only process relevant tools\n  if (!['Bash', 'Write', 'Edit', 'Skill', 'Task'].includes(toolName)) {\n    return outputSilentSuccess();\n  }\n\n  // Get tool output/result\n  let toolOutput = '';\n  switch (toolName) {\n    case 'Bash': {\n      toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n      const command = getField<string>(input, 'tool_input.command') || '';\n      if (command) {\n        toolOutput = `${command}\\n${toolOutput}`;\n      }\n      break;\n    }\n    case 'Write':\n    case 'Edit': {\n      const content = getField<string>(input, 'tool_input.new_string') ||\n                     getField<string>(input, 'tool_input.content') || '';\n      const filePath = getField<string>(input, 'tool_input.file_path') || '';\n      toolOutput = filePath ? `Writing to ${filePath}: ${content}` : content;\n      break;\n    }\n    case 'Skill':\n    case 'Task': {\n      toolOutput = String(getField<unknown>(input, 'tool_result') || input.tool_output || '');\n      break;\n    }\n  }\n\n  // Skip if output is too short\n  if (!toolOutput || toolOutput.length < MIN_CONTENT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Classify priority\n  let priority = classifyPriority(toolOutput);\n  logHook('realtime-sync', `Tool: ${toolName}, Priority: ${priority}, Content length: ${toolOutput.length}`);\n\n  // Context pressure override\n  const contextPressure = getContextPressure();\n  const projectDir = getProjectDir();\n  const sessionId = getSessionId();\n  const pendingFile = `${projectDir}/.claude/logs/.mem0-pending-sync-${sessionId}.json`;\n\n  // Upgrade BATCHED to IMMEDIATE if context pressure is high\n  if (priority === 'BATCHED' && contextPressure >= CONTEXT_EMERGENCY_THRESHOLD) {\n    priority = 'IMMEDIATE';\n    logHook('realtime-sync', `EMERGENCY: Context at ${contextPressure}%, upgrading BATCHED to IMMEDIATE`);\n  }\n\n  // If critical (>90%), flush pending queue immediately\n  if (contextPressure >= CONTEXT_CRITICAL_THRESHOLD) {\n    const pendingCount = getPendingCount(pendingFile);\n    if (pendingCount > 0) {\n      logHook('realtime-sync', `CRITICAL: Context at ${contextPressure}%, flushing ${pendingCount} pending items`);\n\n      return {\n        continue: true,\n        systemMessage: `[CRITICAL SYNC] Context at ${contextPressure}% - compaction imminent!\n\n${pendingCount} items in pending queue need immediate sync to knowledge graph.\nPending sync file: ${pendingFile}\n\nExecute mcp__memory__create_entities for each item in the pending file NOW\nto preserve session context in the knowledge graph before compaction.`,\n      };\n    }\n  }\n\n  switch (priority) {\n    case 'IMMEDIATE': {\n      const decision = extractDecision(toolOutput);\n\n      if (!decision || decision.length < 20) {\n        logHook('realtime-sync', 'Could not extract meaningful decision');\n        return outputSilentSuccess();\n      }\n\n      const category = detectCategory(decision);\n      logHook('realtime-sync', `IMMEDIATE sync triggered: category=${category}`);\n\n      return {\n        continue: true,\n        systemMessage: `[IMMEDIATE SYNC] Critical decision detected - store in knowledge graph now.\n\nCategory: ${category}\nDecision: \"${decision.substring(0, 200)}\"\n\nStore in knowledge graph with mcp__memory__create_entities:\n\\`\\`\\`json\n{\n  \"entities\": [{\n    \"name\": \"${category}-decision\",\n    \"entityType\": \"Decision\",\n    \"observations\": [\"${decision.substring(0, 300).replace(/\"/g, '\\\\\"')}\"]\n  }]\n}\n\\`\\`\\`\n\nThis decision is critical and should be synced immediately for:\n- Session continuity if interrupted\n- Cross-agent knowledge sharing\n- Future reference in similar contexts`,\n      };\n    }\n\n    case 'BATCHED': {\n      const decision = extractDecision(toolOutput);\n\n      if (decision && decision.length >= 20) {\n        const category = detectCategory(decision);\n        addToPendingQueue(decision, category, pendingFile);\n\n        const pendingCount = getPendingCount(pendingFile);\n\n        // Auto-sync when queue reaches threshold (5+ items)\n        if (pendingCount >= 5) {\n          logHook('realtime-sync', `BATCHED queue has ${pendingCount} items - triggering batch sync`);\n\n          return {\n            continue: true,\n            systemMessage: `[BATCHED SYNC] ${pendingCount} patterns/conventions queued for graph sync.\n\nLatest: \"${decision.substring(0, 100)}...\" (${category})\n\nThese will be synced to knowledge graph at session end, or trigger batch sync now with mcp__memory__create_entities for each item in:\n${pendingFile}`,\n          };\n        }\n      }\n\n      return outputSilentSuccess();\n    }\n\n    case 'SESSION_END':\n    default:\n      // Let existing Stop hooks handle this\n      return outputSilentSuccess();\n  }\n}\n", "/**\n * Session Event Tracker\n * Logs all session events (skills, agents, hooks, decisions) with user identity.\n *\n * Events are stored per-session in JSONL format for later aggregation.\n * This enables learning user patterns across sessions.\n *\n * Storage: .claude/memory/sessions/{session_id}/events.jsonl\n */\n\nimport { existsSync, appendFileSync, mkdirSync, readFileSync, readdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport { getIdentityContext, type IdentityContext } from './user-identity.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Event types that can be tracked\n */\nexport type SessionEventType =\n  | 'skill_invoked'\n  | 'agent_spawned'\n  | 'hook_triggered'\n  | 'decision_made'\n  | 'preference_stated'\n  | 'problem_reported'\n  | 'solution_found'\n  | 'tool_used'\n  | 'session_start'\n  | 'session_end'\n  | 'communication_style_detected';\n\n/**\n * A single session event\n */\nexport interface SessionEvent {\n  /** Unique event ID */\n  event_id: string;\n  /** Event type */\n  event_type: SessionEventType;\n  /** Identity context (user, session, machine) */\n  identity: IdentityContext;\n  /** Event-specific payload */\n  payload: {\n    /** Name of skill/agent/hook/tool */\n    name: string;\n    /** Input data (optional, may be truncated for privacy) */\n    input?: Record<string, unknown>;\n    /** Output/result (optional, may be truncated) */\n    output?: Record<string, unknown>;\n    /** Duration in milliseconds */\n    duration_ms?: number;\n    /** Whether the event succeeded */\n    success: boolean;\n    /** Additional context */\n    context?: string;\n    /** Confidence score (for decisions) */\n    confidence?: number;\n  };\n}\n\n/**\n * Session summary (aggregated at session end)\n */\nexport interface SessionSummary {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  start_time?: string;\n  end_time?: string;\n  duration_ms?: number;\n  event_counts: Record<SessionEventType, number>;\n  skills_used: string[];\n  agents_spawned: string[];\n  hooks_triggered: string[];\n  decisions_made: number;\n  problems_reported: number;\n  solutions_found: number;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/** Session ID validation regex - alphanumeric, dashes, underscores only (SEC-002) */\nconst SESSION_ID_PATTERN = /^[a-zA-Z0-9_-]{1,128}$/;\n\n/**\n * Validate session ID to prevent path traversal attacks.\n * Defense-in-depth: trusted sources, but we validate at boundary anyway.\n */\nfunction isValidSessionId(sessionId: string): boolean {\n  return SESSION_ID_PATTERN.test(sessionId);\n}\n\n/**\n * Get session storage directory\n */\nfunction getSessionDir(sessionId?: string): string {\n  const sid = sessionId || getSessionId();\n  // Validate session ID to prevent path traversal (SEC-002)\n  if (!isValidSessionId(sid)) {\n    throw new Error(`Invalid session ID format`);\n  }\n  return `${getProjectDir()}/.claude/memory/sessions/${sid}`;\n}\n\n/**\n * Get events file path for a session\n */\nfunction getEventsPath(sessionId?: string): string {\n  return `${getSessionDir(sessionId)}/events.jsonl`;\n}\n\n/**\n * Ensure session directory exists\n */\nfunction ensureSessionDir(sessionId?: string): void {\n  const dir = getSessionDir(sessionId);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n// =============================================================================\n// EVENT GENERATION\n// =============================================================================\n\nlet eventCounter = 0;\n\n/**\n * Generate unique event ID\n */\nfunction generateEventId(): string {\n  eventCounter++;\n  return `evt-${Date.now()}-${eventCounter}`;\n}\n\n// =============================================================================\n// EVENT TRACKING\n// =============================================================================\n\n/**\n * Track a session event\n *\n * @param eventType - Type of event\n * @param name - Name of skill/agent/hook/tool\n * @param options - Additional event options\n */\nexport function trackEvent(\n  eventType: SessionEventType,\n  name: string,\n  options: {\n    input?: Record<string, unknown>;\n    output?: Record<string, unknown>;\n    duration_ms?: number;\n    success?: boolean;\n    context?: string;\n    confidence?: number;\n  } = {}\n): void {\n  try {\n    const event: SessionEvent = {\n      event_id: generateEventId(),\n      event_type: eventType,\n      identity: getIdentityContext(),\n      payload: {\n        name,\n        input: sanitizeForStorage(options.input),\n        output: sanitizeForStorage(options.output),\n        duration_ms: options.duration_ms,\n        success: options.success ?? true,\n        context: options.context ? truncate(options.context, 500) : undefined,\n        confidence: options.confidence,\n      },\n    };\n\n    ensureSessionDir();\n    const eventsPath = getEventsPath();\n    appendFileSync(eventsPath, JSON.stringify(event) + '\\n');\n\n    logHook('session-tracker', `Tracked ${eventType}: ${name}`, 'debug');\n  } catch (error) {\n    logHook('session-tracker', `Failed to track event: ${error}`, 'warn');\n  }\n}\n\n/**\n * Track skill invocation\n */\nexport function trackSkillInvoked(\n  skillName: string,\n  args?: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('skill_invoked', skillName, {\n    input: args ? { args } : undefined,\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track agent spawn\n */\nexport function trackAgentSpawned(\n  agentType: string,\n  prompt?: string,\n  success: boolean = true\n): void {\n  trackEvent('agent_spawned', agentType, {\n    input: prompt ? { prompt: truncate(prompt, 200) } : undefined,\n    success,\n  });\n}\n\n/**\n * Track hook triggered\n */\nexport function trackHookTriggered(\n  hookName: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('hook_triggered', hookName, {\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track decision made\n */\nexport function trackDecisionMade(\n  decision: string,\n  rationale?: string,\n  confidence?: number\n): void {\n  trackEvent('decision_made', 'decision', {\n    context: decision,\n    input: rationale ? { rationale } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track preference stated\n */\nexport function trackPreferenceStated(\n  preference: string,\n  confidence?: number\n): void {\n  trackEvent('preference_stated', 'preference', {\n    context: preference,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track problem reported\n */\nexport function trackProblemReported(problem: string): void {\n  trackEvent('problem_reported', 'problem', {\n    context: problem,\n    success: true,\n  });\n}\n\n/**\n * Track solution found\n */\nexport function trackSolutionFound(\n  solution: string,\n  problemId?: string,\n  confidence?: number\n): void {\n  trackEvent('solution_found', 'solution', {\n    context: solution,\n    input: problemId ? { problem_id: problemId } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track tool usage\n *\n * @param toolName - Name of the tool (e.g., 'Grep', 'Read')\n * @param success - Whether the tool call succeeded\n * @param durationMs - Duration of the tool call in milliseconds\n * @param category - Tool category (e.g., 'search', 'file_read') for preference tracking\n */\nexport function trackToolUsed(\n  toolName: string,\n  success: boolean = true,\n  durationMs?: number,\n  category?: string\n): void {\n  trackEvent('tool_used', toolName, {\n    success,\n    duration_ms: durationMs,\n    input: category ? { category } : undefined,\n  });\n}\n\n/**\n * Session context captured at session start\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport interface SessionContext {\n  /** Project directory path */\n  project_dir?: string;\n  /** Current git branch */\n  git_branch?: string;\n  /** Time of day category */\n  time_of_day?: 'morning' | 'afternoon' | 'evening' | 'night';\n  /** Timestamp */\n  started_at: string;\n}\n\n/**\n * Get time of day category from hour\n */\nfunction getTimeOfDay(hour: number): 'morning' | 'afternoon' | 'evening' | 'night' {\n  if (hour >= 5 && hour < 12) return 'morning';\n  if (hour >= 12 && hour < 17) return 'afternoon';\n  if (hour >= 17 && hour < 21) return 'evening';\n  return 'night';\n}\n\n/**\n * Track session start with context\n * Issue #245 Phase 5: Session Lifecycle Tracking\n *\n * @param context - Optional session context (project, branch, time)\n */\nexport function trackSessionStart(context?: Partial<SessionContext>): void {\n  const now = new Date();\n  const sessionContext: SessionContext = {\n    project_dir: context?.project_dir,\n    git_branch: context?.git_branch,\n    time_of_day: context?.time_of_day || getTimeOfDay(now.getHours()),\n    started_at: now.toISOString(),\n  };\n\n  trackEvent('session_start', 'session', {\n    success: true,\n    input: sessionContext as unknown as Record<string, unknown>,\n  });\n}\n\n/**\n * Track session end with timestamp\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport function trackSessionEnd(): void {\n  trackEvent('session_end', 'session', {\n    success: true,\n    input: { ended_at: new Date().toISOString() },\n  });\n}\n\n/**\n * Track user communication style\n */\nexport function trackCommunicationStyle(\n  style: {\n    verbosity: 'terse' | 'moderate' | 'detailed';\n    interaction_type: 'question' | 'command' | 'discussion';\n    technical_level: 'beginner' | 'intermediate' | 'expert';\n  }\n): void {\n  trackEvent('communication_style_detected', 'communication', {\n    input: style as unknown as Record<string, unknown>,\n    success: true,\n  });\n}\n\n\n// =============================================================================\n// SESSION SUMMARY\n// =============================================================================\n\n/**\n * Load all events for a session\n */\nexport function loadSessionEvents(sessionId?: string): SessionEvent[] {\n  const eventsPath = getEventsPath(sessionId);\n\n  if (!existsSync(eventsPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(eventsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    return lines.map(line => JSON.parse(line));\n  } catch (error) {\n    logHook('session-tracker', `Failed to load session events: ${error}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Generate session summary from events\n */\nexport function generateSessionSummary(sessionId?: string): SessionSummary {\n  const events = loadSessionEvents(sessionId);\n  const identity = getIdentityContext();\n\n  const eventCounts: Record<SessionEventType, number> = {\n    skill_invoked: 0,\n    agent_spawned: 0,\n    hook_triggered: 0,\n    decision_made: 0,\n    preference_stated: 0,\n    problem_reported: 0,\n    solution_found: 0,\n    tool_used: 0,\n    session_start: 0,\n    session_end: 0,\n    communication_style_detected: 0,\n  };\n\n  const skillsUsed = new Set<string>();\n  const agentsSpawned = new Set<string>();\n  const hooksTriggered = new Set<string>();\n\n  let startTime: string | undefined;\n  let endTime: string | undefined;\n\n  for (const event of events) {\n    eventCounts[event.event_type]++;\n\n    switch (event.event_type) {\n      case 'skill_invoked':\n        skillsUsed.add(event.payload.name);\n        break;\n      case 'agent_spawned':\n        agentsSpawned.add(event.payload.name);\n        break;\n      case 'hook_triggered':\n        hooksTriggered.add(event.payload.name);\n        break;\n      case 'session_start':\n        startTime = event.identity.timestamp;\n        break;\n      case 'session_end':\n        endTime = event.identity.timestamp;\n        break;\n    }\n  }\n\n  const durationMs =\n    startTime && endTime\n      ? new Date(endTime).getTime() - new Date(startTime).getTime()\n      : undefined;\n\n  return {\n    session_id: sessionId || identity.session_id,\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    start_time: startTime,\n    end_time: endTime,\n    duration_ms: durationMs,\n    event_counts: eventCounts,\n    skills_used: [...skillsUsed],\n    agents_spawned: [...agentsSpawned],\n    hooks_triggered: [...hooksTriggered],\n    decisions_made: eventCounts.decision_made,\n    problems_reported: eventCounts.problem_reported,\n    solutions_found: eventCounts.solution_found,\n  };\n}\n\n// =============================================================================\n// CROSS-SESSION QUERIES\n// =============================================================================\n\n/**\n * List all session IDs for this project\n */\nexport function listSessionIds(): string[] {\n  const sessionsDir = `${getProjectDir()}/.claude/memory/sessions`;\n\n  if (!existsSync(sessionsDir)) {\n    return [];\n  }\n\n  try {\n    return readdirSync(sessionsDir, { withFileTypes: true })\n      .filter(dirent => dirent.isDirectory())\n      .map(dirent => dirent.name);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get recent sessions for a user\n */\nexport function getRecentUserSessions(\n  userId: string,\n  limit: number = 10\n): SessionSummary[] {\n  const sessionIds = listSessionIds();\n  const summaries: SessionSummary[] = [];\n\n  for (const sessionId of sessionIds) {\n    const summary = generateSessionSummary(sessionId);\n    if (summary.user_id === userId) {\n      summaries.push(summary);\n    }\n    if (summaries.length >= limit * 2) break; // Stop early if we have enough candidates\n  }\n\n  // Sort by start_time descending and take limit\n  return summaries\n    .sort((a, b) => {\n      const timeA = a.start_time ? new Date(a.start_time).getTime() : 0;\n      const timeB = b.start_time ? new Date(b.start_time).getTime() : 0;\n      return timeB - timeA;\n    })\n    .slice(0, limit);\n}\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Truncate string to max length\n */\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return str.slice(0, maxLen - 3) + '...';\n}\n\n/**\n * Sanitize object for storage (remove sensitive data, truncate)\n */\nfunction sanitizeForStorage(\n  obj: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!obj) return undefined;\n\n  const sanitized: Record<string, unknown> = {};\n  const sensitiveKeys = ['password', 'secret', 'token', 'key', 'credential', 'auth'];\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip sensitive keys\n    if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {\n      sanitized[key] = '[REDACTED]';\n      continue;\n    }\n\n    // Truncate long strings\n    if (typeof value === 'string' && value.length > 500) {\n      sanitized[key] = truncate(value, 500);\n      continue;\n    }\n\n    // Recursively sanitize objects\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      sanitized[key] = sanitizeForStorage(value as Record<string, unknown>);\n      continue;\n    }\n\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n}\n", "/**\n * User Identity System\n * Resolves and manages user identity across sessions for multi-user decision capture.\n *\n * Identity Resolution Order:\n * 1. Explicit config (.claude/.user_identity.json)\n * 2. Git config (user.email, user.name)\n * 3. Environment variables (USER, USERNAME)\n * 4. Anonymous (machine-based hash)\n *\n * Privacy: User controls what gets shared via privacy settings.\n * Storage: User profiles stored locally in .claude/memory/users/\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport * as os from 'node:os';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * User identity source - where the identity was resolved from\n */\nexport type IdentitySource = 'config' | 'git' | 'env' | 'anonymous';\n\n/**\n * Resolved user identity\n */\nexport interface UserIdentity {\n  /** Unique user identifier (email, username, or anonymous hash) */\n  user_id: string;\n  /** Human-readable display name */\n  display_name: string;\n  /** Optional team/org identifier */\n  team_id?: string;\n  /** Machine identifier (hostname) */\n  machine_id: string;\n  /** How the identity was resolved */\n  source: IdentitySource;\n  /** Anonymous hash for global sharing (privacy-preserving) */\n  anonymous_id: string;\n  /** Email if available */\n  email?: string;\n}\n\n/**\n * User privacy settings - controls what gets shared\n */\nexport interface PrivacySettings {\n  /** Share patterns with team (same project) */\n  share_with_team: boolean;\n  /** Share patterns globally (anonymized) */\n  share_globally: boolean;\n  /** Share decisions */\n  share_decisions: boolean;\n  /** Share preferences */\n  share_preferences: boolean;\n  /** Share skill usage statistics */\n  share_skill_usage: boolean;\n  /** Share prompt content (usually false for privacy) */\n  share_prompts: boolean;\n  /** Anonymize user_id when sharing globally */\n  anonymize_globally: boolean;\n}\n\n/**\n * User identity configuration file format\n */\nexport interface UserIdentityConfig {\n  /** Explicit user ID */\n  user_id?: string;\n  /** Display name */\n  display_name?: string;\n  /** Team identifier */\n  team_id?: string;\n  /** Privacy settings */\n  privacy?: Partial<PrivacySettings>;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst IDENTITY_CONFIG_FILE = '.claude/.user_identity.json';\nconst SALT = 'orchestkit-user-identity-v1';\n\n/** Default privacy settings (conservative) */\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  share_with_team: true,\n  share_globally: false, // Opt-in\n  share_decisions: true,\n  share_preferences: true,\n  share_skill_usage: false, // Might reveal workflow\n  share_prompts: false, // Privacy sensitive\n  anonymize_globally: true,\n};\n\n// =============================================================================\n// CACHING\n// =============================================================================\n\nlet cachedIdentity: UserIdentity | null = null;\nlet cachedPrivacy: PrivacySettings | null = null;\n\n/**\n * Clear cached identity (for testing)\n */\nexport function clearIdentityCache(): void {\n  cachedIdentity = null;\n  cachedPrivacy = null;\n}\n\n// =============================================================================\n// IDENTITY RESOLUTION\n// =============================================================================\n\n/**\n * Generate anonymous hash from input\n */\nfunction generateAnonymousId(input: string): string {\n  return createHash('sha256')\n    .update(input + SALT)\n    .digest('hex')\n    .slice(0, 16);\n}\n\n/**\n * Get machine identifier\n */\nfunction getMachineId(): string {\n  try {\n    return os.hostname();\n  } catch {\n    return 'unknown-machine';\n  }\n}\n\n/**\n * Try to read explicit user config\n */\nfunction readUserConfig(projectDir: string): UserIdentityConfig | null {\n  const configPath = `${projectDir}/${IDENTITY_CONFIG_FILE}`;\n\n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    logHook('user-identity', `Failed to read user config: ${error}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Try to get identity from git config\n */\nfunction getGitIdentity(projectDir: string): { email?: string; name?: string } {\n  const result: { email?: string; name?: string } = {};\n\n  try {\n    result.email = execSync('git config user.email', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git email not configured\n  }\n\n  try {\n    result.name = execSync('git config user.name', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git name not configured\n  }\n\n  return result;\n}\n\n/**\n * Get identity from environment variables\n */\nfunction getEnvIdentity(): { username?: string } {\n  const username = process.env.USER || process.env.USERNAME || process.env.LOGNAME;\n  return { username };\n}\n\n/**\n * Resolve user identity using fallback chain\n *\n * Resolution order:\n * 1. Explicit config file\n * 2. Git config\n * 3. Environment username\n * 4. Anonymous (machine-based)\n */\nexport function resolveUserIdentity(projectDir?: string): UserIdentity {\n  // Return cached if available\n  if (cachedIdentity) {\n    return cachedIdentity;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const machineId = getMachineId();\n\n  // 1. Try explicit config\n  const config = readUserConfig(dir);\n  if (config?.user_id) {\n    cachedIdentity = {\n      user_id: config.user_id,\n      display_name: config.display_name || config.user_id,\n      team_id: config.team_id,\n      machine_id: machineId,\n      source: 'config',\n      anonymous_id: generateAnonymousId(config.user_id),\n      email: config.user_id.includes('@') ? config.user_id : undefined,\n    };\n    logHook('user-identity', `Resolved from config: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 2. Try git config\n  const git = getGitIdentity(dir);\n  if (git.email) {\n    cachedIdentity = {\n      user_id: git.email,\n      display_name: git.name || git.email.split('@')[0],\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'git',\n      anonymous_id: generateAnonymousId(git.email),\n      email: git.email,\n    };\n    logHook('user-identity', `Resolved from git: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 3. Try environment\n  const env = getEnvIdentity();\n  if (env.username) {\n    const userId = `${env.username}@${machineId}`;\n    cachedIdentity = {\n      user_id: userId,\n      display_name: env.username,\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'env',\n      anonymous_id: generateAnonymousId(userId),\n    };\n    logHook('user-identity', `Resolved from env: ${cachedIdentity.user_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 4. Anonymous fallback\n  const anonId = generateAnonymousId(machineId + process.pid);\n  cachedIdentity = {\n    user_id: `anon-${anonId.slice(0, 8)}`,\n    display_name: 'Anonymous',\n    team_id: config?.team_id,\n    machine_id: machineId,\n    source: 'anonymous',\n    anonymous_id: anonId,\n  };\n  logHook('user-identity', `Resolved as anonymous: ${cachedIdentity.user_id}`, 'debug');\n  return cachedIdentity;\n}\n\n// =============================================================================\n// PRIVACY SETTINGS\n// =============================================================================\n\n/**\n * Get user's privacy settings\n */\nexport function getPrivacySettings(projectDir?: string): PrivacySettings {\n  if (cachedPrivacy) {\n    return cachedPrivacy;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const config = readUserConfig(dir);\n\n  cachedPrivacy = {\n    ...DEFAULT_PRIVACY,\n    ...config?.privacy,\n  };\n\n  return cachedPrivacy;\n}\n\n/**\n * Check if user allows sharing a specific type of data\n */\nexport function canShare(\n  dataType: 'decisions' | 'preferences' | 'skill_usage' | 'prompts',\n  scope: 'team' | 'global'\n): boolean {\n  const privacy = getPrivacySettings();\n\n  // Check scope permission first\n  if (scope === 'team' && !privacy.share_with_team) return false;\n  if (scope === 'global' && !privacy.share_globally) return false;\n\n  // Check data type permission\n  switch (dataType) {\n    case 'decisions':\n      return privacy.share_decisions;\n    case 'preferences':\n      return privacy.share_preferences;\n    case 'skill_usage':\n      return privacy.share_skill_usage;\n    case 'prompts':\n      return privacy.share_prompts;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get user ID for sharing (applies anonymization if needed)\n */\nexport function getUserIdForScope(scope: 'local' | 'team' | 'global'): string {\n  const identity = resolveUserIdentity();\n  const privacy = getPrivacySettings();\n\n  if (scope === 'global' && privacy.anonymize_globally) {\n    return identity.anonymous_id;\n  }\n\n  return identity.user_id;\n}\n\n// =============================================================================\n// IDENTITY PERSISTENCE\n// =============================================================================\n\n/**\n * Save user identity config (creates or updates)\n */\nexport function saveUserIdentityConfig(\n  config: UserIdentityConfig,\n  projectDir?: string\n): boolean {\n  const dir = projectDir || getProjectDir();\n  const configPath = `${dir}/${IDENTITY_CONFIG_FILE}`;\n  const configDir = `${dir}/.claude`;\n\n  try {\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n    // Clear cache to pick up new config\n    clearIdentityCache();\n\n    logHook('user-identity', `Saved identity config to ${configPath}`, 'info');\n    return true;\n  } catch (error) {\n    logHook('user-identity', `Failed to save identity config: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// CONTEXT HELPERS\n// =============================================================================\n\n/**\n * Get full identity context for session events\n */\nexport interface IdentityContext {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  machine_id: string;\n  identity_source: IdentitySource;\n  timestamp: string;\n}\n\n/**\n * Get identity context for tagging events\n */\nexport function getIdentityContext(): IdentityContext {\n  const identity = resolveUserIdentity();\n\n  return {\n    session_id: getSessionId(),\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    machine_id: identity.machine_id,\n    identity_source: identity.source,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Get project-scoped user ID for mem0 storage\n * Format: {project}-{scope} (e.g., \"my-app-decisions\")\n */\nexport function getProjectUserId(scope: string): string {\n  const projectDir = getProjectDir();\n  const projectName = projectDir.split('/').pop() || 'unknown';\n  const sanitized = projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  return `${sanitized}-${scope}`;\n}\n\n/**\n * Get user-scoped ID for mem0 storage\n * Format: {user_id}-{scope} (e.g., \"alice@company.com-preferences\")\n */\nexport function getUserScopedId(scope: string): string {\n  const identity = resolveUserIdentity();\n  const sanitizedUserId = identity.user_id.toLowerCase().replace(/[^a-z0-9@.-]/g, '-');\n  return `${sanitizedUserId}-${scope}`;\n}\n\n/**\n * Get global scope ID (for cross-project best practices)\n */\nexport function getGlobalScopeId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n", "/**\n * Tool Categories\n * Issue #245 Phase 4: Tool Usage Tracking\n *\n * Maps Claude Code tools to semantic categories for:\n * - Usage pattern analysis\n * - Tool preference learning\n * - Workflow detection\n *\n * Categories align with user workflow intentions, not implementation details.\n */\n\n/**\n * Tool category types\n */\nexport type ToolCategory =\n  | 'search'        // Finding files/content: Grep, Glob, WebSearch\n  | 'file_read'     // Reading files: Read\n  | 'file_write'    // Creating files: Write\n  | 'file_edit'     // Modifying files: Edit, MultiEdit, NotebookEdit\n  | 'execution'     // Running commands: Bash\n  | 'agent'         // Spawning agents: Task\n  | 'skill'         // Invoking skills: Skill\n  | 'web'           // Web access: WebFetch, WebSearch\n  | 'interaction'   // User interaction: AskUserQuestion\n  | 'task_mgmt'     // Task management: TaskCreate, TaskUpdate, TaskList, TaskGet\n  | 'other';        // Unknown/uncategorized\n\n/**\n * Static tool \u2192 category mapping\n *\n * This mapping covers all known Claude Code tools as of CC 2.1.22.\n * Unknown tools default to 'other'.\n */\nexport const TOOL_CATEGORIES: Record<string, ToolCategory> = {\n  // Search tools - finding files and content\n  Grep: 'search',\n  Glob: 'search',\n  WebSearch: 'web',\n\n  // File reading\n  Read: 'file_read',\n\n  // File writing (creation)\n  Write: 'file_write',\n\n  // File editing (modification)\n  Edit: 'file_edit',\n  MultiEdit: 'file_edit',\n  NotebookEdit: 'file_edit',\n\n  // Execution\n  Bash: 'execution',\n\n  // Agent/skill invocation\n  Task: 'agent',\n  Skill: 'skill',\n\n  // Web access\n  WebFetch: 'web',\n\n  // User interaction\n  AskUserQuestion: 'interaction',\n\n  // Task management (CC 2.1.16)\n  TaskCreate: 'task_mgmt',\n  TaskUpdate: 'task_mgmt',\n  TaskList: 'task_mgmt',\n  TaskGet: 'task_mgmt',\n  TaskOutput: 'task_mgmt',\n  TaskStop: 'task_mgmt',\n\n  // Planning\n  EnterPlanMode: 'interaction',\n  ExitPlanMode: 'interaction',\n};\n\n/**\n * Get the category for a tool\n *\n * @param toolName - The name of the tool (e.g., 'Grep', 'Read')\n * @returns The tool's category, or 'other' if unknown\n *\n * @example\n * getToolCategory('Grep')  // 'search'\n * getToolCategory('Read')  // 'file_read'\n * getToolCategory('CustomTool')  // 'other'\n */\nexport function getToolCategory(toolName: string): ToolCategory {\n  return TOOL_CATEGORIES[toolName] || 'other';\n}\n\n/**\n * Get all tools in a category\n *\n * @param category - The category to look up\n * @returns Array of tool names in that category\n *\n * @example\n * getToolsInCategory('search')  // ['Grep', 'Glob']\n */\nexport function getToolsInCategory(category: ToolCategory): string[] {\n  return Object.entries(TOOL_CATEGORIES)\n    .filter(([, cat]) => cat === category)\n    .map(([tool]) => tool);\n}\n\n/**\n * Check if two tools are in the same category\n *\n * @param tool1 - First tool name\n * @param tool2 - Second tool name\n * @returns true if both tools are in the same category\n *\n * @example\n * areSameCategory('Grep', 'Glob')  // true (both 'search')\n * areSameCategory('Read', 'Write') // false\n */\nexport function areSameCategory(tool1: string, tool2: string): boolean {\n  return getToolCategory(tool1) === getToolCategory(tool2);\n}\n\n/**\n * Get a human-readable description of a category\n *\n * @param category - The category\n * @returns Description of what tools in this category do\n */\nexport function getCategoryDescription(category: ToolCategory): string {\n  const descriptions: Record<ToolCategory, string> = {\n    search: 'Finding files and content',\n    file_read: 'Reading file contents',\n    file_write: 'Creating new files',\n    file_edit: 'Modifying existing files',\n    execution: 'Running shell commands',\n    agent: 'Spawning specialized agents',\n    skill: 'Invoking skills',\n    web: 'Accessing web resources',\n    interaction: 'User interaction',\n    task_mgmt: 'Managing tasks',\n    other: 'Other operations',\n  };\n  return descriptions[category];\n}\n", "/**\n * User Tracking Hook\n * Issue #245: Multi-User Intelligent Decision Capture System\n *\n * Tracks tool usage, skill invocations, and agent spawns to build user profiles.\n * This data is aggregated into user profiles for personalized experiences.\n *\n * Tracked events:\n * - All tool usage (for workflow pattern detection)\n * - Skill invocations (when tool_name === 'Skill')\n * - Agent spawns (when tool_name === 'Task')\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport {\n  trackToolUsed,\n  trackSkillInvoked,\n  trackAgentSpawned,\n} from '../lib/session-tracker.js';\nimport { getToolCategory } from '../lib/tool-categories.js';\n\n/**\n * Extract skill name from Skill tool input\n */\nfunction extractSkillName(input: HookInput): string | undefined {\n  const toolInput = input.tool_input;\n  if (!toolInput || typeof toolInput !== 'object') return undefined;\n\n  // Skill tool uses 'skill' parameter\n  const skillParam = (toolInput as Record<string, unknown>).skill;\n  if (typeof skillParam === 'string') return skillParam;\n\n  return undefined;\n}\n\n/**\n * Extract agent type from Task tool input\n */\nfunction extractAgentType(input: HookInput): string | undefined {\n  const toolInput = input.tool_input;\n  if (!toolInput || typeof toolInput !== 'object') return undefined;\n\n  // Task tool uses 'subagent_type' parameter\n  const agentType = (toolInput as Record<string, unknown>).subagent_type;\n  if (typeof agentType === 'string') return agentType;\n\n  return undefined;\n}\n\n/**\n * Extract prompt summary from Task tool input\n */\nfunction extractPromptSummary(input: HookInput): string | undefined {\n  const toolInput = input.tool_input;\n  if (!toolInput || typeof toolInput !== 'object') return undefined;\n\n  const prompt = (toolInput as Record<string, unknown>).prompt;\n  if (typeof prompt === 'string') {\n    // Truncate to first 200 chars\n    return prompt.length > 200 ? prompt.slice(0, 200) + '...' : prompt;\n  }\n\n  return undefined;\n}\n\n/**\n * Determine if tool call was successful\n * For PostToolUse, we check tool_error\n */\nfunction wasSuccessful(input: HookInput): boolean {\n  // If is_error is explicitly set, use that\n  if (input.tool_error) return false;\n\n  // Otherwise assume success (PostToolUse runs after successful tool calls)\n  return true;\n}\n\n/**\n * User tracking hook - runs for all tools\n */\nexport function userTracking(input: HookInput): HookResult {\n  try {\n    const toolName = input.tool_name || 'unknown';\n    const success = wasSuccessful(input);\n    const category = getToolCategory(toolName);\n\n    // Track all tool usage with category for preference learning\n    trackToolUsed(toolName, success, undefined, category);\n\n    // Track skill invocations specifically\n    if (toolName === 'Skill') {\n      const skillName = extractSkillName(input);\n      if (skillName) {\n        trackSkillInvoked(skillName, undefined, success);\n        logHook('user-tracking', `Tracked skill: ${skillName}`, 'debug');\n      }\n    }\n\n    // Track agent spawns specifically\n    if (toolName === 'Task') {\n      const agentType = extractAgentType(input);\n      if (agentType) {\n        const promptSummary = extractPromptSummary(input);\n        trackAgentSpawned(agentType, promptSummary, success);\n        logHook('user-tracking', `Tracked agent: ${agentType}`, 'debug');\n      }\n    }\n\n    return outputSilentSuccess();\n  } catch (error) {\n    // Non-blocking - errors shouldn't affect user experience\n    logHook('user-tracking', `Error: ${error}`, 'warn');\n    return outputSilentSuccess();\n  }\n}\n", "/**\n * Session Metrics - Tracks tool usage statistics\n * CC 2.1.7 Compliant: Self-contained hook with stdin reading\n * Hook: PostToolUse (*)\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\nconst METRICS_FILE = '/tmp/claude-session-metrics.json';\nconst LOCKFILE = `${METRICS_FILE}.lock`;\n\ninterface SessionMetrics {\n  tools: Record<string, number>;\n  errors: number;\n  warnings: number;\n}\n\n/**\n * Track tool usage metrics\n */\nexport function sessionMetrics(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  if (!toolName) {\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Initialize metrics file if needed\n    let metrics: SessionMetrics = { tools: {}, errors: 0, warnings: 0 };\n\n    if (existsSync(METRICS_FILE)) {\n      try {\n        const content = readFileSync(METRICS_FILE, 'utf8').trim();\n        if (content) {\n          metrics = JSON.parse(content);\n        }\n      } catch {\n        // Invalid JSON, reinitialize\n        metrics = { tools: {}, errors: 0, warnings: 0 };\n      }\n    }\n\n    // Ensure tools object exists\n    if (!metrics.tools) {\n      metrics.tools = {};\n    }\n\n    // Increment tool counter\n    const currentCount = metrics.tools[toolName] || 0;\n    metrics.tools[toolName] = currentCount + 1;\n\n    // Write updated metrics\n    writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));\n  } catch (error) {\n    logHook('session-metrics', `Error updating metrics: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Edit Pattern Tracker - PostToolUse Hook\n * Tracks edit patterns after skill usage to enable skill evolution\n *\n * Part of: #58 (Skill Evolution System)\n * Triggers on: Write|Edit after skill usage\n * Action: Categorize and log edit patterns for evolution analysis\n * CC 2.1.7 Compliant\n *\n * Version: 1.0.2 - TypeScript port\n */\n\nimport { existsSync, readFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../lib/common.js';\n\n// Edit pattern categories with detection patterns\nconst PATTERN_DEFINITIONS: Array<{ name: string; regex: RegExp }> = [\n  // API/Backend patterns\n  { name: 'add_pagination', regex: /limit.*offset|page.*size|cursor.*pagination|paginate|Paginated/i },\n  { name: 'add_rate_limiting', regex: /rate.?limit|throttl|RateLimiter|requests.?per/i },\n  { name: 'add_caching', regex: /@cache|cache_key|TTL|redis|memcache|@cached/i },\n  { name: 'add_retry_logic', regex: /retry|backoff|max_attempts|tenacity|Retry/i },\n  // Error handling patterns\n  { name: 'add_error_handling', regex: /try.*catch|except|raise.*Exception|throw.*Error|error.*handler/i },\n  { name: 'add_validation', regex: /validate|Validator|@validate|Pydantic|Zod|yup|schema/i },\n  { name: 'add_logging', regex: /logger[.]|logging[.]|console[.]log|winston|pino|structlog/i },\n  // Type safety patterns\n  { name: 'add_types', regex: /: *(str|int|bool|List|Dict|Optional)|interface |type .*=/i },\n  { name: 'add_type_guards', regex: /isinstance|typeof|is.*Type|assert.*type/i },\n  // Code quality patterns\n  { name: 'add_docstring', regex: /docstring|\"\"\"[^\"]+\"\"\"|\\/\\*\\*/i },\n  { name: 'remove_comments', regex: /^-.*#|^-.*\\/\\/|^-.*\\*/m },\n  // Security patterns\n  { name: 'add_auth_check', regex: /@auth|@require_auth|isAuthenticated|requiresAuth|@login_required/i },\n  { name: 'add_input_sanitization', regex: /escape|sanitize|htmlspecialchars|DOMPurify/i },\n  // Testing patterns\n  { name: 'add_test_case', regex: /def test_|it\\(|describe\\(|expect\\(|assert|@pytest/i },\n  { name: 'add_mock', regex: /Mock|patch|jest[.]mock|vi[.]mock|MagicMock/i },\n  // Import/dependency patterns\n  { name: 'modify_imports', regex: /^[+-].*import|^[+-].*from.*import|^[+-].*require\\(/m },\n  // Async patterns\n  { name: 'add_async', regex: /async |await |Promise|asyncio|async def/i },\n];\n\n/**\n * Get recent skill usage from session state\n */\nfunction getRecentSkill(sessionStateFile: string): string {\n  if (!existsSync(sessionStateFile)) {\n    return '';\n  }\n\n  try {\n    const content = JSON.parse(readFileSync(sessionStateFile, 'utf8'));\n    const now = Math.floor(Date.now() / 1000);\n    const cutoff = now - 300; // 5 minutes\n\n    const recentSkills = (content.recentSkills || [])\n      .filter((s: { timestamp: number }) => s.timestamp > cutoff)\n      .sort((a: { timestamp: number }, b: { timestamp: number }) => b.timestamp - a.timestamp);\n\n    return recentSkills[0]?.skillId || '';\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Detect edit patterns in content diff\n */\nfunction detectPatterns(diffContent: string): string[] {\n  const detected: string[] = [];\n\n  for (const { name, regex } of PATTERN_DEFINITIONS) {\n    if (regex.test(diffContent)) {\n      detected.push(name);\n    }\n  }\n\n  return detected;\n}\n\n/**\n * Log edit pattern to JSONL file\n */\nfunction logEditPattern(\n  skillId: string,\n  filePath: string,\n  patterns: string[],\n  editPatternsFile: string\n): void {\n  const sessionId = getSessionId();\n  const timestamp = new Date().toISOString();\n\n  const entry = {\n    timestamp,\n    skill_id: skillId,\n    file_path: filePath,\n    session_id: sessionId,\n    patterns,\n  };\n\n  try {\n    mkdirSync(require('path').dirname(editPatternsFile), { recursive: true });\n    appendFileSync(editPatternsFile, JSON.stringify(entry) + '\\n');\n  } catch {\n    // Ignore write errors\n  }\n}\n\n/**\n * Track skill edit patterns\n */\nexport function skillEditTracker(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Write/Edit tools\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  // Get file path from tool input\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Get recently used skill\n  const projectDir = getProjectDir();\n  const sessionStateFile = `${projectDir}/.claude/session/state.json`;\n  const skillId = getRecentSkill(sessionStateFile);\n\n  if (!skillId) {\n    // No recent skill usage - nothing to track\n    return outputSilentSuccess();\n  }\n\n  // Get the diff/edit content\n  let editContent = '';\n\n  if (toolName === 'Edit') {\n    // For Edit tool, analyze old_string -> new_string diff\n    const oldString = getField<string>(input, 'tool_input.old_string') || '';\n    const newString = getField<string>(input, 'tool_input.new_string') || '';\n\n    if (oldString && newString) {\n      // Create pseudo-diff (+ for added, - for removed lines)\n      const oldLines = oldString.split('\\n');\n      const newLines = newString.split('\\n');\n      editContent = oldLines.map(l => `-${l}`).join('\\n') + '\\n' +\n                   newLines.map(l => `+${l}`).join('\\n');\n    }\n  } else {\n    // For Write tool, analyze the new content\n    editContent = getField<string>(input, 'tool_input.content') || '';\n  }\n\n  if (!editContent) {\n    return outputSilentSuccess();\n  }\n\n  // Detect patterns\n  const patterns = detectPatterns(editContent);\n\n  // Only log if patterns detected\n  if (patterns.length > 0) {\n    const editPatternsFile = `${projectDir}/.claude/feedback/edit-patterns.jsonl`;\n    logEditPattern(skillId, filePath, patterns, editPatternsFile);\n\n    // Debug log\n    if (process.env.CLAUDE_HOOK_DEBUG) {\n      logHook('skill-edit-tracker', `Detected ${patterns.length} patterns for ${skillId}: ${JSON.stringify(patterns)}`);\n    }\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n  blockedBy?: string[];\n  blocks?: string[];\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Get action-specific activeForm based on agent type\n */\nfunction getActiveFormForAgent(agent: string, description: string): string {\n  const actionMap: Record<string, string> = {\n    'backend-system-architect': 'Designing',\n    'frontend-ui-developer': 'Building',\n    'test-generator': 'Writing tests for',\n    'security-auditor': 'Auditing',\n    'workflow-architect': 'Architecting',\n    'database-engineer': 'Implementing database for',\n    'llm-integrator': 'Integrating LLM for',\n    'code-quality-reviewer': 'Reviewing',\n    'ux-researcher': 'Researching UX for',\n    'product-strategist': 'Strategizing',\n    'debug-investigator': 'Investigating',\n    'performance-engineer': 'Optimizing',\n    'accessibility-specialist': 'Auditing accessibility for',\n    'infrastructure-architect': 'Designing infrastructure for',\n    'data-pipeline-engineer': 'Building pipeline for',\n  };\n\n  const action = actionMap[agent] || 'Working on';\n  const shortDesc = description.slice(0, 40).toLowerCase();\n  return `${action} ${shortDesc}`;\n}\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: getActiveFormForAgent(agent, description),\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'deleted',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Generate TaskUpdate instruction for task deletion (CC 2.1.20)\n */\nexport function generateTaskDeleteInstruction(\n  taskId: string,\n  _reason: string\n): TaskUpdateInstruction {\n  return {\n    taskId,\n    status: 'deleted',\n  };\n}\n\n/**\n * Format TaskDelete instruction as markdown for Claude (CC 2.1.20)\n */\nexport function formatTaskDeleteForClaude(taskId: string, reason: string): string {\n  return `### Delete Orphaned Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${taskId}\"\n  status: \"deleted\"\n\\`\\`\\`\n\n**Reason**: ${reason}`;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number,\n  blockedBy?: string[],\n  blocks?: string[]\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n    blockedBy,\n    blocks,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get pending tasks blocked by a specific failed task (CC 2.1.20)\n */\nexport function getTasksBlockedBy(failedTaskId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks.filter(\n    t =>\n      t.status === 'pending' &&\n      t.blockedBy &&\n      t.blockedBy.includes(failedTaskId)\n  );\n}\n\n/**\n * Get orphaned tasks - pending tasks where all blockers have failed (CC 2.1.20)\n */\nexport function getOrphanedTasks(): TaskEntry[] {\n  const registry = loadRegistry();\n  const failedIds = new Set(\n    registry.tasks.filter(t => t.status === 'failed').map(t => t.taskId)\n  );\n\n  if (failedIds.size === 0) return [];\n\n  return registry.tasks.filter(t => {\n    if (t.status !== 'pending' || !t.blockedBy || t.blockedBy.length === 0) {\n      return false;\n    }\n    // Orphaned if ALL blockers are failed\n    return t.blockedBy.every(id => failedIds.has(id));\n  });\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Calibration Tracker - PostToolUse Hook for Tracking Task Completions\n * Issue #197: Agent Orchestration Layer\n *\n * Tracks agent task completions for calibration:\n * - Captures dispatch-outcome pairs\n * - Records to calibration engine\n * - Triggers on TaskUpdate tool calls\n *\n * CC 2.1.9 Compliant: Silent hook that tracks in background\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport { recordOutcome } from '../lib/calibration-engine.js';\nimport { getTaskById } from '../lib/task-integration.js';\nimport { getLastClassification, loadConfig } from '../lib/orchestration-state.js';\nimport type { AgentOutcome } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Extract task ID from TaskUpdate tool input\n */\nfunction extractTaskId(input: HookInput): string | null {\n  const toolInput = input.tool_input || {};\n\n  // TaskUpdate has taskId parameter\n  if (typeof toolInput.taskId === 'string') {\n    return toolInput.taskId;\n  }\n\n  return null;\n}\n\n/**\n * Check if this is a task status update\n */\nfunction isTaskStatusUpdate(input: HookInput): boolean {\n  if (input.tool_name !== 'TaskUpdate') {\n    return false;\n  }\n\n  const toolInput = input.tool_input || {};\n  return typeof toolInput.status === 'string';\n}\n\n/**\n * Map task status to agent outcome\n */\nfunction statusToOutcome(status: string): AgentOutcome | null {\n  switch (status) {\n    case 'completed':\n      return 'success';\n    case 'pending':\n      // Pending after in_progress might indicate failure\n      return null;\n    default:\n      return null;\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Calibration tracker hook\n *\n * Monitors TaskUpdate tool calls to track agent outcomes:\n * 1. Checks if this is a task status update to 'completed'\n * 2. Looks up the task to find associated agent\n * 3. Records outcome to calibration engine\n */\nexport function calibrationTracker(input: HookInput): HookResult {\n  // Only track TaskUpdate calls\n  if (!isTaskStatusUpdate(input)) {\n    return outputSilentSuccess();\n  }\n\n  // Check if calibration is enabled\n  const config = loadConfig();\n  if (!config.enableCalibration) {\n    return outputSilentSuccess();\n  }\n\n  const toolInput = input.tool_input || {};\n  const taskId = extractTaskId(input);\n  const status = toolInput.status as string;\n\n  if (!taskId) {\n    return outputSilentSuccess();\n  }\n\n  // Only track completions\n  const outcome = statusToOutcome(status);\n  if (!outcome) {\n    return outputSilentSuccess();\n  }\n\n  logHook('calibration-tracker', `Tracking task ${taskId} status update to ${status}`);\n\n  // Look up task\n  const task = getTaskById(taskId);\n  if (!task) {\n    logHook('calibration-tracker', `Task ${taskId} not found in registry`);\n    return outputSilentSuccess();\n  }\n\n  // Get agent from task\n  const agent = task.agent;\n  if (!agent) {\n    logHook('calibration-tracker', `No agent associated with task ${taskId}`);\n    return outputSilentSuccess();\n  }\n\n  // Get last classification for keywords\n  const lastClassification = getLastClassification();\n  const agentMatch = lastClassification?.agents.find(a => a.agent === agent);\n\n  const matchedKeywords = agentMatch?.matchedKeywords || [];\n  const confidence = task.confidence || agentMatch?.confidence || 0;\n\n  // Calculate duration if possible\n  const durationMs = task.createdAt\n    ? Date.now() - new Date(task.createdAt).getTime()\n    : undefined;\n\n  // Record to calibration engine\n  recordOutcome(\n    '', // Prompt not available in PostTool context\n    agent,\n    matchedKeywords,\n    confidence,\n    outcome,\n    durationMs\n  );\n\n  logHook(\n    'calibration-tracker',\n    `Recorded calibration: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n\n  return outputSilentSuccess();\n}\n", "/**\n * Pattern Extractor - Automatic pattern extraction from bash events\n * Part of OrchestKit Plugin - Cross-Project Patterns (#48) + Best Practices (#49)\n *\n * Automatically extracts patterns from:\n * - git commit messages\n * - gh pr merge\n * - test results (pass/fail)\n * - build results\n *\n * CC 2.1.9 Compliant: Uses additionalContext for pattern injection\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface PatternQueue {\n  patterns: PatternEntry[];\n}\n\ninterface PatternEntry {\n  text: string;\n  category: string;\n  outcome: string;\n  source: string;\n  timestamp: string;\n  project: string;\n}\n\n// Tech detection patterns\nconst TECH_PATTERNS: Record<string, RegExp> = {\n  JWT: /jwt|jsonwebtoken/i,\n  OAuth2: /oauth|oauth2/i,\n  PostgreSQL: /postgres|postgresql|psql/i,\n  Redis: /redis/i,\n  React: /react/i,\n  FastAPI: /fastapi/i,\n  SQLAlchemy: /sqlalchemy/i,\n  Alembic: /alembic/i,\n  'cursor-pagination': /cursor.based|keyset/i,\n  'offset-pagination': /offset.pagination/i,\n  WebSocket: /websocket/i,\n  SSE: /sse|server.sent/i,\n  GraphQL: /graphql/i,\n  REST: /rest.api|restful/i,\n};\n\n// Category patterns from commit prefixes\nconst CATEGORY_PATTERNS: Record<string, RegExp> = {\n  feature: /^feat:|^feature:/i,\n  bugfix: /^fix:|^bugfix:/i,\n  refactor: /^refactor:/i,\n  optimization: /^perf:|^performance:/i,\n  security: /^security:|^sec:/i,\n  testing: /^test:|^tests:/i,\n};\n\n// Best practice category detection\nconst BEST_PRACTICE_CATEGORIES: Record<string, RegExp> = {\n  pagination: /cursor|pagination|offset|limit|page/i,\n  caching: /cache|redis|memcache|ttl/i,\n  authentication: /auth|jwt|oauth|token|login/i,\n  validation: /validate|validation|schema|pydantic|zod/i,\n  testing: /test|spec|coverage|mock/i,\n  security: /security|encrypt|hash|secret|credential/i,\n  performance: /performance|optimize|cache|index/i,\n  error_handling: /error|exception|retry|fallback/i,\n};\n\n/**\n * Get project ID from directory\n */\nfunction getProjectId(): string {\n  const projectDir = getProjectDir();\n  return projectDir.split('/').pop() || 'unknown';\n}\n\n/**\n * Extract tech and pattern info from text\n */\nfunction extractPatternInfo(text: string): { tech: string; pattern: string } {\n  const textLower = text.toLowerCase();\n  let tech = 'unknown';\n  let pattern = 'general';\n\n  // Detect technologies\n  for (const [name, regex] of Object.entries(TECH_PATTERNS)) {\n    if (regex.test(textLower)) {\n      tech = name;\n      break;\n    }\n  }\n\n  // Detect patterns from commit prefixes\n  for (const [name, regex] of Object.entries(CATEGORY_PATTERNS)) {\n    if (regex.test(text)) {\n      pattern = name;\n      break;\n    }\n  }\n\n  return { tech, pattern };\n}\n\n/**\n * Detect best practice category\n */\nfunction detectBestPracticeCategory(text: string): string {\n  for (const [category, regex] of Object.entries(BEST_PRACTICE_CATEGORIES)) {\n    if (regex.test(text)) {\n      return category;\n    }\n  }\n  return 'general';\n}\n\n/**\n * Queue a pattern for storage (batched on session end)\n */\nfunction queuePattern(\n  text: string,\n  category: string,\n  outcome: string,\n  source: string,\n  patternsQueue: string\n): void {\n  const timestamp = new Date().toISOString();\n  const projectId = getProjectId();\n\n  // Initialize queue file if needed\n  if (!existsSync(patternsQueue)) {\n    try {\n      mkdirSync(require('path').dirname(patternsQueue), { recursive: true });\n      writeFileSync(patternsQueue, JSON.stringify({ patterns: [] }));\n    } catch {\n      return;\n    }\n  }\n\n  try {\n    const data: PatternQueue = JSON.parse(readFileSync(patternsQueue, 'utf8'));\n    data.patterns.push({\n      text,\n      category,\n      outcome,\n      source,\n      timestamp,\n      project: projectId,\n    });\n    writeFileSync(patternsQueue, JSON.stringify(data, null, 2));\n    logHook('pattern-extractor', `Queued pattern: category=${category} outcome=${outcome} source=${source}`);\n  } catch {\n    // Ignore queue errors\n  }\n}\n\n/**\n * Handle git commit pattern extraction\n */\nfunction handleGitCommit(command: string, exitCode: number, patternsQueue: string): void {\n  // Extract commit message\n  let commitMsg = '';\n  const msgMatch = command.match(/-m\\s+[\"']([^\"']+)[\"']/) ||\n                   command.match(/-m\\s+([^\\s]+)/);\n  if (msgMatch) {\n    commitMsg = msgMatch[1];\n  }\n\n  if (!commitMsg) {\n    return;\n  }\n\n  const { tech, pattern } = extractPatternInfo(commitMsg);\n  const category = detectBestPracticeCategory(commitMsg);\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n\n  // Build descriptive text\n  let patternText = commitMsg;\n  if (tech !== 'unknown') {\n    patternText = `[${tech}] ${commitMsg}`;\n  }\n\n  queuePattern(patternText, category, outcome, 'commit', patternsQueue);\n}\n\n/**\n * Handle PR merge pattern extraction\n */\nfunction handlePrMerge(command: string, exitCode: number, patternsQueue: string): void {\n  if (exitCode !== 0) {\n    return;\n  }\n\n  // PR merge is always a success pattern (reviewed code)\n  let prInfo = 'PR merged successfully';\n  const prMatch = command.match(/gh\\s+pr\\s+merge\\s+(\\d+)/);\n  if (prMatch) {\n    prInfo = `PR #${prMatch[1]} merged`;\n  }\n\n  queuePattern(prInfo, 'decision', 'success', 'pr-merge', patternsQueue);\n}\n\n/**\n * Handle test result pattern extraction\n */\nfunction handleTestResult(command: string, exitCode: number, patternsQueue: string): void {\n  let testFramework = 'unknown';\n\n  if (/pytest|py\\.test/.test(command)) testFramework = 'pytest';\n  else if (/jest/.test(command)) testFramework = 'jest';\n  else if (/vitest/.test(command)) testFramework = 'vitest';\n  else if (/npm\\s+test|yarn\\s+test|bun\\s+test/.test(command)) testFramework = 'npm-test';\n  else if (/go\\s+test/.test(command)) testFramework = 'go-test';\n\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n  const patternText = `Tests ${outcome === 'success' ? 'passed' : 'failed'} (${testFramework})`;\n\n  queuePattern(patternText, 'testing', outcome, 'test-run', patternsQueue);\n}\n\n/**\n * Handle build result pattern extraction\n */\nfunction handleBuildResult(command: string, exitCode: number, patternsQueue: string): void {\n  let buildTool = 'unknown';\n\n  if (/npm\\s+run\\s+build/.test(command)) buildTool = 'npm';\n  else if (/yarn\\s+build/.test(command)) buildTool = 'yarn';\n  else if (/cargo\\s+build/.test(command)) buildTool = 'cargo';\n  else if (/make/.test(command)) buildTool = 'make';\n  else if (/docker\\s+build/.test(command)) buildTool = 'docker';\n\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n  const patternText = `Build ${outcome === 'success' ? 'succeeded' : 'failed'} (${buildTool})`;\n\n  queuePattern(patternText, 'build', outcome, 'build', patternsQueue);\n}\n\n/**\n * Extract patterns from bash events\n */\nexport function patternExtractor(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  if (!command) {\n    return outputSilentSuccess();\n  }\n\n  const commandLower = command.toLowerCase();\n  const projectDir = getProjectDir();\n  const patternsQueue = `${projectDir}/.claude/feedback/patterns-queue.json`;\n\n  // Route to appropriate handler\n  if (/git\\s+commit/.test(commandLower)) {\n    handleGitCommit(command, exitCode, patternsQueue);\n  } else if (/gh\\s+pr\\s+merge/.test(commandLower)) {\n    handlePrMerge(command, exitCode, patternsQueue);\n  } else if (/pytest|jest|vitest|npm\\s+test|yarn\\s+test|bun\\s+test|go\\s+test/.test(commandLower)) {\n    handleTestResult(command, exitCode, patternsQueue);\n  } else if (/npm\\s+run\\s+build|yarn\\s+build|cargo\\s+build|make|docker\\s+build/.test(commandLower)) {\n    handleBuildResult(command, exitCode, patternsQueue);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Code Style Learner - Learn user's code style preferences from written code\n * Hook: PostToolUse/Write (#133)\n * CC 2.1.7 Compliant\n *\n * Tracks:\n * - Indentation (tabs vs spaces, indent size)\n * - Quote style (single vs double quotes)\n * - Naming patterns (detected from code)\n * - Import order (stdlib first, third-party, local)\n *\n * Storage: .claude/feedback/code-style-profile.json\n * Memory Fabric v2.1: Cross-project learning via patterns queue\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface StyleProfile {\n  version: string;\n  last_updated: string | null;\n  samples_count: number;\n  languages: Record<string, LanguageProfile>;\n  global_preferences: {\n    indentation: { style: string; size: number; confidence: number };\n    quotes: { style: string; confidence: number };\n  };\n}\n\ninterface LanguageProfile {\n  samples: number;\n  indentation: { tabs: number; spaces_2: number; spaces_4: number };\n  quotes: { single: number; double: number };\n  semicolons: { always: number; omit: number };\n  trailing_comma: { always: number; minimal: number };\n  type_hints: { used: number; not_used: number };\n  docstring_style: Record<string, number>;\n}\n\nconst CODE_EXTENSIONS = ['py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java'];\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py': return 'python';\n    case 'ts':\n    case 'tsx': return 'typescript';\n    case 'js':\n    case 'jsx': return 'javascript';\n    case 'go': return 'go';\n    case 'rs': return 'rust';\n    case 'java': return 'java';\n    default: return null;\n  }\n}\n\n/**\n * Detect indentation style from code content\n */\nfunction detectIndentation(content: string): { style: string; size: number } {\n  let tabCount = 0;\n  let space2Count = 0;\n  let space4Count = 0;\n\n  for (const line of content.split('\\n')) {\n    if (line.startsWith('\\t')) {\n      tabCount++;\n    } else if (line.startsWith('    ')) {\n      space4Count++;\n    } else if (line.match(/^  [^ ]/)) {\n      space2Count++;\n    }\n  }\n\n  if (tabCount > space2Count + space4Count) {\n    return { style: 'tabs', size: 1 };\n  }\n  if (space2Count > space4Count) {\n    return { style: 'spaces', size: 2 };\n  }\n  if (space4Count > 0) {\n    return { style: 'spaces', size: 4 };\n  }\n\n  return { style: 'unknown', size: 4 };\n}\n\n/**\n * Detect quote style from code content\n */\nfunction detectQuoteStyle(content: string): string {\n  const singleCount = (content.match(/'/g) || []).length;\n  const doubleCount = (content.match(/\"/g) || []).length;\n\n  return singleCount > doubleCount ? 'single' : 'double';\n}\n\n/**\n * Detect semicolon usage (JS/TS)\n */\nfunction detectSemicolonStyle(content: string): string {\n  let withSemi = 0;\n  let withoutSemi = 0;\n\n  for (const line of content.split('\\n')) {\n    // Skip empty lines and comments\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('*')) continue;\n\n    if (/;\\s*$/.test(line)) {\n      withSemi++;\n    } else if (/[a-zA-Z0-9\\)\\]\\'\\\"]\\\\s*$/.test(line)) {\n      withoutSemi++;\n    }\n  }\n\n  return withSemi > withoutSemi ? 'always' : 'omit';\n}\n\n/**\n * Detect trailing comma preference\n */\nfunction detectTrailingComma(content: string): string {\n  const trailingCount = (content.match(/,\\s*$/gm) || []).length;\n  return trailingCount > 5 ? 'always' : 'minimal';\n}\n\n/**\n * Detect Python-specific patterns\n */\nfunction detectPythonPatterns(content: string): { typeHints: boolean; docstringStyle: string } {\n  const hasTypeHints = /\\) -> |: [A-Z][a-zA-Z]+(\\[|$| =)/.test(content);\n\n  let docstringStyle = 'unknown';\n  if (/\"\"\"[^\"]+\"\"\"/.test(content)) {\n    if (/:param |:returns:|:raises:/.test(content)) {\n      docstringStyle = 'sphinx';\n    } else if (/Args:|Returns:|Raises:/.test(content)) {\n      docstringStyle = 'google';\n    } else if (/Parameters|Returns\\n-+/.test(content)) {\n      docstringStyle = 'numpy';\n    } else {\n      docstringStyle = 'simple';\n    }\n  }\n\n  return { typeHints: hasTypeHints, docstringStyle };\n}\n\n/**\n * Load or initialize style profile\n */\nfunction loadProfile(profilePath: string): StyleProfile {\n  if (existsSync(profilePath)) {\n    try {\n      return JSON.parse(readFileSync(profilePath, 'utf8'));\n    } catch {\n      // Invalid JSON, reinitialize\n    }\n  }\n\n  return {\n    version: '1.0.0',\n    last_updated: null,\n    samples_count: 0,\n    languages: {},\n    global_preferences: {\n      indentation: { style: 'unknown', size: 4, confidence: 0 },\n      quotes: { style: 'unknown', confidence: 0 },\n    },\n  };\n}\n\n/**\n * Update style profile with new observations\n */\nfunction updateProfile(\n  profile: StyleProfile,\n  language: string,\n  indentation: { style: string; size: number },\n  quoteStyle: string,\n  semiStyle: string,\n  trailingComma: string,\n  typeHints: boolean | null,\n  docstringStyle: string\n): void {\n  profile.last_updated = new Date().toISOString();\n  profile.samples_count++;\n\n  // Initialize language profile if needed\n  if (!profile.languages[language]) {\n    profile.languages[language] = {\n      samples: 0,\n      indentation: { tabs: 0, spaces_2: 0, spaces_4: 0 },\n      quotes: { single: 0, double: 0 },\n      semicolons: { always: 0, omit: 0 },\n      trailing_comma: { always: 0, minimal: 0 },\n      type_hints: { used: 0, not_used: 0 },\n      docstring_style: {},\n    };\n  }\n\n  const lang = profile.languages[language];\n  lang.samples++;\n\n  // Update indentation\n  if (indentation.style === 'tabs') {\n    lang.indentation.tabs++;\n  } else if (indentation.size === 2) {\n    lang.indentation.spaces_2++;\n  } else {\n    lang.indentation.spaces_4++;\n  }\n\n  // Update quotes\n  if (quoteStyle === 'single') {\n    lang.quotes.single++;\n  } else {\n    lang.quotes.double++;\n  }\n\n  // Update semicolons (JS/TS only)\n  if (semiStyle !== 'unknown') {\n    if (semiStyle === 'always') {\n      lang.semicolons.always++;\n    } else {\n      lang.semicolons.omit++;\n    }\n  }\n\n  // Update trailing comma\n  if (trailingComma !== 'unknown') {\n    if (trailingComma === 'always') {\n      lang.trailing_comma.always++;\n    } else {\n      lang.trailing_comma.minimal++;\n    }\n  }\n\n  // Update type hints (Python)\n  if (typeHints !== null) {\n    if (typeHints) {\n      lang.type_hints.used++;\n    } else {\n      lang.type_hints.not_used++;\n    }\n  }\n\n  // Update docstring style (Python)\n  if (docstringStyle !== 'unknown') {\n    lang.docstring_style[docstringStyle] = (lang.docstring_style[docstringStyle] || 0) + 1;\n  }\n}\n\n/**\n * Learn code style from written files\n */\nexport function codeStyleLearner(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Guard: Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Get file extension to determine language\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  if (!CODE_EXTENSIONS.includes(ext)) {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  // Try to get file content from tool_input or read the file\n  let content = getField<string>(input, 'tool_input.content') || '';\n\n  if (!content) {\n    const projectDir = getProjectDir();\n    const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n    if (existsSync(fullPath)) {\n      try {\n        // Read first 100 lines\n        content = readFileSync(fullPath, 'utf8').split('\\n').slice(0, 100).join('\\n');\n      } catch {\n        return outputSilentSuccess();\n      }\n    }\n  }\n\n  if (!content) {\n    return outputSilentSuccess();\n  }\n\n  // Analyze the code\n  const indentation = detectIndentation(content);\n  const quoteStyle = detectQuoteStyle(content);\n\n  let semiStyle = 'unknown';\n  let trailingComma = 'unknown';\n  let typeHints: boolean | null = null;\n  let docstringStyle = 'unknown';\n\n  // Language-specific detection\n  switch (language) {\n    case 'javascript':\n    case 'typescript':\n      semiStyle = detectSemicolonStyle(content);\n      trailingComma = detectTrailingComma(content);\n      break;\n    case 'python': {\n      const pyPatterns = detectPythonPatterns(content);\n      typeHints = pyPatterns.typeHints;\n      docstringStyle = pyPatterns.docstringStyle;\n      trailingComma = detectTrailingComma(content);\n      break;\n    }\n  }\n\n  // Load and update profile\n  const projectDir = getProjectDir();\n  const profilePath = `${projectDir}/.claude/feedback/code-style-profile.json`;\n\n  try {\n    mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n    const profile = loadProfile(profilePath);\n    updateProfile(profile, language, indentation, quoteStyle, semiStyle, trailingComma, typeHints, docstringStyle);\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n  } catch (error) {\n    logHook('code-style-learner', `Error updating profile: ${error}`);\n  }\n\n  logHook('code-style-learner',\n    `Analyzed ${language} file: indent=${indentation.style}(${indentation.size}) quotes=${quoteStyle}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Naming Convention Learner - Learn project naming conventions from written code\n * Hook: PostToolUse/Write (#134)\n * CC 2.1.7 Compliant\n *\n * Tracks:\n * - Variable naming (camelCase, snake_case, PascalCase, SCREAMING_CASE)\n * - Function naming patterns\n * - Class naming patterns\n * - File naming conventions\n * - Constant naming\n *\n * Storage: .claude/feedback/naming-conventions.json\n * Memory Fabric v2.1: Cross-project learning via patterns queue\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ntype NamingCase = 'camelCase' | 'snake_case' | 'PascalCase' | 'SCREAMING_SNAKE_CASE' | 'private_snake_case' | 'dunder' | 'mixed' | 'unknown';\n\ninterface NamingProfile {\n  version: string;\n  last_updated: string | null;\n  samples_count: number;\n  languages: Record<string, LanguageNamingProfile>;\n  file_naming: Record<string, number>;\n  detected_patterns: {\n    functions: Record<string, number>;\n    classes: Record<string, number>;\n    variables: Record<string, number>;\n    constants: Record<string, number>;\n    types: Record<string, number>;\n  };\n}\n\ninterface LanguageNamingProfile {\n  samples: number;\n  functions: Record<NamingCase, number>;\n  classes: Record<NamingCase, number>;\n  variables: Record<NamingCase, number>;\n  constants: Record<NamingCase, number>;\n  types: Record<NamingCase, number>;\n}\n\nconst CODE_EXTENSIONS = ['py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java'];\n\n/**\n * Detect naming case from an identifier\n */\nfunction detectCase(name: string): NamingCase {\n  if (name.length < 2 || /^[_0-9]+$/.test(name)) {\n    return 'unknown';\n  }\n\n  if (/^[A-Z][A-Z0-9_]*$/.test(name)) {\n    return 'SCREAMING_SNAKE_CASE';\n  }\n  if (/^[A-Z][a-zA-Z0-9]*$/.test(name)) {\n    return 'PascalCase';\n  }\n  if (/^[a-z][a-zA-Z0-9]*$/.test(name) && !name.includes('_')) {\n    return 'camelCase';\n  }\n  if (/^[a-z][a-z0-9_]*$/.test(name)) {\n    return 'snake_case';\n  }\n  if (/^_[a-z][a-z0-9_]*$/.test(name)) {\n    return 'private_snake_case';\n  }\n  if (/^__[a-z][a-z0-9_]*__$/.test(name)) {\n    return 'dunder';\n  }\n\n  return 'mixed';\n}\n\n/**\n * Extract Python identifiers from code\n */\nfunction extractPythonIdentifiers(content: string): {\n  functions: string[];\n  classes: string[];\n  variables: string[];\n  constants: string[];\n} {\n  const functions = (content.match(/def ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('def ', ''));\n\n  const classes = (content.match(/class ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('class ', ''));\n\n  const variables = (content.match(/^\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*=/gm) || [])\n    .map(m => m.replace(/\\s*=.*/, '').trim());\n\n  const constants = (content.match(/^([A-Z][A-Z0-9_]*)\\s*=/gm) || [])\n    .map(m => m.replace(/\\s*=.*/, '').trim());\n\n  return { functions, classes, variables, constants };\n}\n\n/**\n * Extract TypeScript/JavaScript identifiers from code\n */\nfunction extractJsIdentifiers(content: string): {\n  functions: string[];\n  classes: string[];\n  variables: string[];\n  interfaces: string[];\n  types: string[];\n} {\n  const functions = [\n    ...(content.match(/(function|async function) ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n      .map(m => m.replace(/(async )?function /, '')),\n    ...(content.match(/const ([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*\\(/g) || [])\n      .map(m => m.replace(/const /, '').replace(/\\s*=.*/, '')),\n  ];\n\n  const classes = (content.match(/class ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('class ', ''));\n\n  const interfaces = (content.match(/interface ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('interface ', ''));\n\n  const types = (content.match(/type ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('type ', ''));\n\n  const variables = (content.match(/(const|let|var) ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace(/(const|let|var) /, ''));\n\n  return { functions, classes, variables, interfaces, types };\n}\n\n/**\n * Count naming cases for a list of identifiers\n */\nfunction countCases(identifiers: string[]): Record<NamingCase, number> {\n  const counts: Record<NamingCase, number> = {\n    camelCase: 0,\n    snake_case: 0,\n    PascalCase: 0,\n    SCREAMING_SNAKE_CASE: 0,\n    private_snake_case: 0,\n    dunder: 0,\n    mixed: 0,\n    unknown: 0,\n  };\n\n  for (const name of identifiers) {\n    if (!name) continue;\n    const caseType = detectCase(name);\n    counts[caseType]++;\n  }\n\n  return counts;\n}\n\n/**\n * Detect file naming convention from file path\n */\nfunction detectFileNaming(filePath: string): string {\n  const filename = filePath.split('/').pop() || '';\n  const nameWithoutExt = filename.replace(/\\.[^.]+$/, '');\n\n  if (/^[a-z][a-z0-9_]*$/.test(nameWithoutExt)) {\n    return 'snake_case';\n  }\n  if (/^[a-z][a-z0-9-]*$/.test(nameWithoutExt)) {\n    return 'kebab-case';\n  }\n  if (/^[A-Z][a-zA-Z0-9]*$/.test(nameWithoutExt)) {\n    return 'PascalCase';\n  }\n  if (/^[a-z][a-zA-Z0-9]*$/.test(nameWithoutExt)) {\n    return 'camelCase';\n  }\n\n  return 'mixed';\n}\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py': return 'python';\n    case 'ts':\n    case 'tsx': return 'typescript';\n    case 'js':\n    case 'jsx': return 'javascript';\n    case 'go': return 'go';\n    case 'rs': return 'rust';\n    case 'java': return 'java';\n    default: return null;\n  }\n}\n\n/**\n * Load or initialize naming profile\n */\nfunction loadProfile(profilePath: string): NamingProfile {\n  if (existsSync(profilePath)) {\n    try {\n      return JSON.parse(readFileSync(profilePath, 'utf8'));\n    } catch {\n      // Invalid JSON, reinitialize\n    }\n  }\n\n  return {\n    version: '1.0.0',\n    last_updated: null,\n    samples_count: 0,\n    languages: {},\n    file_naming: {},\n    detected_patterns: {\n      functions: {},\n      classes: {},\n      variables: {},\n      constants: {},\n      types: {},\n    },\n  };\n}\n\n/**\n * Initialize language profile\n */\nfunction initLanguageProfile(): LanguageNamingProfile {\n  return {\n    samples: 0,\n    functions: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    classes: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    variables: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    constants: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    types: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n  };\n}\n\n/**\n * Learn naming conventions from written files\n */\nexport function namingConventionLearner(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Guard: Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Get file extension to determine language\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  if (!CODE_EXTENSIONS.includes(ext)) {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  // Try to get file content from tool_input or read the file\n  let content = getField<string>(input, 'tool_input.content') || '';\n\n  if (!content) {\n    const projectDir = getProjectDir();\n    const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n    if (existsSync(fullPath)) {\n      try {\n        // Read first 150 lines\n        content = readFileSync(fullPath, 'utf8').split('\\n').slice(0, 150).join('\\n');\n      } catch {\n        return outputSilentSuccess();\n      }\n    }\n  }\n\n  if (!content) {\n    return outputSilentSuccess();\n  }\n\n  // Detect file naming convention\n  const fileNaming = detectFileNaming(filePath);\n\n  // Extract identifiers based on language\n  let funcCases: Record<NamingCase, number> = countCases([]);\n  let classCases: Record<NamingCase, number> = countCases([]);\n  let varCases: Record<NamingCase, number> = countCases([]);\n  let constCases: Record<NamingCase, number> = countCases([]);\n  let typeCases: Record<NamingCase, number> = countCases([]);\n\n  switch (language) {\n    case 'python': {\n      const ids = extractPythonIdentifiers(content);\n      funcCases = countCases(ids.functions);\n      classCases = countCases(ids.classes);\n      varCases = countCases(ids.variables);\n      constCases = countCases(ids.constants);\n      break;\n    }\n    case 'typescript':\n    case 'javascript': {\n      const ids = extractJsIdentifiers(content);\n      funcCases = countCases(ids.functions);\n      classCases = countCases(ids.classes);\n      varCases = countCases(ids.variables);\n      typeCases = countCases([...ids.interfaces, ...ids.types]);\n      break;\n    }\n  }\n\n  // Load and update profile\n  const projectDir = getProjectDir();\n  const profilePath = `${projectDir}/.claude/feedback/naming-conventions.json`;\n\n  try {\n    mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n    const profile = loadProfile(profilePath);\n\n    // Update profile\n    profile.last_updated = new Date().toISOString();\n    profile.samples_count++;\n\n    // Update file naming counts\n    profile.file_naming[fileNaming] = (profile.file_naming[fileNaming] || 0) + 1;\n\n    // Initialize language entry if needed\n    if (!profile.languages[language]) {\n      profile.languages[language] = initLanguageProfile();\n    }\n\n    const lang = profile.languages[language];\n    lang.samples++;\n\n    // Update naming case counts\n    for (const caseType of Object.keys(funcCases) as NamingCase[]) {\n      lang.functions[caseType] = (lang.functions[caseType] || 0) + funcCases[caseType];\n      lang.classes[caseType] = (lang.classes[caseType] || 0) + classCases[caseType];\n      lang.variables[caseType] = (lang.variables[caseType] || 0) + varCases[caseType];\n      lang.constants[caseType] = (lang.constants[caseType] || 0) + constCases[caseType];\n      lang.types[caseType] = (lang.types[caseType] || 0) + typeCases[caseType];\n    }\n\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n  } catch (error) {\n    logHook('naming-convention-learner', `Error updating profile: ${error}`);\n  }\n\n  logHook('naming-convention-learner', `Analyzed ${language} file (${filePath}): file=${fileNaming}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Usage Optimizer - Track skill usage and suggest consolidation\n * Hook: PostToolUse (Skill)\n * Issue: #127 (CRITICAL)\n *\n * Tracks which skills are used and how often.\n * Stores metrics in .claude/feedback/skill-usage.json\n * Suggests skill consolidation if overlap detected.\n *\n * CC 2.1.9 Compliant: Uses additionalContext for suggestions\n * Version: 1.0.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../../lib/common.js';\n\ninterface SkillUsageFile {\n  version: string;\n  skills: Record<string, number>;\n  sessions: Record<string, string[]>;\n  last_updated: string;\n}\n\n// Skill overlap definitions for consolidation suggestions\nconst SKILL_OVERLAPS: Record<string, string> = {\n  'api-design-framework|fastapi-advanced': 'Both relate to API design. Consider using api-design-framework for patterns, fastapi-advanced for implementation.',\n  'sqlalchemy-2-async|database-schema-designer': 'Both relate to database. Use database-schema-designer for schema design, sqlalchemy-2-async for async patterns.',\n  'caching-strategies|performance-optimization': 'Both optimize performance. Consider consolidating caching queries.',\n  'auth-patterns|owasp-top-10': 'Both relate to security. auth-patterns for implementation, owasp-top-10 for validation.',\n  'asyncio-advanced|connection-pooling': 'Both relate to async. asyncio-advanced for patterns, connection-pooling for specific optimization.',\n};\n\n/**\n * Initialize usage file if it doesn't exist\n */\nfunction initUsageFile(usageFile: string): void {\n  if (!existsSync(usageFile)) {\n    try {\n      mkdirSync(require('path').dirname(usageFile), { recursive: true });\n      writeFileSync(usageFile, JSON.stringify({\n        version: '1.0',\n        skills: {},\n        sessions: {},\n        last_updated: '',\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Load usage data\n */\nfunction loadUsageData(usageFile: string): SkillUsageFile {\n  initUsageFile(usageFile);\n\n  try {\n    return JSON.parse(readFileSync(usageFile, 'utf8'));\n  } catch {\n    return {\n      version: '1.0',\n      skills: {},\n      sessions: {},\n      last_updated: '',\n    };\n  }\n}\n\n/**\n * Update skill usage count\n */\nfunction updateUsage(skill: string, sessionId: string, usageFile: string): void {\n  const data = loadUsageData(usageFile);\n  const timestamp = new Date().toISOString();\n\n  // Update skill count\n  data.skills[skill] = (data.skills[skill] || 0) + 1;\n\n  // Track session usage\n  if (!data.sessions[sessionId]) {\n    data.sessions[sessionId] = [];\n  }\n  if (!data.sessions[sessionId].includes(skill)) {\n    data.sessions[sessionId].push(skill);\n  }\n\n  // Update timestamp\n  data.last_updated = timestamp;\n\n  try {\n    writeFileSync(usageFile, JSON.stringify(data, null, 2));\n    logHook('skill-usage-optimizer', `Updated usage for skill: ${skill} (session: ${sessionId})`);\n  } catch {\n    // Ignore write errors\n  }\n}\n\n/**\n * Get session skills for overlap detection\n */\nfunction getSessionSkills(sessionId: string, usageFile: string): string[] {\n  const data = loadUsageData(usageFile);\n  return data.sessions[sessionId] || [];\n}\n\n/**\n * Check for skill overlaps and suggest consolidation\n */\nfunction checkOverlaps(currentSkill: string, sessionSkills: string[]): string | null {\n  for (const [overlapKey, suggestion] of Object.entries(SKILL_OVERLAPS)) {\n    const [skill1, skill2] = overlapKey.split('|');\n\n    // Check if current skill and any session skill form an overlap\n    if (currentSkill === skill1 || currentSkill === skill2) {\n      const otherSkill = currentSkill === skill1 ? skill2 : skill1;\n\n      if (sessionSkills.includes(otherSkill)) {\n        logHook('skill-usage-optimizer', `Overlap detected: ${skill1} + ${skill2}`);\n        return suggestion;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get top used skills for context\n */\nfunction getUsageStats(usageFile: string): string {\n  const data = loadUsageData(usageFile);\n\n  // Get top 3 skills with counts\n  const entries = Object.entries(data.skills);\n  if (entries.length === 0) return '';\n\n  return entries\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([skill, count]) => `${skill}:${count}`)\n    .join(', ');\n}\n\n/**\n * Track and optimize skill usage\n */\nexport function skillUsageOptimizer(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n  const skillName = getField<string>(input, 'tool_input.skill') ||\n                   getField<string>(input, 'tool_name') || '';\n\n  // Filter: Only process Skill tool uses\n  if (toolName !== 'Skill' && !skillName?.startsWith('skills/')) {\n    if (!skillName) {\n      return outputSilentSuccess();\n    }\n  }\n\n  if (!skillName) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n  const usageFile = `${projectDir}/.claude/feedback/skill-usage.json`;\n  const sessionId = getSessionId();\n\n  // Update usage\n  updateUsage(skillName, sessionId, usageFile);\n\n  // Check for overlaps\n  const sessionSkills = getSessionSkills(sessionId, usageFile);\n  const overlapSuggestion = checkOverlaps(skillName, sessionSkills);\n\n  // Get usage stats\n  const usageStats = getUsageStats(usageFile);\n\n  // Build context message if we have suggestions or stats\n  let contextMsg = '';\n\n  if (overlapSuggestion) {\n    contextMsg = `Skill overlap: ${overlapSuggestion}`;\n    logHook('skill-usage-optimizer', `Suggesting consolidation for: ${skillName}`);\n  }\n\n  // Add stats info periodically (every 5th use of any skill)\n  const data = loadUsageData(usageFile);\n  const currentSkillCount = data.skills[skillName] || 0;\n\n  if (currentSkillCount > 0 && currentSkillCount % 5 === 0 && usageStats) {\n    if (contextMsg) {\n      contextMsg = `${contextMsg} | Top skills: ${usageStats}`;\n    } else {\n      contextMsg = `Top skills this project: ${usageStats}`;\n    }\n  }\n\n  // Output with context if we have something to say\n  if (contextMsg) {\n    // Truncate if too long\n    if (contextMsg.length > 200) {\n      contextMsg = contextMsg.substring(0, 197) + '...';\n    }\n\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        additionalContext: contextMsg,\n      },\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Issue Progress Commenter - Queue commit progress for GitHub issue updates\n * Part of OrchestKit Plugin - Issue Progress Tracking\n *\n * Triggers: After successful git commit commands\n * Function: Extracts issue number from branch name or commit message and queues\n *           progress for batch commenting at session end\n *\n * CC 2.1.9 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getSessionId, logHook } from '../../lib/common.js';\n\ninterface ProgressFile {\n  session_id: string;\n  issues: Record<string, IssueProgress>;\n}\n\ninterface IssueProgress {\n  commits: CommitInfo[];\n  tasks_completed: string[];\n  pr_url: string | null;\n  branch: string;\n}\n\ninterface CommitInfo {\n  sha: string;\n  message: string;\n  timestamp: string;\n}\n\n/**\n * Extract issue number from branch name (e.g., issue/123-description, fix/123-bug)\n */\nfunction extractIssueFromBranch(branch: string): string | null {\n  // Pattern: issue/123-*, fix/123-*, feature/123-*, etc.\n  let match = branch.match(/^(issue|fix|feature|bug|feat)\\/(\\d+)/);\n  if (match) {\n    return match[2];\n  }\n\n  // Pattern: 123-description (issue number at start)\n  match = branch.match(/^(\\d+)-/);\n  if (match) {\n    return match[1];\n  }\n\n  return null;\n}\n\n/**\n * Extract issue number from commit message (e.g., \"fix(#123): message\" or \"closes #123\")\n */\nfunction extractIssueFromCommit(message: string): string | null {\n  // Pattern: (#123) or #123 in message\n  let match = message.match(/#(\\d+)/);\n  if (match) {\n    return match[1];\n  }\n\n  // Pattern: fixes/closes/resolves #123\n  match = message.match(/(fix|fixes|close|closes|resolve|resolves)\\s+#?(\\d+)/i);\n  if (match) {\n    return match[2];\n  }\n\n  return null;\n}\n\n/**\n * Get current branch name\n */\nfunction getCurrentBranch(): string {\n  try {\n    return execSync('git branch --show-current 2>/dev/null || git rev-parse --abbrev-ref HEAD 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Get latest commit info\n */\nfunction getLatestCommit(): CommitInfo | null {\n  try {\n    const sha = execSync('git rev-parse --short HEAD 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    const message = execSync('git log -1 --pretty=%s 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    const timestamp = execSync('git log -1 --pretty=%cI 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim() || new Date().toISOString();\n\n    return { sha, message, timestamp };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Initialize progress file if needed\n */\nfunction initProgressFile(progressFile: string, sessionId: string): void {\n  if (!existsSync(progressFile)) {\n    try {\n      mkdirSync(require('path').dirname(progressFile), { recursive: true });\n      writeFileSync(progressFile, JSON.stringify({\n        session_id: sessionId,\n        issues: {},\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Add commit to issue progress queue\n */\nfunction queueCommitProgress(\n  issueNum: string,\n  commit: CommitInfo,\n  branch: string,\n  progressFile: string,\n  sessionId: string\n): boolean {\n  initProgressFile(progressFile, sessionId);\n\n  try {\n    const data: ProgressFile = JSON.parse(readFileSync(progressFile, 'utf8'));\n\n    if (!data.issues[issueNum]) {\n      data.issues[issueNum] = {\n        commits: [],\n        tasks_completed: [],\n        pr_url: null,\n        branch,\n      };\n    }\n\n    data.issues[issueNum].commits.push(commit);\n    data.issues[issueNum].branch = branch;\n\n    writeFileSync(progressFile, JSON.stringify(data, null, 2));\n    logHook('issue-progress-commenter', `Queued commit for issue #${issueNum}`);\n    return true;\n  } catch {\n    logHook('issue-progress-commenter', `Error queuing commit for issue #${issueNum}`);\n    return false;\n  }\n}\n\n/**\n * Queue commit progress for GitHub issue updates\n */\nexport function issueProgressCommenter(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  // Only process successful git commit commands\n  if (!/git\\s+commit/i.test(command) || exitCode !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-progress-commenter', 'Processing git commit command...');\n\n  // Check if gh CLI is available\n  try {\n    execSync('which gh', { stdio: 'ignore', timeout: 2000 });\n  } catch {\n    logHook('issue-progress-commenter', 'gh CLI not available, skipping issue progress tracking');\n    return outputSilentSuccess();\n  }\n\n  // Check if we're in a git repo with GitHub remote\n  try {\n    const remote = execSync('git remote get-url origin 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    });\n    if (!remote.includes('github')) {\n      logHook('issue-progress-commenter', 'Not a GitHub repository, skipping');\n      return outputSilentSuccess();\n    }\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Get branch and commit info\n  const branch = getCurrentBranch();\n  if (!branch) {\n    logHook('issue-progress-commenter', 'Could not determine current branch');\n    return outputSilentSuccess();\n  }\n\n  // Try to extract issue number\n  let issueNum = extractIssueFromBranch(branch);\n\n  // If not found in branch, try commit message\n  if (!issueNum) {\n    try {\n      const commitMsg = execSync('git log -1 --pretty=%s 2>/dev/null', {\n        encoding: 'utf8',\n        timeout: 5000,\n      }).trim();\n      issueNum = extractIssueFromCommit(commitMsg);\n    } catch {\n      // Ignore\n    }\n  }\n\n  // If no issue number found, skip silently\n  if (!issueNum) {\n    logHook('issue-progress-commenter', `No issue number found in branch '${branch}' or commit message`);\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-progress-commenter', `Found issue #${issueNum}`);\n\n  // Verify issue exists (quick check)\n  try {\n    execSync(`gh issue view ${issueNum} --json number`, { stdio: 'ignore', timeout: 5000 });\n  } catch {\n    logHook('issue-progress-commenter', `Issue #${issueNum} not found or not accessible`);\n    return outputSilentSuccess();\n  }\n\n  // Get commit info and queue it\n  const commit = getLatestCommit();\n  if (!commit) {\n    logHook('issue-progress-commenter', 'Could not get commit info');\n    return outputSilentSuccess();\n  }\n\n  // Sanitize session ID - prefer input.session_id, fallback to getSessionId()\n  const sessionId = (input.session_id || getSessionId()).replace(/[^a-zA-Z0-9_-]/g, '');\n  const progressFile = `/tmp/claude-session-${sessionId}/issue-progress.json`;\n\n  queueCommitProgress(issueNum, commit, branch, progressFile, sessionId);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Issue Subtask Updater - Auto-update issue checkboxes based on commit messages\n * Part of OrchestKit Plugin - Issue Progress Tracking\n *\n * Triggers: After successful git commit commands\n * Function: Parses commit message for task completion keywords and updates\n *           corresponding checkboxes in the GitHub issue body\n *\n * CC 2.1.9 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getSessionId, logHook } from '../../lib/common.js';\n\ninterface ProgressFile {\n  session_id: string;\n  issues: Record<string, IssueProgress>;\n}\n\ninterface IssueProgress {\n  commits: unknown[];\n  tasks_completed: string[];\n  pr_url: string | null;\n}\n\n/**\n * Extract action and subject from commit message\n * e.g., \"feat(#123): Add input validation\" -> \"Add input validation\"\n */\nfunction extractTaskFromCommit(message: string): string {\n  // Remove conventional commit prefix: type(scope):\n  let task = message.replace(/^[a-z]+(\\([^)]*\\))?:\\s*/i, '');\n\n  // Remove issue references like (#123)\n  task = task.replace(/\\(#\\d+\\)/g, '');\n\n  return task.trim();\n}\n\n/**\n * Normalize text for comparison (lowercase, remove extra spaces)\n */\nfunction normalizeText(text: string): string {\n  return text.toLowerCase().replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Check if commit task matches a checkbox item\n */\nfunction matchesCheckbox(commitTask: string, checkboxText: string): boolean {\n  const normCommit = normalizeText(commitTask);\n  const normCheckbox = normalizeText(checkboxText);\n\n  // Exact match (after normalization)\n  if (normCommit === normCheckbox) {\n    return true;\n  }\n\n  // Commit task contains checkbox text\n  if (normCommit.includes(normCheckbox)) {\n    return true;\n  }\n\n  // Checkbox text contains commit task\n  if (normCheckbox.includes(normCommit)) {\n    return true;\n  }\n\n  // Check if they share significant words (at least 2 words matching)\n  const commitWords = new Set(normCommit.split(' ').filter(w => w.length >= 3));\n  const checkboxWords = normCheckbox.split(' ').filter(w => w.length >= 3);\n  let matchingWords = 0;\n\n  for (const word of checkboxWords) {\n    if (commitWords.has(word)) {\n      matchingWords++;\n    }\n  }\n\n  return matchingWords >= 2;\n}\n\n/**\n * Extract issue number from branch name\n */\nfunction extractIssueFromBranch(branch: string): string | null {\n  let match = branch.match(/^(issue|fix|feature|bug|feat)\\/(\\d+)/);\n  if (match) {\n    return match[2];\n  }\n\n  match = branch.match(/^(\\d+)-/);\n  if (match) {\n    return match[1];\n  }\n\n  return null;\n}\n\n/**\n * Extract issue number from commit message\n */\nfunction extractIssueFromCommit(message: string): string | null {\n  const match = message.match(/#(\\d+)/);\n  return match ? match[1] : null;\n}\n\n/**\n * Get unchecked tasks from issue body\n */\nfunction getUncheckedTasks(issueNum: string): string[] {\n  try {\n    const body = execSync(`gh issue view ${issueNum} --json body -q '.body' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 10000,\n    });\n\n    // Extract unchecked checkbox items: - [ ] text\n    const lines = body.split('\\n');\n    const unchecked: string[] = [];\n\n    for (const line of lines) {\n      const match = line.match(/^\\s*-\\s*\\[\\s*\\]\\s+(.+)/);\n      if (match) {\n        unchecked.push(match[1].trim());\n      }\n    }\n\n    return unchecked;\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Update a checkbox from unchecked to checked\n */\nfunction updateCheckbox(issueNum: string, checkboxText: string): boolean {\n  logHook('issue-subtask-updater', `Attempting to update checkbox: '${checkboxText}' in issue #${issueNum}`);\n\n  try {\n    // Get current body\n    const body = execSync(`gh issue view ${issueNum} --json body -q '.body' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 10000,\n    });\n\n    // Escape special regex characters in checkbox text\n    const escapedText = checkboxText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    // Replace unchecked with checked\n    const updatedBody = body.replace(\n      new RegExp(`(^\\\\s*-\\\\s*)\\\\[\\\\s*\\\\](\\\\s+${escapedText})`, 'm'),\n      '$1[x]$2'\n    );\n\n    // Check if anything changed\n    if (body === updatedBody) {\n      logHook('issue-subtask-updater', `No change needed for checkbox: '${checkboxText}'`);\n      return false;\n    }\n\n    // Get repo info\n    const repo = execSync(`gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    // Update issue body via API\n    const bodyJson = JSON.stringify(updatedBody);\n    execSync(`gh api -X PATCH \"repos/${repo}/issues/${issueNum}\" -f body=${bodyJson}`, {\n      stdio: 'ignore',\n      timeout: 10000,\n    });\n\n    logHook('issue-subtask-updater', `Successfully updated checkbox: '${checkboxText}'`);\n    return true;\n  } catch (error) {\n    logHook('issue-subtask-updater', `Failed to update issue body: ${error}`);\n    return false;\n  }\n}\n\n/**\n * Record completed task in progress file\n */\nfunction recordTaskCompletion(issueNum: string, taskText: string, progressFile: string): void {\n  if (!existsSync(progressFile)) {\n    return;\n  }\n\n  try {\n    const data: ProgressFile = JSON.parse(readFileSync(progressFile, 'utf8'));\n\n    if (!data.issues[issueNum]) {\n      data.issues[issueNum] = {\n        commits: [],\n        tasks_completed: [],\n        pr_url: null,\n      };\n    }\n\n    if (!data.issues[issueNum].tasks_completed.includes(taskText)) {\n      data.issues[issueNum].tasks_completed.push(taskText);\n      writeFileSync(progressFile, JSON.stringify(data, null, 2));\n    }\n  } catch {\n    // Ignore errors\n  }\n}\n\n/**\n * Update issue subtasks based on commit\n */\nexport function issueSubtaskUpdater(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  // Only process successful git commit commands\n  if (!/git\\s+commit/i.test(command) || exitCode !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', 'Processing git commit for subtask updates...');\n\n  // Check if gh CLI is available\n  try {\n    execSync('which gh', { stdio: 'ignore', timeout: 2000 });\n  } catch {\n    logHook('issue-subtask-updater', 'gh CLI not available, skipping subtask updates');\n    return outputSilentSuccess();\n  }\n\n  // Check if we're in a git repo with GitHub remote\n  try {\n    const remote = execSync('git remote get-url origin 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    });\n    if (!remote.includes('github')) {\n      logHook('issue-subtask-updater', 'Not a GitHub repository, skipping');\n      return outputSilentSuccess();\n    }\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Get branch and commit message\n  let branch = '';\n  let commitMsg = '';\n\n  try {\n    branch = execSync('git branch --show-current 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    commitMsg = execSync('git log -1 --pretty=%s 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Extract issue number\n  let issueNum = extractIssueFromBranch(branch);\n  if (!issueNum) {\n    issueNum = extractIssueFromCommit(commitMsg);\n  }\n\n  if (!issueNum) {\n    logHook('issue-subtask-updater', 'No issue number found');\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', `Found issue #${issueNum}, checking for matching subtasks...`);\n\n  // Extract task from commit message\n  const commitTask = extractTaskFromCommit(commitMsg);\n  if (!commitTask) {\n    logHook('issue-subtask-updater', 'Could not extract task from commit message');\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', `Commit task: '${commitTask}'`);\n\n  // Get unchecked tasks from issue\n  const uncheckedTasks = getUncheckedTasks(issueNum);\n  if (uncheckedTasks.length === 0) {\n    logHook('issue-subtask-updater', `No unchecked tasks in issue #${issueNum}`);\n    return outputSilentSuccess();\n  }\n\n  // Check each unchecked task for a match\n  let matched = false;\n  const sessionId = (input.session_id || getSessionId()).replace(/[^a-zA-Z0-9_-]/g, '');\n  const progressFile = `/tmp/claude-session-${sessionId}/issue-progress.json`;\n\n  for (const checkboxText of uncheckedTasks) {\n    if (matchesCheckbox(commitTask, checkboxText)) {\n      logHook('issue-subtask-updater', `Found matching checkbox: '${checkboxText}'`);\n\n      if (updateCheckbox(issueNum, checkboxText)) {\n        recordTaskCompletion(issueNum, checkboxText, progressFile);\n        matched = true;\n      }\n    }\n  }\n\n  if (!matched) {\n    logHook('issue-subtask-updater', `No matching checkboxes found for task: '${commitTask}'`);\n    return outputSilentSuccess();\n  }\n\n  // Provide additionalContext to Claude when tasks are updated (CC 2.1.9)\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: `Issue #${issueNum}: Automatically marked sub-task as complete based on commit.`,\n    },\n  };\n}\n", "/**\n * Unified PostToolUse Dispatcher\n * Issue #235: Hook Architecture Refactor\n *\n * Consolidates multiple async PostToolUse hooks into a single dispatcher.\n * This reduces the number of \"Async hook completed\" messages from ~14 to 1.\n *\n * CC 2.1.19 Compliant: Single async hook with internal routing\n *\n * NOTE: Async hooks are fire-and-forget by design. They can only return\n * { async: true, asyncTimeout } - fields like systemMessage, continue,\n * decision are NOT processed by Claude Code for async hooks.\n * Failures are logged to file but not surfaced to users.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\n// Import individual hook implementations\nimport { sessionMetrics } from './session-metrics.js';\nimport { auditLogger } from './audit-logger.js';\nimport { calibrationTracker } from './calibration-tracker.js';\nimport { patternExtractor } from './bash/pattern-extractor.js';\nimport { codeStyleLearner } from './write/code-style-learner.js';\nimport { namingConventionLearner } from './write/naming-convention-learner.js';\nimport { skillEditTracker } from './skill-edit-tracker.js';\nimport { coordinationHeartbeat } from './coordination-heartbeat.js';\nimport { skillUsageOptimizer } from './skill/skill-usage-optimizer.js';\nimport { memoryBridge } from './memory-bridge.js';\nimport { realtimeSync } from './realtime-sync.js';\nimport { issueProgressCommenter } from './bash/issue-progress-commenter.js';\nimport { issueSubtaskUpdater } from './bash/issue-subtask-updater.js';\nimport { mem0WebhookHandler } from './mem0-webhook-handler.js';\nimport { userTracking } from './user-tracking.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult | Promise<HookResult>;\n\ninterface HookConfig {\n  name: string;\n  fn: HookFn;\n  matcher: string | string[];\n}\n\n// -----------------------------------------------------------------------------\n// Hook Registry\n// -----------------------------------------------------------------------------\n\n/**\n * Registry of all async PostToolUse hooks consolidated into dispatcher\n */\nconst HOOKS: HookConfig[] = [\n  // Wildcard matchers (run for all tools)\n  { name: 'session-metrics', fn: sessionMetrics, matcher: '*' },\n  { name: 'audit-logger', fn: auditLogger, matcher: '*' },\n  { name: 'calibration-tracker', fn: calibrationTracker, matcher: '*' },\n\n  // Bash-specific\n  { name: 'pattern-extractor', fn: patternExtractor, matcher: 'Bash' },\n  { name: 'issue-progress-commenter', fn: issueProgressCommenter, matcher: 'Bash' },\n  { name: 'issue-subtask-updater', fn: issueSubtaskUpdater, matcher: 'Bash' },\n  { name: 'mem0-webhook-handler', fn: mem0WebhookHandler, matcher: 'Bash' },\n\n  // Write/Edit-specific\n  { name: 'code-style-learner', fn: codeStyleLearner, matcher: ['Write', 'Edit'] },\n  { name: 'naming-convention-learner', fn: namingConventionLearner, matcher: ['Write', 'Edit'] },\n  { name: 'skill-edit-tracker', fn: skillEditTracker, matcher: ['Write', 'Edit'] },\n\n  // Task-specific\n  { name: 'coordination-heartbeat', fn: coordinationHeartbeat, matcher: 'Task' },\n\n  // Skill-specific\n  { name: 'skill-usage-optimizer', fn: skillUsageOptimizer, matcher: 'Skill' },\n\n  // MCP memory-specific\n  { name: 'memory-bridge', fn: memoryBridge, matcher: ['mcp__mem0__add_memory', 'mcp__memory__create_entities'] },\n\n  // Multi-tool matcher\n  { name: 'realtime-sync', fn: realtimeSync, matcher: ['Bash', 'Write', 'Edit', 'Skill', 'Task'] },\n\n  // User tracking (Issue #245) - tracks all tool usage, skills, and agents\n  { name: 'user-tracking', fn: userTracking, matcher: '*' },\n];\n\n/** Exposed for registry wiring tests */\nexport const registeredHookNames = () => HOOKS.map(h => h.name);\n\n/** Exposed for registry wiring tests */\nexport const registeredHookMatchers = () => HOOKS.map(h => ({ name: h.name, matcher: h.matcher }));\n\n// -----------------------------------------------------------------------------\n// Matcher Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Check if a tool matches a matcher pattern\n * Exported for direct unit testing\n */\nexport function matchesTool(toolName: string, matcher: string | string[]): boolean {\n  if (matcher === '*') return true;\n\n  if (Array.isArray(matcher)) {\n    return matcher.includes(toolName);\n  }\n\n  return toolName === matcher;\n}\n\n// -----------------------------------------------------------------------------\n// Dispatcher Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Unified dispatcher that runs all matching hooks in parallel\n *\n * Benefits:\n * - Single \"Async hook completed\" message instead of 14\n * - Centralized error handling\n * - Consistent timeout behavior\n * - Easier to debug and maintain\n */\nexport async function unifiedDispatcher(input: HookInput): Promise<HookResult> {\n  const toolName = input.tool_name || '';\n\n  // Filter hooks that match this tool\n  const matchingHooks = HOOKS.filter(h => matchesTool(toolName, h.matcher));\n\n  if (matchingHooks.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  // Run all matching hooks in parallel\n  const results = await Promise.allSettled(\n    matchingHooks.map(async hook => {\n      try {\n        const result = hook.fn(input);\n        // Handle both sync and async hooks\n        if (result instanceof Promise) {\n          await result;\n        }\n        return { hook: hook.name, status: 'success' };\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        logHook('unified-dispatcher', `${hook.name} failed: ${message}`);\n        return { hook: hook.name, status: 'error', message };\n      }\n    })\n  );\n\n  // Count failures for logging (async hooks can't report to users)\n  const failures: string[] = [];\n\n  for (const result of results) {\n    if (result.status === 'rejected') {\n      failures.push('unknown');\n    } else if (result.value.status === 'error') {\n      failures.push(result.value.hook);\n    }\n  }\n\n  // Log failures (async hooks are fire-and-forget - can't surface to users)\n  if (failures.length > 0) {\n    logHook('posttool-dispatcher', `${failures.length}/${matchingHooks.length} hooks failed: ${failures.join(', ')}`);\n  }\n\n  // Async hooks always return silent success - CC ignores other fields\n  return outputSilentSuccess();\n}\n", "/**\n * Test Coverage Predictor - LLM-powered validation hook\n * Predicts if new code has adequate test coverage\n * CC 2.1.3 Feature: Post-write analysis\n */\n\nimport { existsSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir } from '../../lib/common.js';\n\n/**\n * Predict test coverage for written files\n */\nexport function coveragePredictor(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only run for Write tool\n  if (toolName !== 'Write') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') ||\n                   process.env.TOOL_OUTPUT_FILE_PATH || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Only analyze source code files (not tests themselves)\n  if (filePath.includes('test') || filePath.includes('spec') || filePath.includes('__tests__')) {\n    return outputSilentSuccess();\n  }\n\n  // Only analyze code files\n  if (!/\\.(py|ts|tsx|js|jsx)$/.test(filePath)) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n\n  // Determine corresponding test file location\n  let testPattern = '';\n  const basename = filePath.split('/').pop() || '';\n\n  if (filePath.endsWith('.py')) {\n    // Python: backend/app/services/foo.py -> backend/tests/unit/test_foo.py\n    const nameWithoutExt = basename.replace('.py', '');\n    testPattern = `test_${nameWithoutExt}.py`;\n  } else if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // TypeScript: src/components/Foo.tsx -> src/components/__tests__/Foo.test.tsx\n    const nameWithoutExt = basename.replace(/\\.[^.]+$/, '');\n    testPattern = `${nameWithoutExt}.test.*`;\n  } else {\n    return outputSilentSuccess();\n  }\n\n  // Check if test file exists\n  let testExists = '';\n  try {\n    const findResult = execSync(\n      `find \"${projectDir}\" -type f -name \"${testPattern}\" 2>/dev/null | head -1`,\n      { encoding: 'utf8', timeout: 5000 }\n    ).trim();\n    testExists = findResult;\n  } catch {\n    // find command failed, assume no test\n  }\n\n  // Log results\n  const logDir = `${projectDir}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n    const timestamp = new Date().toISOString();\n\n    if (testExists) {\n      appendFileSync(\n        `${logDir}/coverage-predictor.log`,\n        `[${timestamp}] COVERAGE_OK: ${filePath} has tests at ${testExists}\\n`\n      );\n    } else {\n      appendFileSync(\n        `${logDir}/coverage-predictor.log`,\n        `[${timestamp}] COVERAGE_WARN: ${filePath} may lack test coverage (expected: ${testPattern})\\n`\n      );\n\n      // Return subtle reminder (not blocking)\n      return {\n        continue: true,\n        systemMessage: `Consider adding tests for: ${filePath}`,\n      };\n    }\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * README Sync Hook for Claude Code\n * After significant code changes, suggests README updates\n * Tracks: new exports, API changes, config changes\n * Hook: PostToolUse (Write)\n * Issue: #140\n */\n\nimport { existsSync, statSync, appendFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface ChangeAnalysis {\n  changeType: string;\n  readmeSection: string;\n  suggestion: string;\n}\n\n/**\n * Analyze file for README-relevant changes\n */\nfunction analyzeFileChange(filePath: string, projectDir: string): ChangeAnalysis | null {\n  const filename = filePath.split('/').pop() || '';\n  const dirname = filePath.split('/').slice(0, -1).join('/');\n  const extLower = (filePath.split('.').pop() || '').toLowerCase();\n\n  // 1. Package configuration files\n  switch (filename) {\n    case 'package.json':\n      if (existsSync(`${projectDir}/${filePath}`)) {\n        try {\n          const pkg = require(`${projectDir}/${filePath}`);\n          const scriptCount = Object.keys(pkg.scripts || {}).length;\n          if (scriptCount > 5) {\n            return {\n              changeType: 'scripts',\n              readmeSection: 'Available Scripts',\n              suggestion: 'Update README with new npm scripts',\n            };\n          }\n        } catch {\n          // Ignore parse errors\n        }\n      }\n      break;\n\n    case 'pyproject.toml':\n    case 'setup.py':\n    case 'setup.cfg':\n      return {\n        changeType: 'python-config',\n        readmeSection: 'Installation',\n        suggestion: 'Verify README installation instructions match project config',\n      };\n\n    case 'Dockerfile':\n    case 'docker-compose.yml':\n    case 'docker-compose.yaml':\n      return {\n        changeType: 'docker',\n        readmeSection: 'Docker / Deployment',\n        suggestion: 'Update README Docker instructions',\n      };\n\n    case '.env.example':\n    case '.env.template':\n      return {\n        changeType: 'env',\n        readmeSection: 'Environment Variables',\n        suggestion: 'Update README environment variable documentation',\n      };\n  }\n\n  // 2. API routes and endpoints\n  if (filePath.includes('/api/') || filePath.includes('/routes/') || filePath.includes('/endpoints/')) {\n    return {\n      changeType: 'api',\n      readmeSection: 'API Endpoints',\n      suggestion: 'Update README API documentation or OpenAPI spec',\n    };\n  }\n\n  // 3. Configuration directories\n  if (dirname.includes('/config') || dirname.includes('/settings')) {\n    return {\n      changeType: 'config',\n      readmeSection: 'Configuration',\n      suggestion: 'Document new configuration options in README',\n    };\n  }\n\n  // 4. Main entry points / index files\n  if (['index.ts', 'index.js', 'main.py', 'app.py', '__init__.py'].includes(filename)) {\n    const depth = filePath.split('/').length;\n    if (depth <= 4) {\n      return {\n        changeType: 'entry-point',\n        readmeSection: 'Getting Started',\n        suggestion: 'Review README getting started section for accuracy',\n      };\n    }\n  }\n\n  // 5. CLI tools and bin scripts\n  if (filePath.includes('/bin/') || filePath.includes('/cli/') || filePath.includes('/scripts/')) {\n    if (['sh', 'py', 'ts'].includes(extLower)) {\n      return {\n        changeType: 'cli',\n        readmeSection: 'CLI / Commands',\n        suggestion: 'Update README CLI usage documentation',\n      };\n    }\n  }\n\n  // 6. Public exports (index files with exports)\n  if (filename === 'index.ts' || filename === 'index.js') {\n    const fullPath = `${projectDir}/${filePath}`;\n    if (existsSync(fullPath)) {\n      try {\n        const { readFileSync } = require('fs');\n        const content = readFileSync(fullPath, 'utf8');\n        const exportCount = (content.match(/^export/gm) || []).length;\n        if (exportCount > 5) {\n          return {\n            changeType: 'exports',\n            readmeSection: 'API Reference',\n            suggestion: 'Consider updating API reference with new exports',\n          };\n        }\n      } catch {\n        // Ignore read errors\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find README file in project\n */\nfunction findReadme(projectDir: string): string | null {\n  for (const name of ['README.md', 'Readme.md', 'readme.md', 'README.rst', 'README']) {\n    if (existsSync(`${projectDir}/${name}`)) {\n      return `${projectDir}/${name}`;\n    }\n  }\n  return null;\n}\n\n/**\n * Sync README suggestions\n */\nexport function readmeSync(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only run for Write tool\n  if (toolName !== 'Write') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Skip internal files\n  if (filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock') ||\n      filePath.endsWith('.log')) {\n    return outputSilentSuccess();\n  }\n\n  // Skip test files - they don't typically require README updates\n  if (filePath.includes('test') || filePath.includes('spec') || filePath.includes('__tests__')) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n\n  // Analyze file for README-relevant changes\n  const analysis = analyzeFileChange(filePath, projectDir);\n\n  if (!analysis) {\n    return outputSilentSuccess();\n  }\n\n  // Check if README exists\n  const readmePath = findReadme(projectDir);\n\n  let contextMsg: string;\n\n  if (readmePath) {\n    // Check when README was last modified\n    let daysOld = 0;\n    try {\n      const stats = statSync(readmePath);\n      const mtime = stats.mtime.getTime();\n      const now = Date.now();\n      daysOld = Math.floor((now - mtime) / (86400 * 1000));\n    } catch {\n      // Ignore stat errors\n    }\n\n    let suggestion = analysis.suggestion;\n    if (daysOld > 30) {\n      suggestion = `${suggestion} (README last updated ${daysOld}+ days ago)`;\n    }\n\n    contextMsg = `README sync: ${analysis.changeType} change in ${filePath.split('/').pop()}. Section: '${analysis.readmeSection}'. ${suggestion}`;\n  } else {\n    contextMsg = `README sync: ${analysis.changeType} change detected but no README.md found. Consider creating one.`;\n  }\n\n  // Truncate if too long\n  if (contextMsg.length > 200) {\n    contextMsg = `README sync: ${analysis.changeType} change detected. Consider updating '${analysis.readmeSection}' section.`;\n  }\n\n  // Log the suggestion\n  const logDir = `${projectDir}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n    const timestamp = new Date().toISOString();\n    appendFileSync(\n      `${logDir}/readme-sync.log`,\n      `[${timestamp}] README_SYNC: ${analysis.changeType} change in ${filePath} -> ${analysis.readmeSection}\\n`\n    );\n  } catch {\n    // Ignore log errors\n  }\n\n  logHook('readme-sync', `README_SYNC: ${analysis.changeType} change suggests README update`);\n\n  // Output using CC 2.1.9 additionalContext format\n  return {\n    continue: true,\n    hookSpecificOutput: {\n      additionalContext: contextMsg,\n    },\n  };\n}\n", "/**\n * Release Lock on Commit - PostToolUse Hook\n * Releases file locks after successful git commit\n *\n * Triggers on: Bash with git commit that succeeded\n * Action: Release locks on committed files\n * CC 2.1.7 Compliant: Proper JSON output\n *\n * Version: 1.0.1\n * Part of Multi-Worktree Coordination System\n */\n\nimport { existsSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../../lib/common.js';\n\n/**\n * Release file locks after Write operations\n * Note: This hook is for Write tool - locks are released on session end or explicit release\n */\nexport function releaseLockOnCommit(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const coordLib = `${projectDir}/.claude/coordination/lib/coordination.sh`;\n\n  // Check if coordination lib exists\n  if (!existsSync(coordLib)) {\n    return outputSilentSuccess();\n  }\n\n  // This hook runs after Write tool - we don't release locks here\n  // Locks are released on session end or explicit release\n  // The coordination system handles auto-expiration of stale locks\n\n  return outputSilentSuccess();\n}\n", "/**\n * File Lock Release - Release locks after successful Write/Edit\n * CC 2.1.7 Compliant: Self-contained hook with stdin reading and self-guard\n * Hook: PostToolUse (Write|Edit)\n *\n * FIX: Now releases from locks.json (matching multi-instance-lock.ts acquisition)\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\nimport { join } from 'node:path';\n\ninterface FileLock {\n  lock_id: string;\n  file_path: string;\n  lock_type: string;\n  instance_id: string;\n  acquired_at: string;\n  expires_at: string;\n  reason?: string;\n}\n\ninterface LockDatabase {\n  locks: FileLock[];\n}\n\n/**\n * Get locks file path\n */\nfunction getLocksFilePath(projectDir: string): string {\n  return join(projectDir, '.claude', 'coordination', 'locks.json');\n}\n\n/**\n * Check if coordination is enabled\n */\nfunction isCoordinationEnabled(projectDir: string): boolean {\n  return existsSync(join(projectDir, '.claude', 'coordination'));\n}\n\n/**\n * Get current instance ID\n * Priority: CLAUDE_SESSION_ID > .instance/id.json > fallback-{pid}\n * Using .instance/id.json ensures consistent ID across hook processes.\n */\nfunction getInstanceId(): string {\n  // 1. Try CLAUDE_SESSION_ID first\n  if (process.env.CLAUDE_SESSION_ID) {\n    return process.env.CLAUDE_SESSION_ID;\n  }\n\n  // 2. Try reading from .instance/id.json for consistent ID across processes\n  try {\n    const projectDir = getProjectDir();\n    const instanceIdPath = join(projectDir, '.instance', 'id.json');\n    if (existsSync(instanceIdPath)) {\n      const data = JSON.parse(readFileSync(instanceIdPath, 'utf8'));\n      if (data.instance_id) {\n        return data.instance_id;\n      }\n    }\n  } catch {\n    // Ignore read errors\n  }\n\n  // 3. Fallback to PID (may cause issues with lock release)\n  return `fallback-${process.pid}`;\n}\n\n/**\n * Load locks database\n */\nfunction loadLocks(locksPath: string): LockDatabase {\n  try {\n    if (existsSync(locksPath)) {\n      return JSON.parse(readFileSync(locksPath, 'utf8'));\n    }\n  } catch {\n    // Ignore parse errors\n  }\n  return { locks: [] };\n}\n\n/**\n * Save locks database\n */\nfunction saveLocks(locksPath: string, data: LockDatabase): void {\n  writeFileSync(locksPath, JSON.stringify(data, null, 2));\n}\n\n/**\n * Clean expired locks\n */\nfunction cleanExpiredLocks(locks: FileLock[]): FileLock[] {\n  const now = new Date().toISOString();\n  return locks.filter(l => l.expires_at > now);\n}\n\n/**\n * Release file lock from locks.json\n */\nfunction releaseFileLock(locksPath: string, filePath: string, instanceId: string): boolean {\n  try {\n    const data = loadLocks(locksPath);\n    const originalCount = data.locks.length;\n\n    // Clean expired locks AND remove matching lock\n    data.locks = cleanExpiredLocks(data.locks).filter(\n      l => !(l.file_path === filePath && l.instance_id === instanceId)\n    );\n\n    if (data.locks.length < originalCount) {\n      saveLocks(locksPath, data);\n      logHook('file-lock-release', `Released lock for ${filePath}`);\n      return true;\n    }\n\n    return false;\n  } catch (error) {\n    logHook('file-lock-release', `Failed to release lock for ${filePath}: ${error}`);\n    return false;\n  }\n}\n\n/**\n * Release file locks after Write/Edit operations\n */\nexport function fileLockRelease(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n\n  // Self-guard: Only run if coordination is enabled\n  if (!isCoordinationEnabled(projectDir)) {\n    return outputSilentSuccess();\n  }\n\n  // Get file path\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Skip coordination directory files\n  if (filePath.includes('/.claude/coordination/') || filePath.includes('.claude/coordination')) {\n    return outputSilentSuccess();\n  }\n\n  // Normalize path (match multi-instance-lock.ts behavior)\n  const normalizedPath = filePath.startsWith(projectDir)\n    ? filePath.slice(projectDir.length + 1)\n    : filePath;\n\n  // Release lock regardless of result (lock should be released even on error)\n  const locksPath = getLocksFilePath(projectDir);\n  const instanceId = getInstanceId();\n  releaseFileLock(locksPath, normalizedPath, instanceId);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Problem Tracker - Track open problems and pair them with solutions\n *\n * Part of Intelligent Decision Capture System\n *\n * Purpose:\n * - Track problems/issues mentioned by users\n * - Detect when tool outputs indicate solutions\n * - Pair problems with their solutions\n * - Store problem-solution pairs for learning\n *\n * CC 2.1.16 Compliant\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getProjectDir, logHook } from './common.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Tracked problem waiting for solution\n */\nexport interface Problem {\n  /** Unique problem ID */\n  id: string;\n  /** Problem description text */\n  text: string;\n  /** When problem was reported */\n  timestamp: string;\n  /** Session where problem was reported */\n  session_id: string;\n  /** Current status */\n  status: 'open' | 'solved' | 'abandoned';\n  /** Technologies/patterns involved */\n  entities: string[];\n  /** Project name */\n  project: string;\n  /** Paired solution if solved */\n  solution?: Solution;\n}\n\n/**\n * Solution that resolved a problem\n */\nexport interface Solution {\n  /** Solution description */\n  text: string;\n  /** Tool that provided the solution */\n  tool: string;\n  /** File modified if applicable */\n  file?: string;\n  /** When solution was detected */\n  timestamp: string;\n  /** Confidence this is the actual solution */\n  confidence: number;\n  /** Exit code if Bash tool */\n  exit_code?: number;\n}\n\n/**\n * Problem-solution pair for storage\n */\nexport interface ProblemSolutionPair {\n  /** Problem ID */\n  problem_id: string;\n  /** Problem description */\n  problem_text: string;\n  /** Solution description */\n  solution_text: string;\n  /** Tool used */\n  tool: string;\n  /** File if applicable */\n  file?: string;\n  /** Entities involved */\n  entities: string[];\n  /** Solution confidence */\n  confidence: number;\n  /** When paired */\n  paired_at: string;\n  /** Session ID */\n  session_id: string;\n  /** Project */\n  project: string;\n}\n\n// =============================================================================\n// SOLUTION DETECTION PATTERNS\n// =============================================================================\n\n/**\n * Patterns indicating successful solution\n */\nexport const SOLUTION_SUCCESS_PATTERNS: RegExp[] = [\n  // Test success\n  /\\b(all )?tests?\\s*(passed|passing|pass)\\b/i,\n  /\\b(test|tests)\\s*(suite)?\\s*(passed|successful|succeeded)\\b/i,\n  /\\b\\d+\\s*passed?,?\\s*0\\s*failed\\b/i,\n  /\\bOK\\s*\\(\\d+\\s*tests?\\)/i,\n\n  // Build success\n  /\\bbuild\\s*(succeeded|successful|complete(d)?)\\b/i,\n  /\\bcompiled?\\s*successfully\\b/i,\n  /\\bbundle\\s*(created|generated)\\b/i,\n\n  // Fix/resolution indicators\n  /\\bfixed\\b/i,\n  /\\bresolved\\b/i,\n  /\\bsolved\\b/i,\n  /\\bnow works\\b/i,\n  /\\bworking\\s*(now|correctly|properly)\\b/i,\n  /\\bno\\s*(more\\s*)?(errors?|issues?|problems?)\\b/i,\n\n  // Status improvements\n  /\\bsuccess(ful(ly)?)?\\b/i,\n  /\\bready\\s*(for|to)\\b/i,\n  /\\bcomplete(d)?\\b/i,\n];\n\n/**\n * Patterns indicating failed attempt (not a solution)\n */\nexport const SOLUTION_FAILURE_PATTERNS: RegExp[] = [\n  /\\b(tests?\\s*)?(failed|failing|failure)\\b/i,\n  /\\berror(s)?\\b/i,\n  /\\bexception\\b/i,\n  /\\bcrash(ed|ing)?\\b/i,\n  /\\btimeout\\b/i,\n  /\\bnot\\s*(found|working|defined)\\b/i,\n  /\\bundefined\\b/i,\n  /\\bsyntax\\s*error\\b/i,\n  /\\btype\\s*error\\b/i,\n  /\\bcannot\\s*(find|read|import)\\b/i,\n];\n\n// =============================================================================\n// FILE OPERATIONS\n// =============================================================================\n\n/**\n * Get path to open problems file\n */\nfunction getOpenProblemsPath(): string {\n  return join(getProjectDir(), '.claude', 'memory', 'open-problems.jsonl');\n}\n\n/**\n * Get path to problem-solutions file\n */\nfunction getProblemSolutionsPath(): string {\n  return join(getProjectDir(), '.claude', 'memory', 'problem-solutions.jsonl');\n}\n\n/**\n * Load open problems from JSONL file\n */\nexport function loadOpenProblems(sessionId?: string): Problem[] {\n  const filePath = getOpenProblemsPath();\n\n  if (!existsSync(filePath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const problems: Problem[] = [];\n\n    for (const line of lines) {\n      try {\n        const problem = JSON.parse(line) as Problem;\n        // Only return open problems, optionally filter by session\n        if (problem.status === 'open') {\n          if (!sessionId || problem.session_id === sessionId) {\n            problems.push(problem);\n          }\n        }\n      } catch {\n        // Skip malformed lines\n      }\n    }\n\n    // Return most recent first, limited to avoid memory issues\n    return problems.slice(-50).reverse();\n  } catch (err) {\n    logHook('problem-tracker', `Failed to load open problems: ${err}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Update problem status in file (mark as solved/abandoned)\n */\nexport function updateProblemStatus(\n  problemId: string,\n  status: 'solved' | 'abandoned',\n  solution?: Solution\n): boolean {\n  const filePath = getOpenProblemsPath();\n\n  if (!existsSync(filePath)) {\n    return false;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    let updated = false;\n\n    const newLines = lines.map(line => {\n      try {\n        const problem = JSON.parse(line) as Problem;\n        if (problem.id === problemId) {\n          problem.status = status;\n          if (solution) {\n            problem.solution = solution;\n          }\n          updated = true;\n          return JSON.stringify(problem);\n        }\n        return line;\n      } catch {\n        return line;\n      }\n    });\n\n    if (updated) {\n      writeFileSync(filePath, newLines.join('\\n') + '\\n');\n    }\n\n    return updated;\n  } catch (err) {\n    logHook('problem-tracker', `Failed to update problem ${problemId}: ${err}`, 'warn');\n    return false;\n  }\n}\n\n/**\n * Store problem-solution pair\n */\nexport function storeProblemSolutionPair(pair: ProblemSolutionPair): boolean {\n  const filePath = getProblemSolutionsPath();\n\n  try {\n    const dir = dirname(filePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    const line = JSON.stringify(pair) + '\\n';\n    writeFileSync(filePath, line, { flag: 'a' });\n\n    logHook(\n      'problem-tracker',\n      `Stored problem-solution pair: ${pair.problem_id} \u2192 ${pair.tool}`,\n      'info'\n    );\n\n    return true;\n  } catch (err) {\n    logHook('problem-tracker', `Failed to store pair: ${err}`, 'warn');\n    return false;\n  }\n}\n\n// =============================================================================\n// SOLUTION DETECTION\n// =============================================================================\n\n/**\n * Check if output contains solution indicators\n */\nexport function hasSolutionIndicators(output: string): boolean {\n  return SOLUTION_SUCCESS_PATTERNS.some(pattern => pattern.test(output));\n}\n\n/**\n * Check if output contains failure indicators\n */\nexport function hasFailureIndicators(output: string): boolean {\n  return SOLUTION_FAILURE_PATTERNS.some(pattern => pattern.test(output));\n}\n\n/**\n * Calculate confidence that output represents a solution to a problem\n */\nexport function calculateSolutionConfidence(\n  problem: Problem,\n  output: string,\n  tool: string,\n  exitCode?: number\n): number {\n  let confidence = 0.3; // Base confidence\n\n  // Exit code is strong signal\n  if (exitCode === 0) {\n    confidence += 0.2;\n  } else if (exitCode !== undefined && exitCode !== 0) {\n    confidence -= 0.3;\n  }\n\n  // Success patterns boost confidence\n  const successCount = SOLUTION_SUCCESS_PATTERNS.filter(p => p.test(output)).length;\n  confidence += Math.min(0.3, successCount * 0.1);\n\n  // Failure patterns reduce confidence\n  const failureCount = SOLUTION_FAILURE_PATTERNS.filter(p => p.test(output)).length;\n  confidence -= Math.min(0.4, failureCount * 0.15);\n\n  // Entity overlap boosts confidence\n  const outputLower = output.toLowerCase();\n  const matchingEntities = problem.entities.filter(e => outputLower.includes(e.toLowerCase()));\n  confidence += Math.min(0.15, matchingEntities.length * 0.05);\n\n  // Certain tools are more likely to provide solutions\n  if (tool === 'Bash') {\n    // Bash with tests is strong signal\n    if (/test|pytest|jest|vitest/i.test(output)) {\n      confidence += 0.1;\n    }\n  } else if (tool === 'Write' || tool === 'Edit') {\n    // Code changes could be fixes\n    confidence += 0.05;\n  }\n\n  // Clamp to valid range\n  return Math.max(0, Math.min(1, confidence));\n}\n\n/**\n * Summarize a solution from tool output\n */\nexport function summarizeSolution(output: string, tool: string, file?: string): string {\n  // Try to extract a meaningful summary\n  const lines = output.split('\\n').filter(l => l.trim());\n\n  // Look for success messages\n  for (const pattern of SOLUTION_SUCCESS_PATTERNS) {\n    const match = output.match(pattern);\n    if (match) {\n      const context = extractContext(output, match.index || 0);\n      if (context) {\n        return context.slice(0, 200);\n      }\n    }\n  }\n\n  // Fall back to first meaningful line\n  for (const line of lines.slice(0, 5)) {\n    const trimmed = line.trim();\n    if (trimmed.length > 10 && trimmed.length < 200) {\n      return trimmed;\n    }\n  }\n\n  // Generic summary based on tool\n  if (file) {\n    return `${tool} operation on ${file.split('/').pop()} completed`;\n  }\n\n  return `${tool} completed successfully`;\n}\n\n/**\n * Extract context around a match position\n */\nfunction extractContext(text: string, position: number, windowSize: number = 100): string {\n  const start = Math.max(0, position - 20);\n  const end = Math.min(text.length, position + windowSize);\n  let context = text.slice(start, end).trim();\n\n  // Clean up\n  context = context.replace(/\\s+/g, ' ');\n\n  // Find sentence boundaries\n  const sentenceEnd = context.search(/[.!?]\\s/);\n  if (sentenceEnd > 20) {\n    context = context.slice(0, sentenceEnd + 1);\n  }\n\n  return context;\n}\n\n/**\n * Pair a solution with matching problems\n *\n * Returns the number of problems paired\n */\nexport function pairSolutionWithProblems(\n  output: string,\n  tool: string,\n  file: string | undefined,\n  exitCode: number | undefined,\n  sessionId: string\n): number {\n  // Skip if output looks like a failure\n  if (hasFailureIndicators(output) && !hasSolutionIndicators(output)) {\n    return 0;\n  }\n\n  // Load open problems\n  const openProblems = loadOpenProblems(sessionId);\n  if (openProblems.length === 0) {\n    return 0;\n  }\n\n  const project = getProjectDir().split('/').pop() || 'unknown';\n  const timestamp = new Date().toISOString();\n  let paired = 0;\n\n  for (const problem of openProblems) {\n    const confidence = calculateSolutionConfidence(problem, output, tool, exitCode);\n\n    // Only pair if reasonably confident\n    if (confidence >= 0.6) {\n      const solution: Solution = {\n        text: summarizeSolution(output, tool, file),\n        tool,\n        file,\n        timestamp,\n        confidence,\n        exit_code: exitCode,\n      };\n\n      // Update problem status\n      const updated = updateProblemStatus(problem.id, 'solved', solution);\n\n      if (updated) {\n        // Store the pair\n        const pair: ProblemSolutionPair = {\n          problem_id: problem.id,\n          problem_text: problem.text,\n          solution_text: solution.text,\n          tool,\n          file,\n          entities: problem.entities,\n          confidence,\n          paired_at: timestamp,\n          session_id: sessionId,\n          project,\n        };\n\n        if (storeProblemSolutionPair(pair)) {\n          paired++;\n        }\n      }\n    }\n  }\n\n  return paired;\n}\n\n/**\n * Abandon stale problems (older than threshold)\n */\nexport function abandonStaleProblems(maxAgeMs: number = 24 * 60 * 60 * 1000): number {\n  const openProblems = loadOpenProblems();\n  const cutoff = Date.now() - maxAgeMs;\n  let abandoned = 0;\n\n  for (const problem of openProblems) {\n    const problemTime = new Date(problem.timestamp).getTime();\n    if (problemTime < cutoff) {\n      if (updateProblemStatus(problem.id, 'abandoned')) {\n        abandoned++;\n      }\n    }\n  }\n\n  if (abandoned > 0) {\n    logHook('problem-tracker', `Abandoned ${abandoned} stale problems`, 'info');\n  }\n\n  return abandoned;\n}\n", "/**\n * Solution Detector Hook - Detect when tool outputs resolve open problems\n *\n * Part of Intelligent Decision Capture System\n * Hook: PostToolUse\n *\n * Purpose:\n * - Monitor tool outputs for solution indicators\n * - Pair successful outputs with open problems\n * - Store problem-solution pairs for learning\n *\n * Triggers:\n * - Test passes after test failures\n * - Build succeeds after build errors\n * - \"fixed\", \"resolved\", \"now works\" in output\n *\n * CC 2.1.16 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  getField,\n  getSessionId,\n  logHook,\n} from '../lib/common.js';\nimport {\n  pairSolutionWithProblems,\n  hasSolutionIndicators,\n} from '../lib/problem-tracker.js';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst HOOK_NAME = 'solution-detector';\nconst MIN_OUTPUT_LENGTH = 20; // Skip very short outputs\n\n// Tools that commonly indicate solutions\nconst SOLUTION_TOOLS = ['Bash', 'Write', 'Edit', 'Task'];\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Detect solutions in tool outputs and pair with open problems\n *\n * This hook runs on PostToolUse and checks if the output indicates\n * that a previously stated problem has been resolved.\n */\nexport function solutionDetector(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process relevant tools\n  if (!SOLUTION_TOOLS.includes(toolName)) {\n    return outputSilentSuccess();\n  }\n\n  // Get tool output\n  const toolOutput = extractToolOutput(input);\n  if (!toolOutput || toolOutput.length < MIN_OUTPUT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Quick check for solution indicators before doing heavier work\n  if (!hasSolutionIndicators(toolOutput)) {\n    return outputSilentSuccess();\n  }\n\n  // Get context\n  const sessionId = input.session_id || getSessionId();\n  const exitCode = input.exit_code;\n  const file = getField<string>(input, 'tool_input.file_path');\n\n  // Try to pair with open problems\n  try {\n    const paired = pairSolutionWithProblems(\n      toolOutput,\n      toolName,\n      file,\n      exitCode,\n      sessionId\n    );\n\n    if (paired > 0) {\n      logHook(HOOK_NAME, `Paired ${paired} problem(s) with solution from ${toolName}`, 'info');\n    }\n  } catch (err) {\n    logHook(HOOK_NAME, `Error pairing solutions: ${err}`, 'warn');\n  }\n\n  // Always silent success - this is a background capture hook\n  return outputSilentSuccess();\n}\n\n/**\n * Extract tool output from various input formats\n */\nfunction extractToolOutput(input: HookInput): string {\n  // Try different field names used by CC\n  const toolResult = input.tool_result;\n  if (typeof toolResult === 'string') {\n    return toolResult;\n  }\n  if (toolResult && typeof toolResult === 'object') {\n    const content = (toolResult as { content?: string }).content;\n    if (typeof content === 'string') {\n      return content;\n    }\n  }\n\n  // Try tool_output field\n  const toolOutput = input.tool_output;\n  if (typeof toolOutput === 'string') {\n    return toolOutput;\n  }\n  if (toolOutput && typeof toolOutput === 'object') {\n    const content = (toolOutput as { content?: string }).content;\n    if (typeof content === 'string') {\n      return content;\n    }\n  }\n\n  // Try output field (SubagentStop)\n  const output = input.output;\n  if (typeof output === 'string') {\n    return output;\n  }\n\n  return '';\n}\n", "/**\n * Tool Preference Learner Hook - Learn user's tool usage patterns\n *\n * Part of Intelligent Decision Capture System\n * Hook: PostToolUse\n *\n * Purpose:\n * - Track which tools are used for different tasks\n * - Learn preferences like \"prefers Grep over Bash find\"\n * - Identify tool usage patterns per category\n * - Store preferences for future suggestions\n *\n * Categories:\n * - file_search: Glob, Grep, Bash find\n * - code_reading: Read, Bash cat/head\n * - testing: Bash npm test, pytest, jest\n * - git: Bash git, Skill commit\n *\n * CC 2.1.16 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  getField,\n  getProjectDir,\n  logHook,\n} from '../lib/common.js';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst HOOK_NAME = 'tool-preference-learner';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Tool category for grouping similar operations\n */\nexport type ToolCategory =\n  | 'file_search'\n  | 'content_search'\n  | 'code_reading'\n  | 'code_writing'\n  | 'testing'\n  | 'building'\n  | 'git_operations'\n  | 'agent_spawn'\n  | 'other';\n\n/**\n * Learned tool preference\n */\nexport interface ToolPreference {\n  /** Category of operation */\n  category: ToolCategory;\n  /** Preferred tool for this category */\n  preferred_tool: string;\n  /** Confidence in this preference */\n  confidence: number;\n  /** Number of times this tool was used */\n  sample_count: number;\n  /** Last updated timestamp */\n  updated_at: string;\n}\n\n/**\n * Usage counts for tools in a category\n */\ninterface CategoryUsage {\n  [tool: string]: number;\n}\n\n/**\n * All preferences data\n */\ninterface PreferencesData {\n  /** Usage counts per category */\n  usage: Record<ToolCategory, CategoryUsage>;\n  /** Derived preferences */\n  preferences: Record<ToolCategory, ToolPreference | null>;\n  /** Last update timestamp */\n  updated_at: string;\n}\n\n// =============================================================================\n// TOOL CATEGORIZATION\n// =============================================================================\n\n/**\n * Tool category mappings\n */\nconst TOOL_CATEGORIES: Record<string, ToolCategory[]> = {\n  // File search tools\n  'Glob': ['file_search'],\n  'Bash:find': ['file_search'],\n  'Bash:ls': ['file_search'],\n\n  // Content search tools\n  'Grep': ['content_search'],\n  'Bash:grep': ['content_search'],\n  'Bash:rg': ['content_search'],\n  'Bash:ag': ['content_search'],\n\n  // Code reading tools\n  'Read': ['code_reading'],\n  'Bash:cat': ['code_reading'],\n  'Bash:head': ['code_reading'],\n  'Bash:tail': ['code_reading'],\n\n  // Code writing tools\n  'Write': ['code_writing'],\n  'Edit': ['code_writing'],\n  'MultiEdit': ['code_writing'],\n  'NotebookEdit': ['code_writing'],\n\n  // Testing tools\n  'Bash:test': ['testing'],\n  'Bash:pytest': ['testing'],\n  'Bash:jest': ['testing'],\n  'Bash:vitest': ['testing'],\n  'Bash:npm_test': ['testing'],\n\n  // Building tools\n  'Bash:build': ['building'],\n  'Bash:npm_run_build': ['building'],\n  'Bash:make': ['building'],\n  'Bash:cargo_build': ['building'],\n  'Bash:tsc': ['building'],\n\n  // Git operations\n  'Bash:git': ['git_operations'],\n  'Bash:gh': ['git_operations'],\n  'Skill:commit': ['git_operations'],\n  'Skill:create-pr': ['git_operations'],\n\n  // Agent operations\n  'Task': ['agent_spawn'],\n};\n\n/**\n * Patterns to identify Bash sub-tools\n */\nconst BASH_PATTERNS: [RegExp, string][] = [\n  [/\\bfind\\s+/, 'Bash:find'],\n  [/\\bls\\s+/, 'Bash:ls'],\n  [/\\bgrep\\s+/, 'Bash:grep'],\n  [/\\brg\\s+/, 'Bash:rg'],\n  [/\\bag\\s+/, 'Bash:ag'],\n  [/\\bcat\\s+/, 'Bash:cat'],\n  [/\\bhead\\s+/, 'Bash:head'],\n  [/\\btail\\s+/, 'Bash:tail'],\n  [/\\bpytest\\b/, 'Bash:pytest'],\n  [/\\bjest\\b/, 'Bash:jest'],\n  [/\\bvitest\\b/, 'Bash:vitest'],\n  [/\\bnpm\\s+test\\b/, 'Bash:npm_test'],\n  [/\\bnpm\\s+run\\s+build\\b/, 'Bash:npm_run_build'],\n  [/\\bmake\\b/, 'Bash:make'],\n  [/\\bcargo\\s+build\\b/, 'Bash:cargo_build'],\n  [/\\btsc\\b/, 'Bash:tsc'],\n  [/\\bgit\\s+/, 'Bash:git'],\n  [/\\bgh\\s+/, 'Bash:gh'],\n];\n\n/**\n * Get specific tool identifier for a Bash command\n */\nfunction identifyBashTool(command: string): string {\n  for (const [pattern, toolId] of BASH_PATTERNS) {\n    if (pattern.test(command)) {\n      return toolId;\n    }\n  }\n  return 'Bash:other';\n}\n\n/**\n * Get tool identifier for categorization\n */\nfunction getToolIdentifier(tool: string, command?: string, skill?: string): string {\n  if (tool === 'Bash' && command) {\n    return identifyBashTool(command);\n  }\n\n  if (tool === 'Skill' && skill) {\n    return `Skill:${skill}`;\n  }\n\n  return tool;\n}\n\n/**\n * Get categories for a tool\n */\nfunction getToolCategories(toolId: string): ToolCategory[] {\n  return TOOL_CATEGORIES[toolId] || ['other'];\n}\n\n// =============================================================================\n// FILE OPERATIONS\n// =============================================================================\n\n/**\n * Get path to preferences file\n */\nfunction getPreferencesPath(): string {\n  return join(getProjectDir(), '.claude', 'memory', 'tool-preferences.json');\n}\n\n/**\n * Load preferences data\n */\nfunction loadPreferences(): PreferencesData {\n  const filePath = getPreferencesPath();\n\n  if (!existsSync(filePath)) {\n    return createEmptyPreferences();\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as PreferencesData;\n  } catch {\n    return createEmptyPreferences();\n  }\n}\n\n/**\n * Save preferences data\n */\nfunction savePreferences(data: PreferencesData): boolean {\n  const filePath = getPreferencesPath();\n\n  try {\n    const dir = dirname(filePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    writeFileSync(filePath, JSON.stringify(data, null, 2));\n    return true;\n  } catch (err) {\n    logHook(HOOK_NAME, `Failed to save preferences: ${err}`, 'warn');\n    return false;\n  }\n}\n\n/**\n * Create empty preferences structure\n */\nfunction createEmptyPreferences(): PreferencesData {\n  const categories: ToolCategory[] = [\n    'file_search', 'content_search', 'code_reading', 'code_writing',\n    'testing', 'building', 'git_operations', 'agent_spawn', 'other',\n  ];\n\n  const usage: Record<ToolCategory, CategoryUsage> = {} as Record<ToolCategory, CategoryUsage>;\n  const preferences: Record<ToolCategory, ToolPreference | null> = {} as Record<ToolCategory, ToolPreference | null>;\n\n  for (const cat of categories) {\n    usage[cat] = {};\n    preferences[cat] = null;\n  }\n\n  return {\n    usage,\n    preferences,\n    updated_at: new Date().toISOString(),\n  };\n}\n\n// =============================================================================\n// PREFERENCE CALCULATION\n// =============================================================================\n\n/**\n * Calculate preference from usage counts\n */\nfunction calculatePreference(\n  category: ToolCategory,\n  usage: CategoryUsage\n): ToolPreference | null {\n  const tools = Object.entries(usage);\n\n  if (tools.length === 0) {\n    return null;\n  }\n\n  // Sort by count descending\n  tools.sort((a, b) => b[1] - a[1]);\n\n  const [preferredTool, count] = tools[0];\n  const totalCount = tools.reduce((sum, [, c]) => sum + c, 0);\n\n  // Calculate confidence based on:\n  // 1. Sample size (more samples = higher confidence)\n  // 2. Dominance (how much more preferred tool is used vs others)\n  const sampleConfidence = Math.min(1, count / 10); // Max at 10 samples\n  const dominance = count / totalCount;\n  const confidence = (sampleConfidence * 0.4 + dominance * 0.6);\n\n  // Only return preference if confidence is reasonable\n  if (confidence < 0.3 || count < 2) {\n    return null;\n  }\n\n  return {\n    category,\n    preferred_tool: preferredTool,\n    confidence,\n    sample_count: count,\n    updated_at: new Date().toISOString(),\n  };\n}\n\n/**\n * Update all preferences from usage data\n */\nfunction updateAllPreferences(data: PreferencesData): void {\n  const categories = Object.keys(data.usage) as ToolCategory[];\n\n  for (const category of categories) {\n    data.preferences[category] = calculatePreference(category, data.usage[category]);\n  }\n\n  data.updated_at = new Date().toISOString();\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Track tool usage for preference learning\n */\nexport function toolPreferenceLearner(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Skip if no tool name\n  if (!toolName) {\n    return outputSilentSuccess();\n  }\n\n  // Get command for Bash tool\n  const command = getField<string>(input, 'tool_input.command');\n  const skill = getField<string>(input, 'tool_input.skill');\n\n  // Get tool identifier and categories\n  const toolId = getToolIdentifier(toolName, command, skill);\n  const categories = getToolCategories(toolId);\n\n  // Skip 'other' category to avoid noise\n  const relevantCategories = categories.filter(c => c !== 'other');\n  if (relevantCategories.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  // Load and update preferences\n  const data = loadPreferences();\n\n  for (const category of relevantCategories) {\n    if (!data.usage[category]) {\n      data.usage[category] = {};\n    }\n    data.usage[category][toolId] = (data.usage[category][toolId] || 0) + 1;\n  }\n\n  // Recalculate preferences\n  updateAllPreferences(data);\n\n  // Save\n  savePreferences(data);\n\n  // Log significant preference changes\n  for (const category of relevantCategories) {\n    const pref = data.preferences[category];\n    if (pref && pref.confidence > 0.7 && pref.sample_count === 10) {\n      logHook(\n        HOOK_NAME,\n        `Strong preference detected: ${category} \u2192 ${pref.preferred_tool} (${(pref.confidence * 100).toFixed(0)}%)`,\n        'info'\n      );\n    }\n  }\n\n  return outputSilentSuccess();\n}\n\n// =============================================================================\n// EXPORTS FOR OTHER HOOKS\n// =============================================================================\n\n/**\n * Get preferred tool for a category\n */\nexport function getPreferredTool(category: ToolCategory): ToolPreference | null {\n  const data = loadPreferences();\n  return data.preferences[category] || null;\n}\n\n/**\n * Get all preferences\n */\nexport function getAllPreferences(): Record<ToolCategory, ToolPreference | null> {\n  const data = loadPreferences();\n  return data.preferences;\n}\n", "/**\n * PostTool Hooks Entry Point\n *\n * Hooks that run after tool execution (PostToolUse)\n * Bundle: posttool.mjs (~45 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\nexport * from '../lib/git.js';\n\n// PostTool hooks - Root (13)\nimport { auditLogger } from '../posttool/audit-logger.js';\nimport { unifiedErrorHandler } from '../posttool/unified-error-handler.js';\nimport { autoLint } from '../posttool/auto-lint.js';\nimport { contextBudgetMonitor } from '../posttool/context-budget-monitor.js';\nimport { coordinationHeartbeat } from '../posttool/coordination-heartbeat.js';\nimport { mem0WebhookHandler } from '../posttool/mem0-webhook-handler.js';\nimport { memoryBridge } from '../posttool/memory-bridge.js';\nimport { realtimeSync } from '../posttool/realtime-sync.js';\nimport { userTracking } from '../posttool/user-tracking.js';\nimport { sessionMetrics } from '../posttool/session-metrics.js';\nimport { skillEditTracker } from '../posttool/skill-edit-tracker.js';\nimport { calibrationTracker } from '../posttool/calibration-tracker.js';\nimport { unifiedDispatcher } from '../posttool/unified-dispatcher.js';\n\n// PostTool/Write hooks (5)\nimport { codeStyleLearner } from '../posttool/write/code-style-learner.js';\nimport { coveragePredictor } from '../posttool/write/coverage-predictor.js';\nimport { namingConventionLearner } from '../posttool/write/naming-convention-learner.js';\nimport { readmeSync } from '../posttool/write/readme-sync.js';\nimport { releaseLockOnCommit } from '../posttool/write/release-lock-on-commit.js';\n\n// PostTool/Bash hooks (3)\nimport { issueProgressCommenter } from '../posttool/bash/issue-progress-commenter.js';\nimport { issueSubtaskUpdater } from '../posttool/bash/issue-subtask-updater.js';\nimport { patternExtractor } from '../posttool/bash/pattern-extractor.js';\n\n// PostTool/Skill hooks (1)\nimport { skillUsageOptimizer } from '../posttool/skill/skill-usage-optimizer.js';\n\n// PostTool/Write-Edit hooks (1)\nimport { fileLockRelease } from '../posttool/write-edit/file-lock-release.js';\n\n// Intelligent Decision Capture System\nimport { solutionDetector } from '../posttool/solution-detector.js';\nimport { toolPreferenceLearner } from '../posttool/tool-preference-learner.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * PostTool hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  // PostTool hooks - Root (13)\n  'posttool/audit-logger': auditLogger,\n  'posttool/unified-error-handler': unifiedErrorHandler,\n  'posttool/auto-lint': autoLint,\n  'posttool/context-budget-monitor': contextBudgetMonitor,\n  'posttool/coordination-heartbeat': coordinationHeartbeat,\n  'posttool/mem0-webhook-handler': mem0WebhookHandler,\n  'posttool/memory-bridge': memoryBridge,\n  'posttool/realtime-sync': realtimeSync,\n  'posttool/user-tracking': userTracking,\n  'posttool/session-metrics': sessionMetrics,\n  'posttool/skill-edit-tracker': skillEditTracker,\n  'posttool/calibration-tracker': calibrationTracker,\n  'posttool/unified-dispatcher': unifiedDispatcher,\n\n  // PostTool/Write hooks (5)\n  'posttool/write/code-style-learner': codeStyleLearner,\n  'posttool/write/coverage-predictor': coveragePredictor,\n  'posttool/write/naming-convention-learner': namingConventionLearner,\n  'posttool/write/readme-sync': readmeSync,\n  'posttool/write/release-lock-on-commit': releaseLockOnCommit,\n\n  // PostTool/Bash hooks (3)\n  'posttool/bash/issue-progress-commenter': issueProgressCommenter,\n  'posttool/bash/issue-subtask-updater': issueSubtaskUpdater,\n  'posttool/bash/pattern-extractor': patternExtractor,\n\n  // PostTool/Skill hooks (1)\n  'posttool/skill/skill-usage-optimizer': skillUsageOptimizer,\n\n  // PostTool/Write-Edit hooks (1)\n  'posttool/write-edit/file-lock-release': fileLockRelease,\n\n  // Intelligent Decision Capture System\n  'posttool/solution-detector': solutionDetector,\n  'posttool/tool-preference-learner': toolPreferenceLearner,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "execSync", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "getCachedBranch", "projectDir", "branch", "getLogLevel", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "estimateTokenCount", "content", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "readHookInput", "chunks", "buf", "bytesRead", "fd", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "execSync", "getCurrentBranch", "projectDir", "dir", "getProjectDir", "execSync", "isProtectedBranch", "branch", "currentBranch", "getRepoRoot", "isGitRepo", "getGitStatus", "hasUncommittedChanges", "getDefaultBranch", "extractIssueNumber", "patterns", "pattern", "match", "validateBranchName", "validPrefixes", "prefix", "appendFileSync", "existsSync", "mkdirSync", "statSync", "renameSync", "readCountFile", "auditLogger", "input", "toolName", "readFileSync", "writeFileSync", "readCount", "outputSilentSuccess", "projectDir", "auditLog", "logDir", "existsSync", "mkdirSync", "rotateLogFile", "timestamp", "details", "getField", "logEntry", "appendFileSync", "logFile", "maxBytes", "statSync", "rotated", "renameSync", "existsSync", "appendFileSync", "readFileSync", "writeFileSync", "mkdirSync", "statSync", "renameSync", "createHash", "ERROR_PATTERN", "TRIVIAL_COMMANDS", "MAX_CONTEXT_CHARS", "DEDUP_PROMPT_THRESHOLD", "MAX_SKILLS", "MAX_LOG_BYTES", "detectError", "input", "toolOutput", "getField", "toolError", "exitCode", "isError", "errorType", "errorMessage", "errorLines", "line", "rotateLogFile", "logFile", "existsSync", "statSync", "renameSync", "logError", "errorInfo", "projectDir", "getProjectDir", "errorLog", "metricsFile", "mkdirSync", "inputHash", "createHash", "errorRecord", "getSessionId", "appendFileSync", "metrics", "readFileSync", "writeFileSync", "logHook", "matchErrorPattern", "errorText", "solutionsFile", "content", "errorLower", "pattern", "shouldSuggest", "patternId", "errorContext", "dedupFile", "dedup", "suggestionHash", "currentCount", "lastSuggestedAt", "getSkillDescription", "skillName", "skillsDir", "skillFile", "frontmatterMatch", "descMatch", "buildSuggestionMessage", "brief", "steps", "msg", "step", "i", "patternSkills", "categorySkills", "allSkills", "skill", "desc", "unifiedErrorHandler", "toolName", "command", "outputSilentSuccess", "pluginRoot", "getPluginRoot", "matchedPattern", "suggestionMessage", "existsSync", "execSync", "getLanguage", "filePath", "commandExists", "cmd", "execSync", "autoLint", "input", "toolName", "outputSilentSuccess", "getField", "projectDir", "fullPath", "existsSync", "language", "lintIssues", "fixesApplied", "ruffCheck", "biomeOut", "error", "logHook", "basename", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "BUDGET_TOTAL", "COMPRESS_TRIGGER", "COMPRESS_TARGET", "MCP_DEFER_TRIGGER", "estimateTokens", "filePath", "existsSync", "content", "readFileSync", "estimateTokenCount", "calculateUsage", "contextDir", "getProjectDir", "alwaysLoadedFiles", "total", "file", "getEffectiveContextWindow", "baseWindow", "shouldDeferMcp", "currentTokens", "effectiveWindow", "updateMcpDeferState", "shouldDefer", "stateFile", "getSessionId", "state", "writeFileSync", "logHook", "compressSession", "sessionFile", "compressed", "archiveOldDecisions", "projectDir", "decisionsFile", "decisions", "archiveDir", "mkdirSync", "date", "archiveFile", "contextBudgetMonitor", "_input", "usageRatio", "usagePercent", "deferMcp", "newTokens", "newRatio", "newPercent", "error", "outputSilentSuccess", "existsSync", "readFileSync", "execSync", "coordinationHeartbeat", "_input", "projectDir", "getProjectDir", "coordLib", "existsSync", "outputSilentSuccess", "instanceEnv", "instanceId", "match", "readFileSync", "execSync", "error", "logHook", "mem0WebhookHandler", "input", "logHook", "toolName", "command", "getField", "outputSilentSuccess", "eventDataStr", "eventData", "eventType", "memoryId", "error", "existsSync", "ENTITY_PATTERNS", "extractEntitiesFromText", "text", "textLower", "entities", "entityType", "pattern", "matches", "match", "entityName", "word", "observation", "extractRelationsFromText", "relations", "entityNames", "e", "entity1", "entity1Lower", "entity2", "entity2Lower", "memoryBridge", "input", "logHook", "memoryText", "getField", "outputSilentSuccess", "memoryAgent", "getPluginRoot", "existsSync", "entityCount", "relationCount", "entityList", "msg", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "IMMEDIATE_KEYWORDS", "BATCHED_KEYWORDS", "MIN_CONTENT_LENGTH", "CONTEXT_EMERGENCY_THRESHOLD", "CONTEXT_CRITICAL_THRESHOLD", "getContextPressure", "pressure", "tokensUsed", "maxTokens", "classifyPriority", "content", "extractDecision", "patterns", "pattern", "match", "sentences", "detectCategory", "contentLower", "initPendingQueue", "pendingFile", "existsSync", "mkdirSync", "writeFileSync", "addToPendingQueue", "category", "data", "readFileSync", "logHook", "getPendingCount", "realtimeSync", "input", "toolName", "outputSilentSuccess", "toolOutput", "getField", "command", "filePath", "priority", "contextPressure", "projectDir", "getProjectDir", "sessionId", "getSessionId", "pendingCount", "decision", "existsSync", "appendFileSync", "mkdirSync", "readFileSync", "readdirSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "createHash", "os", "IDENTITY_CONFIG_FILE", "SALT", "cachedIdentity", "generateAnonymousId", "input", "createHash", "SALT", "getMachineId", "readUserConfig", "projectDir", "configPath", "IDENTITY_CONFIG_FILE", "existsSync", "content", "readFileSync", "error", "logHook", "getGitIdentity", "result", "execSync", "getEnvIdentity", "resolveUserIdentity", "cachedIdentity", "dir", "getProjectDir", "machineId", "config", "git", "env", "userId", "anonId", "getIdentityContext", "identity", "resolveUserIdentity", "getSessionId", "SESSION_ID_PATTERN", "isValidSessionId", "sessionId", "getSessionDir", "sid", "getSessionId", "getProjectDir", "getEventsPath", "ensureSessionDir", "dir", "existsSync", "mkdirSync", "eventCounter", "generateEventId", "trackEvent", "eventType", "name", "options", "event", "getIdentityContext", "sanitizeForStorage", "truncate", "eventsPath", "appendFileSync", "logHook", "error", "trackSkillInvoked", "skillName", "args", "success", "durationMs", "trackAgentSpawned", "agentType", "prompt", "trackToolUsed", "toolName", "success", "durationMs", "category", "trackEvent", "truncate", "str", "maxLen", "sanitizeForStorage", "obj", "sanitized", "sensitiveKeys", "key", "value", "s", "TOOL_CATEGORIES", "getToolCategory", "toolName", "extractSkillName", "input", "toolInput", "skillParam", "extractAgentType", "agentType", "extractPromptSummary", "prompt", "wasSuccessful", "userTracking", "toolName", "success", "category", "getToolCategory", "trackToolUsed", "skillName", "trackSkillInvoked", "logHook", "promptSummary", "trackAgentSpawned", "outputSilentSuccess", "error", "existsSync", "readFileSync", "writeFileSync", "METRICS_FILE", "LOCKFILE", "sessionMetrics", "input", "toolName", "outputSilentSuccess", "metrics", "existsSync", "content", "readFileSync", "currentCount", "writeFileSync", "error", "logHook", "existsSync", "readFileSync", "appendFileSync", "mkdirSync", "PATTERN_DEFINITIONS", "getRecentSkill", "sessionStateFile", "existsSync", "content", "readFileSync", "cutoff", "s", "a", "b", "detectPatterns", "diffContent", "detected", "name", "regex", "logEditPattern", "skillId", "filePath", "patterns", "editPatternsFile", "sessionId", "getSessionId", "entry", "mkdirSync", "appendFileSync", "skillEditTracker", "input", "toolName", "outputSilentSuccess", "getField", "projectDir", "getProjectDir", "editContent", "oldString", "newString", "oldLines", "newLines", "l", "logHook", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "MAX_RECORDS", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "ADJUSTMENT_STEP", "keyword", "existing", "a", "MAX_ADJUSTMENT", "updateStats", "data", "records", "successful", "r", "avgConf", "sum", "agentStats", "record", "stat", "agent", "a", "b", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "loadRegistry", "file", "getRegistryFile", "existsSync", "readFileSync", "getSessionId", "getTaskById", "taskId", "loadRegistry", "t", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "loadState", "stateFile", "getStateFile", "existsSync", "data", "readFileSync", "err", "logHook", "getSessionId", "getLastClassification", "loadState", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "getConfigFile", "existsSync", "data", "readFileSync", "extractTaskId", "input", "toolInput", "isTaskStatusUpdate", "statusToOutcome", "status", "calibrationTracker", "outputSilentSuccess", "loadConfig", "taskId", "outcome", "logHook", "task", "getTaskById", "agent", "agentMatch", "getLastClassification", "a", "matchedKeywords", "confidence", "durationMs", "recordOutcome", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "TECH_PATTERNS", "CATEGORY_PATTERNS", "BEST_PRACTICE_CATEGORIES", "getProjectId", "getProjectDir", "extractPatternInfo", "text", "textLower", "tech", "pattern", "name", "regex", "detectBestPracticeCategory", "category", "queuePattern", "outcome", "source", "patternsQueue", "timestamp", "projectId", "existsSync", "mkdirSync", "writeFileSync", "data", "readFileSync", "logHook", "handleGitCommit", "command", "exitCode", "commitMsg", "msgMatch", "patternText", "handlePrMerge", "prInfo", "prMatch", "handleTestResult", "testFramework", "handleBuildResult", "buildTool", "patternExtractor", "input", "outputSilentSuccess", "getField", "commandLower", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "CODE_EXTENSIONS", "getLanguage", "filePath", "detectIndentation", "content", "tabCount", "space2Count", "space4Count", "line", "detectQuoteStyle", "singleCount", "doubleCount", "detectSemicolonStyle", "withSemi", "withoutSemi", "trimmed", "detectTrailingComma", "detectPythonPatterns", "hasTypeHints", "docstringStyle", "loadProfile", "profilePath", "existsSync", "readFileSync", "updateProfile", "profile", "language", "indentation", "quoteStyle", "semiStyle", "trailingComma", "typeHints", "lang", "codeStyleLearner", "input", "toolName", "outputSilentSuccess", "getField", "ext", "projectDir", "getProjectDir", "fullPath", "pyPatterns", "mkdirSync", "writeFileSync", "error", "logHook", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "CODE_EXTENSIONS", "detectCase", "name", "extractPythonIdentifiers", "content", "functions", "m", "classes", "variables", "constants", "extractJsIdentifiers", "interfaces", "types", "countCases", "identifiers", "counts", "caseType", "detectFileNaming", "filePath", "nameWithoutExt", "getLanguage", "loadProfile", "profilePath", "existsSync", "readFileSync", "initLanguageProfile", "namingConventionLearner", "input", "toolName", "outputSilentSuccess", "getField", "ext", "language", "projectDir", "getProjectDir", "fullPath", "fileNaming", "funcCases", "classCases", "varCases", "constCases", "typeCases", "ids", "mkdirSync", "profile", "lang", "writeFileSync", "error", "logHook", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "SKILL_OVERLAPS", "initUsageFile", "usageFile", "existsSync", "mkdirSync", "writeFileSync", "loadUsageData", "readFileSync", "updateUsage", "skill", "sessionId", "data", "timestamp", "logHook", "getSessionSkills", "checkOverlaps", "currentSkill", "sessionSkills", "overlapKey", "suggestion", "skill1", "skill2", "otherSkill", "getUsageStats", "entries", "a", "b", "count", "skillUsageOptimizer", "input", "toolName", "skillName", "getField", "outputSilentSuccess", "getProjectDir", "getSessionId", "overlapSuggestion", "usageStats", "contextMsg", "currentSkillCount", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "extractIssueFromBranch", "branch", "match", "extractIssueFromCommit", "message", "getCurrentBranch", "execSync", "getLatestCommit", "sha", "timestamp", "initProgressFile", "progressFile", "sessionId", "existsSync", "mkdirSync", "writeFileSync", "queueCommitProgress", "issueNum", "commit", "data", "readFileSync", "logHook", "issueProgressCommenter", "input", "outputSilentSuccess", "command", "getField", "exitCode", "commitMsg", "getSessionId", "existsSync", "readFileSync", "writeFileSync", "execSync", "extractTaskFromCommit", "message", "task", "normalizeText", "text", "matchesCheckbox", "commitTask", "checkboxText", "normCommit", "normCheckbox", "commitWords", "w", "checkboxWords", "matchingWords", "word", "extractIssueFromBranch", "branch", "match", "extractIssueFromCommit", "getUncheckedTasks", "issueNum", "lines", "execSync", "unchecked", "line", "updateCheckbox", "logHook", "body", "escapedText", "updatedBody", "repo", "bodyJson", "error", "recordTaskCompletion", "taskText", "progressFile", "existsSync", "data", "readFileSync", "writeFileSync", "issueSubtaskUpdater", "input", "outputSilentSuccess", "command", "getField", "exitCode", "commitMsg", "uncheckedTasks", "matched", "getSessionId", "HOOKS", "sessionMetrics", "auditLogger", "calibrationTracker", "patternExtractor", "issueProgressCommenter", "issueSubtaskUpdater", "mem0WebhookHandler", "codeStyleLearner", "namingConventionLearner", "skillEditTracker", "coordinationHeartbeat", "skillUsageOptimizer", "memoryBridge", "realtimeSync", "userTracking", "matchesTool", "toolName", "matcher", "unifiedDispatcher", "input", "matchingHooks", "HOOKS", "h", "outputSilentSuccess", "results", "hook", "result", "error", "message", "logHook", "failures", "appendFileSync", "mkdirSync", "execSync", "coveragePredictor", "input", "outputSilentSuccess", "filePath", "getField", "projectDir", "getProjectDir", "testPattern", "basename", "testExists", "execSync", "logDir", "mkdirSync", "timestamp", "appendFileSync", "existsSync", "statSync", "appendFileSync", "mkdirSync", "analyzeFileChange", "filePath", "projectDir", "filename", "dirname", "extLower", "existsSync", "pkg", "__require", "fullPath", "readFileSync", "findReadme", "name", "readmeSync", "input", "outputSilentSuccess", "getField", "getProjectDir", "analysis", "readmePath", "contextMsg", "daysOld", "mtime", "statSync", "now", "suggestion", "logDir", "mkdirSync", "timestamp", "appendFileSync", "logHook", "existsSync", "releaseLockOnCommit", "_input", "coordLib", "getProjectDir", "existsSync", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "join", "getLocksFilePath", "projectDir", "isCoordinationEnabled", "existsSync", "getInstanceId", "getProjectDir", "instanceIdPath", "data", "readFileSync", "loadLocks", "locksPath", "saveLocks", "writeFileSync", "cleanExpiredLocks", "locks", "now", "l", "releaseFileLock", "filePath", "instanceId", "originalCount", "logHook", "error", "fileLockRelease", "input", "toolName", "outputSilentSuccess", "getField", "normalizedPath", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "SOLUTION_SUCCESS_PATTERNS", "SOLUTION_FAILURE_PATTERNS", "getOpenProblemsPath", "join", "getProjectDir", "getProblemSolutionsPath", "loadOpenProblems", "sessionId", "filePath", "existsSync", "lines", "readFileSync", "problems", "line", "problem", "err", "logHook", "updateProblemStatus", "problemId", "status", "solution", "updated", "newLines", "writeFileSync", "storeProblemSolutionPair", "pair", "dir", "dirname", "mkdirSync", "hasSolutionIndicators", "output", "pattern", "hasFailureIndicators", "calculateSolutionConfidence", "tool", "exitCode", "confidence", "successCount", "p", "failureCount", "outputLower", "matchingEntities", "e", "summarizeSolution", "file", "l", "match", "context", "extractContext", "trimmed", "text", "position", "windowSize", "start", "end", "sentenceEnd", "pairSolutionWithProblems", "openProblems", "project", "timestamp", "paired", "HOOK_NAME", "MIN_OUTPUT_LENGTH", "SOLUTION_TOOLS", "solutionDetector", "input", "toolName", "outputSilentSuccess", "toolOutput", "extractToolOutput", "hasSolutionIndicators", "sessionId", "getSessionId", "exitCode", "file", "getField", "paired", "pairSolutionWithProblems", "logHook", "err", "toolResult", "content", "output", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "HOOK_NAME", "TOOL_CATEGORIES", "BASH_PATTERNS", "identifyBashTool", "command", "pattern", "toolId", "getToolIdentifier", "tool", "skill", "getToolCategories", "getPreferencesPath", "getProjectDir", "loadPreferences", "filePath", "createEmptyPreferences", "content", "savePreferences", "data", "dir", "err", "logHook", "categories", "usage", "preferences", "cat", "calculatePreference", "category", "tools", "a", "b", "preferredTool", "count", "totalCount", "sum", "c", "sampleConfidence", "dominance", "confidence", "updateAllPreferences", "toolPreferenceLearner", "input", "toolName", "outputSilentSuccess", "getField", "relevantCategories", "pref", "hooks", "auditLogger", "unifiedErrorHandler", "autoLint", "contextBudgetMonitor", "coordinationHeartbeat", "mem0WebhookHandler", "memoryBridge", "realtimeSync", "userTracking", "sessionMetrics", "skillEditTracker", "calibrationTracker", "unifiedDispatcher", "codeStyleLearner", "coveragePredictor", "namingConventionLearner", "readmeSync", "releaseLockOnCommit", "issueProgressCommenter", "issueSubtaskUpdater", "patternExtractor", "skillUsageOptimizer", "fileLockRelease", "solutionDetector", "toolPreferenceLearner", "getHook", "name", "listHooks"]
}
