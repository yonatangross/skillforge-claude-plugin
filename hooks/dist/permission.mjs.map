{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/guards.ts", "../src/permission/auto-approve-readonly.ts", "../src/permission/auto-approve-safe-bash.ts", "../src/permission/auto-approve-project-writes.ts", "../src/permission/learning-tracker.ts", "../src/entries/permission.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result (SubagentStop) */\n  tool_result?: string;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync } from 'node:fs';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// -----------------------------------------------------------------------------\n\nconst PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\nconst PROJECT_DIR = process.env.CLAUDE_PROJECT_DIR || '.';\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME}/.claude/logs/ork`;\n  }\n  return `${PROJECT_DIR}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n */\nexport function getProjectDir(): string {\n  return PROJECT_DIR;\n}\n\n/**\n * Get the plugin root directory\n */\nexport function getPluginRoot(): string {\n  return PLUGIN_ROOT;\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ guarantees CLAUDE_SESSION_ID availability - no fallback needed\n * Read dynamically to support testing\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID!;\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n */\nexport function logHook(hookName: string, message: string): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = input?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = input?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    // Use fs.readSync for synchronous stdin reading\n    const { readSync } = require('node:fs');\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Self-guard helpers for TypeScript hooks\n * Ported from hooks/_lib/common.sh guard functions\n *\n * Guards are predicates that determine if a hook should run.\n * They return `true` to run the hook, `false` to skip it.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess } from './common.js';\n\n/**\n * Guard result type - either continue (null) or skip with result\n */\nexport type GuardResult = HookResult | null;\n\n/**\n * Create a guard that returns silent success if predicate fails\n */\nexport function createGuard(\n  predicate: (input: HookInput) => boolean\n): (input: HookInput) => GuardResult {\n  return (input: HookInput) => (predicate(input) ? null : outputSilentSuccess());\n}\n\n// -----------------------------------------------------------------------------\n// File Extension Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for specific file extensions\n */\nexport function guardFileExtension(\n  input: HookInput,\n  ...extensions: string[]\n): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  const normalizedExtensions = extensions.map((e) => e.toLowerCase().replace(/^\\./, ''));\n\n  if (normalizedExtensions.includes(ext)) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Only run for code files\n */\nexport function guardCodeFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java');\n}\n\n/**\n * Guard: Only run for Python files\n */\nexport function guardPythonFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'py');\n}\n\n/**\n * Guard: Only run for TypeScript/JavaScript files\n */\nexport function guardTypescriptFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'ts', 'tsx', 'js', 'jsx');\n}\n\n// -----------------------------------------------------------------------------\n// Path Pattern Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for test files\n */\nexport function guardTestFiles(input: HookInput): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  const testPatterns = [/test/i, /spec/i, /__tests__/i];\n  if (testPatterns.some((p) => p.test(filePath))) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Skip internal/generated files\n */\nexport function guardSkipInternal(input: HookInput): GuardResult {\n  const filePath = input.tool_input.file_path || '';\n  if (!filePath) return null; // No file path, continue\n\n  // Skip these directories/patterns\n  const skipPatterns = [\n    /\\/\\.claude\\//,\n    /\\/node_modules\\//,\n    /\\/\\.git\\//,\n    /\\/dist\\//,\n    /\\/build\\//,\n    /\\/__pycache__\\//,\n    /\\/\\.venv\\//,\n    /\\/venv\\//,\n    /\\.lock$/,\n  ];\n\n  if (skipPatterns.some((p) => p.test(filePath))) {\n    return outputSilentSuccess();\n  }\n\n  return null; // Continue with hook\n}\n\n/**\n * Guard: Only run for files matching path patterns\n */\nexport function guardPathPattern(input: HookInput, ...patterns: (string | RegExp)[]): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  for (const pattern of patterns) {\n    if (typeof pattern === 'string') {\n      // Simple glob-like matching\n      const regex = new RegExp(pattern.replace(/\\*/g, '.*').replace(/\\?/g, '.'));\n      if (regex.test(filePath)) return null;\n    } else {\n      if (pattern.test(filePath)) return null;\n    }\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Tool Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for specific tool names\n */\nexport function guardTool(input: HookInput, ...tools: string[]): GuardResult {\n  const toolName = input.tool_name;\n  if (!toolName) return outputSilentSuccess();\n\n  if (tools.includes(toolName)) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Only run for Write or Edit tools\n */\nexport function guardWriteEdit(input: HookInput): GuardResult {\n  return guardTool(input, 'Write', 'Edit');\n}\n\n/**\n * Guard: Only run for Bash tool\n */\nexport function guardBash(input: HookInput): GuardResult {\n  return guardTool(input, 'Bash');\n}\n\n// -----------------------------------------------------------------------------\n// Command Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for non-trivial bash commands\n */\nexport function guardNontrivialBash(input: HookInput): GuardResult {\n  const command = input.tool_input.command || '';\n\n  // Skip trivial commands\n  const trivialPatterns = [\n    /^echo\\s/,\n    /^ls(\\s|$)/,\n    /^pwd$/,\n    /^cat\\s/,\n    /^head\\s/,\n    /^tail\\s/,\n    /^wc\\s/,\n    /^date$/,\n    /^whoami$/,\n  ];\n\n  if (trivialPatterns.some((p) => p.test(command))) {\n    return outputSilentSuccess();\n  }\n\n  return null; // Continue with hook\n}\n\n/**\n * Guard: Only run for git commands\n */\nexport function guardGitCommand(input: HookInput): GuardResult {\n  const command = input.tool_input.command || '';\n\n  if (command.startsWith('git')) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Environment Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run if multi-instance coordination is enabled\n */\nexport function guardMultiInstance(input: HookInput): GuardResult {\n  const projectDir = input.project_dir || process.env.CLAUDE_PROJECT_DIR || '.';\n  const dbPath = `${projectDir}/.claude/coordination/.claude.db`;\n\n  try {\n    const { existsSync } = require('node:fs');\n    if (existsSync(dbPath)) {\n      return null; // Continue with hook\n    }\n  } catch {\n    // Ignore errors\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Composite Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Run multiple guards in sequence, return first skip result or null to continue\n */\nexport function runGuards(input: HookInput, ...guards: ((input: HookInput) => GuardResult)[]): GuardResult {\n  for (const guard of guards) {\n    const result = guard(input);\n    if (result !== null) {\n      return result; // Skip with this result\n    }\n  }\n  return null; // All guards passed, continue\n}\n", "/**\n * Auto-Approve Readonly - Automatically approves read-only operations\n * Hook: PermissionRequest (Read|Glob|Grep)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentAllow, logHook, logPermissionFeedback } from '../lib/common.js';\n\n/**\n * Auto-approve read-only tools: Read, Glob, Grep\n */\nexport function autoApproveReadonly(input: HookInput): HookResult {\n  const toolName = input.tool_name;\n\n  logHook('auto-approve-readonly', `Auto-approving readonly: ${toolName}`);\n  logPermissionFeedback('allow', `Auto-approved readonly: ${toolName}`, input);\n\n  return outputSilentAllow();\n}\n", "/**\n * Auto-Approve Safe Bash - Automatically approves safe bash commands\n * Hook: PermissionRequest (Bash)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentAllow,\n  outputSilentSuccess,\n  logHook,\n  logPermissionFeedback,\n} from '../lib/common.js';\n\n/**\n * Safe command patterns that should be auto-approved\n */\nconst SAFE_PATTERNS: RegExp[] = [\n  // Git read operations\n  /^git (status|log|diff|branch|show|fetch|pull)/,\n  /^git checkout/,\n\n  // Package managers - read operations\n  /^npm (list|ls|outdated|audit|run|test)/,\n  /^pnpm (list|ls|outdated|audit|run|test)/,\n  /^yarn (list|outdated|audit|run|test)/,\n  /^poetry (show|run|env)/,\n\n  // Docker - read operations\n  /^docker (ps|images|logs|inspect)/,\n  /^docker-compose (ps|logs)/,\n  /^docker compose (ps|logs)/,\n\n  // Basic shell commands\n  /^ls(\\s|$)/,\n  /^pwd$/,\n  /^echo\\s/,\n  /^cat\\s/,\n  /^head\\s/,\n  /^tail\\s/,\n  /^wc\\s/,\n  /^find\\s/,\n  /^which\\s/,\n  /^type\\s/,\n  /^env$/,\n  /^printenv/,\n\n  // GitHub CLI - read operations\n  /^gh (issue|pr|repo|workflow) (list|view|status)/,\n  /^gh milestone/,\n\n  // Testing and linting\n  /^pytest/,\n  /^poetry run pytest/,\n  /^npm run (test|lint|typecheck|format)/,\n  /^ruff (check|format)/,\n  /^ty check/,\n  /^mypy/,\n];\n\n/**\n * Auto-approve safe bash commands\n */\nexport function autoApproveSafeBash(input: HookInput): HookResult {\n  const command = input.tool_input.command || '';\n\n  logHook('auto-approve-safe-bash', `Evaluating bash command: ${command.slice(0, 50)}...`);\n\n  // Check against safe patterns\n  for (const pattern of SAFE_PATTERNS) {\n    if (pattern.test(command)) {\n      logHook('auto-approve-safe-bash', `Auto-approved: matches safe pattern ${pattern}`);\n      logPermissionFeedback('allow', `Matches safe pattern: ${pattern}`, input);\n      return outputSilentAllow();\n    }\n  }\n\n  // Not a recognized safe command - let user decide (silent passthrough)\n  logHook('auto-approve-safe-bash', 'Command requires manual approval');\n  return outputSilentSuccess();\n}\n", "/**\n * Auto-Approve Project Writes - Auto-approves writes within project directory\n * Hook: PermissionRequest (Write|Edit)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentAllow,\n  outputSilentSuccess,\n  logHook,\n  logPermissionFeedback,\n  getProjectDir,\n} from '../lib/common.js';\nimport { resolve, isAbsolute } from 'node:path';\n\n/**\n * Directories that should not be auto-approved for writes\n */\nconst EXCLUDED_DIRS = [\n  'node_modules',\n  '.git',\n  'dist',\n  'build',\n  '__pycache__',\n  '.venv',\n  'venv',\n];\n\n/**\n * Auto-approve writes within project directory (excluding sensitive directories)\n */\nexport function autoApproveProjectWrites(input: HookInput): HookResult {\n  let filePath = input.tool_input.file_path || '';\n  const projectDir = getProjectDir();\n\n  logHook('auto-approve-project-writes', `Evaluating write to: ${filePath}`);\n\n  // Resolve to absolute path if relative\n  if (!isAbsolute(filePath)) {\n    filePath = resolve(projectDir, filePath);\n  }\n\n  // Check if file is within project directory\n  if (filePath.startsWith(projectDir)) {\n    // Check against excluded directories\n    for (const dir of EXCLUDED_DIRS) {\n      if (filePath.includes(`/${dir}/`)) {\n        logHook('auto-approve-project-writes', `Write to excluded directory: ${dir}`);\n        return outputSilentSuccess(); // Let user decide\n      }\n    }\n\n    logHook('auto-approve-project-writes', 'Auto-approved: within project directory');\n    logPermissionFeedback('allow', `In-project write: ${filePath}`, input);\n    return outputSilentAllow();\n  }\n\n  // Outside project directory - let user decide\n  logHook('auto-approve-project-writes', 'Write outside project directory - manual approval required');\n  return outputSilentSuccess();\n}\n", "/**\n * Permission Learning Tracker - Learns from user approval patterns\n * Hook: PermissionRequest (Post-approval tracking)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n *\n * This hook runs AFTER other permission hooks and tracks:\n * 1. Commands that are approved manually (potential auto-approve candidates)\n * 2. Patterns in approved commands for learning\n * 3. Frequency of command types\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  outputSilentAllow,\n  logHook,\n  logPermissionFeedback,\n  getPluginRoot,\n} from '../lib/common.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Security blocklist - commands that should never be auto-approved\n */\nconst SECURITY_BLOCKLIST: RegExp[] = [\n  /rm\\s+-rf\\s+[/~]/,\n  /sudo\\s/,\n  /chmod\\s+-R\\s+777/,\n  />\\s*\\/dev\\/sd/,\n  /mkfs\\./,\n  /dd\\s+if=/,\n  /:.*\\(\\).*\\{.*\\|.*&.*\\}/,\n  /curl.*\\|\\s*sh/,\n  /wget.*\\|\\s*sh/,\n];\n\n/**\n * Check if command matches security blocklist\n */\nfunction isSecurityBlocked(command: string): boolean {\n  return SECURITY_BLOCKLIST.some((pattern) => pattern.test(command));\n}\n\n/**\n * Load learned patterns from feedback file\n */\nfunction loadLearnedPatterns(): string[] {\n  const pluginRoot = getPluginRoot();\n  const feedbackFile = join(pluginRoot, '.claude', 'feedback', 'learned-patterns.json');\n\n  try {\n    if (existsSync(feedbackFile)) {\n      const data = JSON.parse(readFileSync(feedbackFile, 'utf8'));\n      return data.autoApprovePatterns || [];\n    }\n  } catch {\n    // Ignore errors\n  }\n\n  return [];\n}\n\n/**\n * Check if command matches a learned auto-approve pattern\n */\nfunction shouldAutoApprove(command: string): boolean {\n  const patterns = loadLearnedPatterns();\n\n  for (const pattern of patterns) {\n    try {\n      const regex = new RegExp(pattern);\n      if (regex.test(command)) {\n        return true;\n      }\n    } catch {\n      // Invalid pattern, skip\n    }\n  }\n\n  return false;\n}\n\n/**\n * Learning tracker hook - observes permissions for learning, optionally auto-approves\n */\nexport function learningTracker(input: HookInput): HookResult {\n  const toolName = input.tool_name;\n  const command = input.tool_input.command || input.tool_input.file_path || '';\n\n  logHook('learning-tracker', `Processing permission for tool: ${toolName}, command: ${command.slice(0, 50)}...`);\n\n  // For Bash commands, check if we should auto-approve based on learned patterns\n  if (toolName === 'Bash' && command) {\n    // First check security blocklist - never auto-approve these\n    if (isSecurityBlocked(command)) {\n      logHook('learning-tracker', 'Command matches security blocklist, skipping');\n      return outputSilentSuccess();\n    }\n\n    // Check if this command matches a learned auto-approve pattern\n    if (shouldAutoApprove(command)) {\n      logHook('learning-tracker', 'Command matches learned auto-approve pattern');\n      logPermissionFeedback('allow', 'Learned pattern match', input);\n      return outputSilentAllow();\n    }\n  }\n\n  // Output: Silent pass-through (don't affect the permission decision)\n  // This hook observes for learning purposes\n  return outputSilentSuccess();\n}\n", "/**\n * Permission Hooks Entry Point\n *\n * Hooks that handle permission decisions (PreToolUse with permissionDecision)\n * Bundle: permission.mjs (~15 KB estimated)\n */\n\n// Re-export types and utilities needed by permission hooks\nexport * from '../types.js';\nexport * from '../lib/common.js';\nexport * from '../lib/guards.js';\n\n// Import hook implementations\nimport { autoApproveReadonly } from '../permission/auto-approve-readonly.js';\nimport { autoApproveSafeBash } from '../permission/auto-approve-safe-bash.js';\nimport { autoApproveProjectWrites } from '../permission/auto-approve-project-writes.js';\nimport { learningTracker } from '../permission/learning-tracker.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Permission hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'permission/auto-approve-readonly': autoApproveReadonly,\n  'permission/auto-approve-safe-bash': autoApproveSafeBash,\n  'permission/auto-approve-project-writes': autoApproveProjectWrites,\n  'permission/learning-tracker': learningTracker,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": ";;;yPAkLO,SAASA,EAAYC,EAA0C,CACpE,OAAO,OAAOA,EAAM,SAAY,QAClC,CAEO,SAASC,EAAaD,EAA2C,CACtE,OAAO,OAAOA,EAAM,WAAc,UAAY,OAAOA,EAAM,SAAY,QACzE,CAEO,SAASE,EAAYF,EAA0C,CACpE,OACE,OAAOA,EAAM,WAAc,UAC3B,OAAOA,EAAM,YAAe,UAC5B,OAAOA,EAAM,YAAe,QAEhC,CAEO,SAASG,EAAYH,EAA0C,CACpE,OAAO,OAAOA,EAAM,WAAc,UAAYA,EAAM,UAAY,MAClE,CC/LA,OAAS,kBAAAI,EAAgB,cAAAC,EAAY,YAAAC,EAAU,cAAAC,EAAY,aAAAC,MAAiB,UAO5E,IAAMC,EAAc,QAAQ,IAAI,oBAAsB,QAAQ,IAAI,oBAAsB,IAClFC,EAAc,QAAQ,IAAI,oBAAsB,IAK/C,SAASC,GAAoB,CAClC,OAAI,QAAQ,IAAI,mBACP,GAAG,QAAQ,IAAI,IAAI,oBAErB,GAAGD,CAAW,eACvB,CAKO,SAASE,GAAwB,CACtC,OAAOF,CACT,CAKO,SAASG,GAAwB,CACtC,OAAOJ,CACT,CAOO,SAASK,GAAuB,CACrC,OAAO,QAAQ,IAAI,iBACrB,CASO,SAASC,GAAkC,CAChD,MAAO,CAAE,SAAU,GAAM,eAAgB,EAAK,CAChD,CAKO,SAASC,GAAgC,CAC9C,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAAE,mBAAoB,OAAQ,CACpD,CACF,CAKO,SAASC,EAAYC,EAA4B,CACtD,MAAO,CACL,SAAU,GACV,WAAYA,EACZ,mBAAoB,CAClB,mBAAoB,OACpB,yBAA0BA,CAC5B,CACF,CACF,CAMO,SAASC,GAAkBC,EAAyB,CACzD,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAClB,cAAe,cACf,kBAAmBA,CACrB,CACF,CACF,CAMO,SAASC,GAAoBD,EAAyB,CAC3D,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAClB,cAAe,mBACf,kBAAmBA,CACrB,CACF,CACF,CAKO,SAASE,GAAuBF,EAAaG,EAAoC,CACtF,IAAMC,EAAqB,CACzB,SAAU,GACV,mBAAoB,CAClB,cAAe,aACf,kBAAmBJ,EACnB,mBAAoB,OACtB,CACF,EAEA,OAAIG,EACFC,EAAO,cAAgBD,EAEvBC,EAAO,eAAiB,GAGnBA,CACT,CAKO,SAASC,GAAYC,EAA6B,CACvD,MAAO,CAAE,SAAU,GAAM,cAAeA,CAAQ,CAClD,CAKO,SAASC,GAAcD,EAA6B,CACzD,MAAO,CAAE,SAAU,GAAM,cAAe,UAAUA,CAAO,EAAG,CAC9D,CAKO,SAASE,GAAWV,EAA4B,CACrD,MAAO,CACL,SAAU,GACV,WAAYA,EACZ,mBAAoB,CAClB,cAAe,aACf,mBAAoB,OACpB,yBAA0BA,CAC5B,CACF,CACF,CAMA,IAAMW,EAAwB,IAAM,KAC9BC,EAA0B,IAAM,KAKtC,SAASC,EAAcC,EAAiBC,EAAuB,CAC7D,GAAK5B,EAAW2B,CAAO,EAEvB,GAAI,CAEF,GADc1B,EAAS0B,CAAO,EACpB,KAAOC,EAAS,CACxB,IAAMC,EAAU,GAAGF,CAAO,QAAQ,KAAK,IAAI,CAAC,GAC5CzB,EAAWyB,EAASE,CAAO,CAC7B,CACF,MAAQ,CAER,CACF,CAKA,SAASC,EAAUC,EAAmB,CAC/B/B,EAAW+B,CAAG,GACjB5B,EAAU4B,EAAK,CAAE,UAAW,EAAK,CAAC,CAEtC,CAKO,SAASC,EAAQC,EAAkBZ,EAAuB,CAC/D,IAAMa,EAAS5B,EAAU,EACnBqB,EAAU,GAAGO,CAAM,aAEzB,GAAI,CACFJ,EAAUI,CAAM,EAChBR,EAAcC,EAASH,CAAqB,EAE5C,IAAMW,EAAY,IAAI,KAAK,EAAE,YAAY,EAAE,QAAQ,IAAK,GAAG,EAAE,MAAM,EAAG,EAAE,EACxEpC,EAAe4B,EAAS,IAAIQ,CAAS,MAAMF,CAAQ,KAAKZ,CAAO;AAAA,CAAI,CACrE,MAAQ,CAER,CACF,CAKO,SAASe,EACdC,EACAxB,EACAyB,EACM,CACN,IAAMJ,EAAS5B,EAAU,EACnBqB,EAAU,GAAGO,CAAM,2BAEzB,GAAI,CACFJ,EAAUI,CAAM,EAChBR,EAAcC,EAASF,CAAuB,EAE9C,IAAMU,EAAY,IAAI,KAAK,EAAE,YAAY,EACnCI,EAAWD,GAAO,WAAa,QAAQ,IAAI,gBAAkB,UAC7DE,EAAYF,GAAO,YAAc7B,EAAa,EAEpDV,EACE4B,EACA,GAAGQ,CAAS,MAAME,CAAQ,MAAMxB,CAAM,WAAW0B,CAAQ,cAAcC,CAAS;AAAA,CAClF,CACF,MAAQ,CAER,CACF,CAUO,SAASC,IAA2B,CACzC,GAAI,CAEF,IAAMC,EAAmB,CAAC,EAEpBC,EAAM,OAAO,YAAY,GAAO,EAElCC,EACEC,EAAK,EAGL,CAAE,SAAAC,CAAS,EAAI,EAAQ,SAAS,EACtC,OACE,GAAI,CAEF,GADAF,EAAYE,EAASD,EAAIF,EAAK,EAAG,IAAS,IAAI,EAC1CC,IAAc,EAAG,MACrBF,EAAO,KAAK,OAAO,KAAKC,EAAI,SAAS,EAAGC,CAAS,CAAC,CAAC,CACrD,MAAQ,CACN,KACF,CAGF,IAAMN,EAAQ,OAAO,OAAOI,CAAM,EAAE,SAAS,MAAM,EAAE,KAAK,EAC1D,OAAKJ,EAIE,KAAK,MAAMA,CAAK,EAHd,CAAE,UAAW,GAAI,WAAY7B,EAAa,EAAG,WAAY,CAAC,CAAE,CAIvE,MAAQ,CACN,MAAO,CAAE,UAAW,GAAI,WAAYA,EAAa,EAAG,WAAY,CAAC,CAAE,CACrE,CACF,CAKO,SAASsC,GAAYT,EAAkBU,EAA6B,CACzE,IAAMC,EAAQD,EAAK,QAAQ,MAAO,EAAE,EAAE,MAAM,GAAG,EAC3CE,EAAiBZ,EAErB,QAAWa,KAAQF,EAAO,CACxB,GAAIC,GAAU,KAA6B,OAC3CA,EAASA,EAAkCC,CAAI,CACjD,CAEA,OAAOD,CACT,CAUO,SAASE,GAAiBC,EAAyB,CACxD,OAAOA,EACJ,QAAQ,gBAAiB,GAAG,EAC5B,QAAQ,MAAO,GAAG,EAClB,QAAQ,OAAQ,GAAG,EACnB,KAAK,CACV,CAKO,SAASC,GAAYC,EAAqB,CAC/C,OAAOA,EAAI,QAAQ,sBAAuB,MAAM,CAClD,CC9SO,SAASC,GACdC,EACmC,CACnC,OAAQC,GAAsBD,EAAUC,CAAK,EAAI,KAAOC,EAAoB,CAC9E,CASO,SAASC,EACdF,KACGG,EACU,CACb,IAAMC,EAAWJ,EAAM,WAAW,UAClC,GAAI,CAACI,EAAU,OAAOH,EAAoB,EAE1C,IAAMI,EAAMD,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,GAAK,GAGxD,OAF6BD,EAAW,IAAKG,GAAMA,EAAE,YAAY,EAAE,QAAQ,MAAO,EAAE,CAAC,EAE5D,SAASD,CAAG,EAC5B,KAGFJ,EAAoB,CAC7B,CAKO,SAASM,GAAeP,EAA+B,CAC5D,OAAOE,EAAmBF,EAAO,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,KAAM,MAAM,CACrF,CAKO,SAASQ,GAAiBR,EAA+B,CAC9D,OAAOE,EAAmBF,EAAO,IAAI,CACvC,CAKO,SAASS,GAAqBT,EAA+B,CAClE,OAAOE,EAAmBF,EAAO,KAAM,MAAO,KAAM,KAAK,CAC3D,CASO,SAASU,GAAeV,EAA+B,CAC5D,IAAMI,EAAWJ,EAAM,WAAW,UAClC,OAAKI,EAEgB,CAAC,QAAS,QAAS,YAAY,EACnC,KAAMO,GAAMA,EAAE,KAAKP,CAAQ,CAAC,EACpC,KAGFH,EAAoB,EAPLA,EAAoB,CAQ5C,CAKO,SAASW,GAAkBZ,EAA+B,CAC/D,IAAMI,EAAWJ,EAAM,WAAW,WAAa,GAC/C,OAAKI,GAGgB,CACnB,eACA,mBACA,YACA,WACA,YACA,kBACA,aACA,WACA,SACF,EAEiB,KAAMO,GAAMA,EAAE,KAAKP,CAAQ,CAAC,EACpCH,EAAoB,EAhBP,IAoBxB,CAKO,SAASY,GAAiBb,KAAqBc,EAA4C,CAChG,IAAMV,EAAWJ,EAAM,WAAW,UAClC,GAAI,CAACI,EAAU,OAAOH,EAAoB,EAE1C,QAAWc,KAAWD,EACpB,GAAI,OAAOC,GAAY,UAGrB,GADc,IAAI,OAAOA,EAAQ,QAAQ,MAAO,IAAI,EAAE,QAAQ,MAAO,GAAG,CAAC,EAC/D,KAAKX,CAAQ,EAAG,OAAO,aAE7BW,EAAQ,KAAKX,CAAQ,EAAG,OAAO,KAIvC,OAAOH,EAAoB,CAC7B,CASO,SAASe,EAAUhB,KAAqBiB,EAA8B,CAC3E,IAAMC,EAAWlB,EAAM,UACvB,OAAKkB,EAEDD,EAAM,SAASC,CAAQ,EAClB,KAGFjB,EAAoB,EANLA,EAAoB,CAO5C,CAKO,SAASkB,GAAenB,EAA+B,CAC5D,OAAOgB,EAAUhB,EAAO,QAAS,MAAM,CACzC,CAKO,SAASoB,GAAUpB,EAA+B,CACvD,OAAOgB,EAAUhB,EAAO,MAAM,CAChC,CASO,SAASqB,GAAoBrB,EAA+B,CACjE,IAAMsB,EAAUtB,EAAM,WAAW,SAAW,GAe5C,MAZwB,CACtB,UACA,YACA,QACA,SACA,UACA,UACA,QACA,SACA,UACF,EAEoB,KAAMW,GAAMA,EAAE,KAAKW,CAAO,CAAC,EACtCrB,EAAoB,EAGtB,IACT,CAKO,SAASsB,GAAgBvB,EAA+B,CAG7D,OAFgBA,EAAM,WAAW,SAAW,IAEhC,WAAW,KAAK,EACnB,KAGFC,EAAoB,CAC7B,CASO,SAASuB,GAAmBxB,EAA+B,CAEhE,IAAMyB,EAAS,GADIzB,EAAM,aAAe,QAAQ,IAAI,oBAAsB,GAC9C,mCAE5B,GAAI,CACF,GAAM,CAAE,WAAA0B,CAAW,EAAI,EAAQ,SAAS,EACxC,GAAIA,EAAWD,CAAM,EACnB,OAAO,IAEX,MAAQ,CAER,CAEA,OAAOxB,EAAoB,CAC7B,CASO,SAAS0B,GAAU3B,KAAqB4B,EAA4D,CACzG,QAAWC,KAASD,EAAQ,CAC1B,IAAME,EAASD,EAAM7B,CAAK,EAC1B,GAAI8B,IAAW,KACb,OAAOA,CAEX,CACA,OAAO,IACT,CC7OO,SAASC,EAAoBC,EAA8B,CAChE,IAAMC,EAAWD,EAAM,UAEvB,OAAAE,EAAQ,wBAAyB,4BAA4BD,CAAQ,EAAE,EACvEE,EAAsB,QAAS,2BAA2BF,CAAQ,GAAID,CAAK,EAEpEI,EAAkB,CAC3B,CCFA,IAAMC,EAA0B,CAE9B,gDACA,gBAGA,yCACA,0CACA,uCACA,yBAGA,mCACA,4BACA,4BAGA,YACA,QACA,UACA,SACA,UACA,UACA,QACA,UACA,WACA,UACA,QACA,YAGA,kDACA,gBAGA,UACA,qBACA,wCACA,uBACA,YACA,OACF,EAKO,SAASC,EAAoBC,EAA8B,CAChE,IAAMC,EAAUD,EAAM,WAAW,SAAW,GAE5CE,EAAQ,yBAA0B,4BAA4BD,EAAQ,MAAM,EAAG,EAAE,CAAC,KAAK,EAGvF,QAAWE,KAAWL,EACpB,GAAIK,EAAQ,KAAKF,CAAO,EACtB,OAAAC,EAAQ,yBAA0B,uCAAuCC,CAAO,EAAE,EAClFC,EAAsB,QAAS,yBAAyBD,CAAO,GAAIH,CAAK,EACjEK,EAAkB,EAK7B,OAAAH,EAAQ,yBAA0B,kCAAkC,EAC7DI,EAAoB,CAC7B,CClEA,OAAS,WAAAC,EAAS,cAAAC,MAAkB,YAKpC,IAAMC,EAAgB,CACpB,eACA,OACA,OACA,QACA,cACA,QACA,MACF,EAKO,SAASC,EAAyBC,EAA8B,CACrE,IAAIC,EAAWD,EAAM,WAAW,WAAa,GACvCE,EAAaC,EAAc,EAUjC,GARAC,EAAQ,8BAA+B,wBAAwBH,CAAQ,EAAE,EAGpEJ,EAAWI,CAAQ,IACtBA,EAAWL,EAAQM,EAAYD,CAAQ,GAIrCA,EAAS,WAAWC,CAAU,EAAG,CAEnC,QAAWG,KAAOP,EAChB,GAAIG,EAAS,SAAS,IAAII,CAAG,GAAG,EAC9B,OAAAD,EAAQ,8BAA+B,gCAAgCC,CAAG,EAAE,EACrEC,EAAoB,EAI/B,OAAAF,EAAQ,8BAA+B,yCAAyC,EAChFG,EAAsB,QAAS,qBAAqBN,CAAQ,GAAID,CAAK,EAC9DQ,EAAkB,CAC3B,CAGA,OAAAJ,EAAQ,8BAA+B,4DAA4D,EAC5FE,EAAoB,CAC7B,CC1CA,OAAS,cAAAG,EAAY,gBAAAC,MAAoB,UACzC,OAAS,QAAAC,MAAY,YAKrB,IAAMC,EAA+B,CACnC,kBACA,SACA,mBACA,gBACA,SACA,WACA,yBACA,gBACA,eACF,EAKA,SAASC,EAAkBC,EAA0B,CACnD,OAAOF,EAAmB,KAAMG,GAAYA,EAAQ,KAAKD,CAAO,CAAC,CACnE,CAKA,SAASE,GAAgC,CACvC,IAAMC,EAAaC,EAAc,EAC3BC,EAAeR,EAAKM,EAAY,UAAW,WAAY,uBAAuB,EAEpF,GAAI,CACF,GAAIR,EAAWU,CAAY,EAEzB,OADa,KAAK,MAAMT,EAAaS,EAAc,MAAM,CAAC,EAC9C,qBAAuB,CAAC,CAExC,MAAQ,CAER,CAEA,MAAO,CAAC,CACV,CAKA,SAASC,EAAkBN,EAA0B,CACnD,IAAMO,EAAWL,EAAoB,EAErC,QAAWD,KAAWM,EACpB,GAAI,CAEF,GADc,IAAI,OAAON,CAAO,EACtB,KAAKD,CAAO,EACpB,MAAO,EAEX,MAAQ,CAER,CAGF,MAAO,EACT,CAKO,SAASQ,EAAgBC,EAA8B,CAC5D,IAAMC,EAAWD,EAAM,UACjBT,EAAUS,EAAM,WAAW,SAAWA,EAAM,WAAW,WAAa,GAK1E,GAHAE,EAAQ,mBAAoB,mCAAmCD,CAAQ,cAAcV,EAAQ,MAAM,EAAG,EAAE,CAAC,KAAK,EAG1GU,IAAa,QAAUV,EAAS,CAElC,GAAID,EAAkBC,CAAO,EAC3B,OAAAW,EAAQ,mBAAoB,8CAA8C,EACnEC,EAAoB,EAI7B,GAAIN,EAAkBN,CAAO,EAC3B,OAAAW,EAAQ,mBAAoB,8CAA8C,EAC1EE,EAAsB,QAAS,wBAAyBJ,CAAK,EACtDK,EAAkB,CAE7B,CAIA,OAAOF,EAAoB,CAC7B,CCxFO,IAAMG,EAAgC,CAC3C,mCAAoCC,EACpC,oCAAqCC,EACrC,yCAA0CC,EAC1C,8BAA+BC,CACjC,EAEO,SAASC,GAAQC,EAAkC,CACxD,OAAON,EAAMM,CAAI,CACnB,CAEO,SAASC,IAAsB,CACpC,OAAO,OAAO,KAAKP,CAAK,CAC1B",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "PLUGIN_ROOT", "PROJECT_DIR", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "createGuard", "predicate", "input", "outputSilentSuccess", "guardFileExtension", "extensions", "filePath", "ext", "e", "guardCodeFiles", "guardPythonFiles", "guardTypescriptFiles", "guardTestFiles", "p", "guardSkipInternal", "guardPathPattern", "patterns", "pattern", "guardTool", "tools", "toolName", "guardWriteEdit", "guardBash", "guardNontrivialBash", "command", "guardGitCommand", "guardMultiInstance", "dbPath", "existsSync", "runGuards", "guards", "guard", "result", "autoApproveReadonly", "input", "toolName", "logHook", "logPermissionFeedback", "outputSilentAllow", "SAFE_PATTERNS", "autoApproveSafeBash", "input", "command", "logHook", "pattern", "logPermissionFeedback", "outputSilentAllow", "outputSilentSuccess", "resolve", "isAbsolute", "EXCLUDED_DIRS", "autoApproveProjectWrites", "input", "filePath", "projectDir", "getProjectDir", "logHook", "dir", "outputSilentSuccess", "logPermissionFeedback", "outputSilentAllow", "existsSync", "readFileSync", "join", "SECURITY_BLOCKLIST", "isSecurityBlocked", "command", "pattern", "loadLearnedPatterns", "pluginRoot", "getPluginRoot", "feedbackFile", "shouldAutoApprove", "patterns", "learningTracker", "input", "toolName", "logHook", "outputSilentSuccess", "logPermissionFeedback", "outputSilentAllow", "hooks", "autoApproveReadonly", "autoApproveSafeBash", "autoApproveProjectWrites", "learningTracker", "getHook", "name", "listHooks"]
}
