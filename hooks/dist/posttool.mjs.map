{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/git.ts", "../src/posttool/audit-logger.ts", "../src/posttool/auto-lint.ts", "../src/posttool/context-budget-monitor.ts", "../src/posttool/coordination-heartbeat.ts", "../src/posttool/error-collector.ts", "../src/posttool/error-solution-suggester.ts", "../src/posttool/error-tracker.ts", "../src/posttool/mem0-webhook-handler.ts", "../src/posttool/memory-bridge.ts", "../src/posttool/realtime-sync.ts", "../src/posttool/session-metrics.ts", "../src/posttool/skill-edit-tracker.ts", "../src/lib/calibration-engine.ts", "../src/lib/task-integration.ts", "../src/lib/orchestration-state.ts", "../src/posttool/calibration-tracker.ts", "../src/posttool/write/code-style-learner.ts", "../src/posttool/write/coverage-predictor.ts", "../src/posttool/write/naming-convention-learner.ts", "../src/posttool/write/readme-sync.ts", "../src/posttool/write/release-lock-on-commit.ts", "../src/posttool/bash/issue-progress-commenter.ts", "../src/posttool/bash/issue-subtask-updater.ts", "../src/posttool/bash/pattern-extractor.ts", "../src/posttool/skill/skill-usage-optimizer.ts", "../src/posttool/write-edit/file-lock-release.ts", "../src/entries/posttool.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result (SubagentStop) */\n  tool_result?: string;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync } from 'node:fs';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME}/.claude/logs/ork`;\n  }\n  return `${getProjectDir()}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n * Read dynamically to support testing\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory\n * Read dynamically to support testing\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability, but we add\n * a defensive fallback to prevent hook crashes during edge cases.\n * Read dynamically to support testing.\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}-${Date.now()}`;\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  const { execSync } = require('node:child_process');\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    // Use fs.readSync for synchronous stdin reading\n    const { readSync } = require('node:fs');\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Git utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh git functions\n */\n\nimport { execSync } from 'node:child_process';\nimport { getProjectDir } from './common.js';\n\n/**\n * Get the current git branch\n */\nexport function getCurrentBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Check if on a protected branch (dev, main, master)\n */\nexport function isProtectedBranch(branch?: string): boolean {\n  const currentBranch = branch || getCurrentBranch();\n  return ['dev', 'main', 'master'].includes(currentBranch);\n}\n\n/**\n * Get the repository root directory\n */\nexport function getRepoRoot(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return dir;\n  }\n}\n\n/**\n * Check if path is inside a git repository\n */\nexport function isGitRepo(projectDir?: string): boolean {\n  const dir = projectDir || getProjectDir();\n  try {\n    execSync('git rev-parse --git-dir', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get git status (short format)\n */\nexport function getGitStatus(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git status --short', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Check if there are uncommitted changes\n */\nexport function hasUncommittedChanges(projectDir?: string): boolean {\n  return getGitStatus(projectDir).length > 0;\n}\n\n/**\n * Get the default branch (main or master)\n */\nexport function getDefaultBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    // Check if 'main' exists\n    execSync('git rev-parse --verify main', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return 'main';\n  } catch {\n    try {\n      // Check if 'master' exists\n      execSync('git rev-parse --verify master', {\n        cwd: dir,\n        encoding: 'utf8',\n        timeout: 5000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n      return 'master';\n    } catch {\n      return 'main'; // Default to main\n    }\n  }\n}\n\n/**\n * Extract issue number from branch name\n * Supports patterns like: issue/123-description, feature/123, fix-123\n */\nexport function extractIssueNumber(branch: string): number | null {\n  // Match common patterns\n  const patterns = [\n    /issue\\/(\\d+)/i,\n    /feature\\/(\\d+)/i,\n    /fix\\/(\\d+)/i,\n    /bug\\/(\\d+)/i,\n    /feat\\/(\\d+)/i,\n    /^(\\d+)-/,\n    /-(\\d+)$/,\n    /#(\\d+)/,\n  ];\n\n  for (const pattern of patterns) {\n    const match = branch.match(pattern);\n    if (match) {\n      return parseInt(match[1], 10);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Validate branch name format\n * Returns error message if invalid, null if valid\n */\nexport function validateBranchName(branch: string): string | null {\n  // Skip validation for protected branches\n  if (isProtectedBranch(branch)) {\n    return null;\n  }\n\n  // Valid prefixes\n  const validPrefixes = [\n    'issue/',\n    'feature/',\n    'fix/',\n    'bug/',\n    'feat/',\n    'chore/',\n    'docs/',\n    'refactor/',\n    'test/',\n    'ci/',\n    'perf/',\n    'style/',\n    'release/',\n    'hotfix/',\n  ];\n\n  const hasValidPrefix = validPrefixes.some((prefix) => branch.startsWith(prefix));\n  if (!hasValidPrefix) {\n    return `Branch name should start with a valid prefix: ${validPrefixes.join(', ')}`;\n  }\n\n  // Check for issue number in issue/ branches\n  if (branch.startsWith('issue/') && !extractIssueNumber(branch)) {\n    return 'issue/ branches should include an issue number (e.g., issue/123-description)';\n  }\n\n  return null;\n}\n", "/**\n * Audit Logger - Logs all tool executions for audit trail\n * Hook: PostToolUse (*)\n * CC 2.1.7 Compliant\n */\n\nimport { appendFileSync, existsSync, mkdirSync, statSync, renameSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir, getField } from '../lib/common.js';\n\n// Track read count across invocations (per-session in memory)\nconst readCountFile = '/tmp/claude-read-count';\n\n/**\n * Log tool execution to audit file\n */\nexport function auditLogger(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Skip logging for high-frequency read operations to reduce noise\n  if (['Read', 'Glob', 'Grep'].includes(toolName)) {\n    try {\n      const { readFileSync, writeFileSync } = require('node:fs');\n      let readCount = 0;\n      try {\n        readCount = parseInt(readFileSync(readCountFile, 'utf8').trim(), 10) || 0;\n      } catch {\n        // File doesn't exist yet\n      }\n      readCount++;\n      writeFileSync(readCountFile, String(readCount));\n\n      if (readCount % 10 !== 0) {\n        return outputSilentSuccess();\n      }\n    } catch {\n      // Ignore count tracking errors\n    }\n  }\n\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || '.';\n  const auditLog = `${projectDir}/.claude/logs/audit.log`;\n\n  try {\n    // Ensure log directory exists\n    const logDir = `${projectDir}/.claude/logs`;\n    if (!existsSync(logDir)) {\n      mkdirSync(logDir, { recursive: true });\n    }\n\n    // Rotate if needed (200KB limit)\n    rotateLogFile(auditLog, 200 * 1024);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n\n    // Get relevant details based on tool type\n    let details = '';\n    switch (toolName) {\n      case 'Bash': {\n        const cmd = getField<string>(input, 'tool_input.command') || '';\n        details = cmd.substring(0, 100);\n        break;\n      }\n      case 'Write':\n      case 'Edit': {\n        details = getField<string>(input, 'tool_input.file_path') || '';\n        break;\n      }\n      case 'Task': {\n        details = getField<string>(input, 'tool_input.subagent_type') || '';\n        break;\n      }\n    }\n\n    const logEntry = details\n      ? `[${timestamp}] ${toolName} | ${details}\\n`\n      : `[${timestamp}] ${toolName}\\n`;\n\n    appendFileSync(auditLog, logEntry);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxBytes: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxBytes) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n", "/**\n * Auto-Lint Hook - PostToolUse hook for Write/Edit\n * CC 2.1.7 Compliant\n *\n * Automatically runs linters after file writes:\n * - Python: ruff check + format (Astral toolchain)\n * - JS/TS: biome check (Rust-based)\n * - JSON/CSS: biome format\n */\n\nimport { existsSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, logHook } from '../lib/common.js';\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py':\n      return 'python';\n    case 'ts':\n    case 'tsx':\n      return 'typescript';\n    case 'js':\n    case 'jsx':\n      return 'javascript';\n    case 'json':\n      return 'json';\n    case 'css':\n    case 'scss':\n      return 'css';\n    default:\n      return null;\n  }\n}\n\n/**\n * Check if a command exists\n */\nfunction commandExists(cmd: string): boolean {\n  try {\n    execSync(`which ${cmd}`, { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Run auto-lint on written files\n */\nexport function autoLint(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Check if file exists\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || '.';\n  const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n  if (!existsSync(fullPath)) {\n    return outputSilentSuccess();\n  }\n\n  // Skip if SKIP_AUTO_LINT is set\n  if (process.env.SKIP_AUTO_LINT === '1') {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  let lintIssues = 0;\n  let fixesApplied = false;\n\n  try {\n    switch (language) {\n      case 'python':\n        if (commandExists('ruff')) {\n          try {\n            const ruffCheck = execSync(`timeout 5s ruff check --output-format=concise \"${fullPath}\" 2>&1`, {\n              encoding: 'utf8',\n              stdio: ['pipe', 'pipe', 'pipe'],\n            });\n            if (ruffCheck) {\n              lintIssues = ruffCheck.split('\\n').filter(Boolean).length;\n              execSync(`timeout 5s ruff check --fix --unsafe-fixes=false \"${fullPath}\" 2>/dev/null`, {\n                stdio: 'ignore',\n              });\n              fixesApplied = true;\n            }\n          } catch {\n            // ruff check returns non-zero when issues found\n          }\n          try {\n            execSync(`timeout 5s ruff format \"${fullPath}\" 2>/dev/null`, { stdio: 'ignore' });\n          } catch {\n            // Ignore format errors\n          }\n        }\n        break;\n\n      case 'typescript':\n      case 'javascript':\n        if (commandExists('biome')) {\n          try {\n            const biomeOut = execSync(`timeout 5s biome check --write \"${fullPath}\" 2>&1`, {\n              encoding: 'utf8',\n              stdio: ['pipe', 'pipe', 'pipe'],\n            });\n            if (biomeOut.includes('Fixed')) {\n              fixesApplied = true;\n            }\n            if (biomeOut.includes('error')) {\n              lintIssues = (biomeOut.match(/error/g) || []).length;\n            }\n          } catch {\n            // Ignore biome errors\n          }\n        }\n        break;\n\n      case 'json':\n      case 'css':\n        if (commandExists('biome')) {\n          try {\n            execSync(`timeout 5s biome format --write \"${fullPath}\" 2>/dev/null`, {\n              stdio: 'ignore',\n            });\n            fixesApplied = true;\n          } catch {\n            // Ignore format errors\n          }\n        }\n        break;\n    }\n  } catch (error) {\n    logHook('auto-lint', `Error: ${error}`);\n  }\n\n  // Build output message\n  if (fixesApplied && lintIssues > 0) {\n    const basename = filePath.split('/').pop();\n    return {\n      continue: true,\n      systemMessage: `Auto-lint: fixed issues, ${lintIssues} remaining in ${basename}`,\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Context Budget Monitor - After Tool Use Hook\n * Monitors context usage and triggers compression when threshold exceeded\n *\n * Triggers compression at 70% budget utilization\n * Target after compression: 50%\n *\n * Version: 2.0.0\n * Part of Context Engineering 2.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, statSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getSessionId, logHook } from '../lib/common.js';\n\n// Configuration\nconst BUDGET_TOTAL = 2200; // Total token budget for context layer\nconst COMPRESS_TRIGGER = 0.70; // Trigger compression at 70%\nconst COMPRESS_TARGET = 0.50; // Target 50% after compression\nconst MCP_DEFER_TRIGGER = 0.10; // Defer MCP tools when context >10% of effective window\n\n/**\n * Estimate tokens from file content (~4 chars per token)\n */\nfunction estimateTokens(filePath: string): number {\n  if (!existsSync(filePath)) return 0;\n\n  try {\n    const stats = statSync(filePath);\n    return Math.floor(stats.size / 4);\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Calculate total loaded context\n */\nfunction calculateUsage(): number {\n  const projectDir = getProjectDir();\n  const contextDir = `${projectDir}/context`;\n\n  const alwaysLoadedFiles = [\n    `${contextDir}/identity.json`,\n    `${contextDir}/session/state.json`,\n    `${contextDir}/knowledge/index.json`,\n    `${contextDir}/knowledge/blockers/current.json`,\n  ];\n\n  let total = 0;\n  for (const file of alwaysLoadedFiles) {\n    total += estimateTokens(file);\n  }\n\n  return total;\n}\n\n/**\n * Get effective context window (actual usable vs static max)\n */\nfunction getEffectiveContextWindow(): number {\n  const baseWindow = parseInt(process.env.CLAUDE_MAX_CONTEXT || '200000', 10);\n  const overheadPercent = 20; // ~20% system overhead\n  return Math.floor(baseWindow * (100 - overheadPercent) / 100);\n}\n\n/**\n * Check if MCP tools should be deferred\n */\nfunction shouldDeferMcp(currentTokens: number): boolean {\n  const effectiveWindow = getEffectiveContextWindow();\n  if (effectiveWindow === 0) return true;\n\n  const usageRatio = currentTokens / effectiveWindow;\n  return usageRatio > MCP_DEFER_TRIGGER;\n}\n\n/**\n * Update MCP deferral state file\n */\nfunction updateMcpDeferState(shouldDefer: boolean, currentTokens: number): void {\n  const sessionId = getSessionId();\n  const stateFile = `/tmp/claude-mcp-defer-state-${sessionId}.json`;\n  const effectiveWindow = getEffectiveContextWindow();\n\n  const state = {\n    mcp_deferred: shouldDefer,\n    context_tokens: currentTokens,\n    effective_window: effectiveWindow,\n    updated_at: new Date().toISOString(),\n    reason: shouldDefer ? 'context > 10% threshold' : 'context within limits',\n  };\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch {\n    // Ignore write errors\n  }\n\n  logHook('context-budget-monitor',\n    `MCP defer state updated: defer=${shouldDefer}, tokens=${currentTokens}, window=${effectiveWindow}`);\n}\n\n/**\n * Compress session state\n */\nfunction compressSession(): void {\n  const projectDir = getProjectDir();\n  const sessionFile = `${projectDir}/context/session/state.json`;\n\n  if (!existsSync(sessionFile)) return;\n\n  try {\n    const content = JSON.parse(readFileSync(sessionFile, 'utf8'));\n\n    const compressed = {\n      session_id: content.session_id,\n      started: content.started,\n      current_task: content.current_task,\n      next_steps: (content.next_steps || []).slice(-3),\n      blockers: content.blockers,\n      _compressed: true,\n      _compressed_at: new Date().toISOString(),\n      _original_files_touched: (content.files_touched || []).length,\n      _original_decisions: (content.decisions_this_session || []).length,\n    };\n\n    writeFileSync(sessionFile, JSON.stringify(compressed, null, 2));\n    logHook('context-budget-monitor', 'Session state compressed');\n  } catch {\n    // Ignore compression errors\n  }\n}\n\n/**\n * Archive old decisions\n */\nfunction archiveOldDecisions(): void {\n  const projectDir = getProjectDir();\n  const decisionsFile = `${projectDir}/context/knowledge/decisions/active.json`;\n\n  if (!existsSync(decisionsFile)) return;\n\n  try {\n    const content = JSON.parse(readFileSync(decisionsFile, 'utf8'));\n    const decisions = content.decisions || [];\n\n    if (decisions.length > 10) {\n      logHook('context-budget-monitor', 'Archiving old decisions (keeping latest 5)...');\n\n      // Create archive directory\n      const archiveDir = `${projectDir}/context/archive/decisions`;\n      mkdirSync(archiveDir, { recursive: true });\n\n      // Archive older decisions\n      const date = new Date();\n      const archiveFile = `${archiveDir}/${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}.json`;\n      writeFileSync(archiveFile, JSON.stringify(decisions.slice(0, -5), null, 2));\n\n      // Keep only latest 5\n      content.decisions = decisions.slice(-5);\n      writeFileSync(decisionsFile, JSON.stringify(content, null, 2));\n\n      logHook('context-budget-monitor', `Archived ${decisions.length - 5} decisions to ${archiveFile}`);\n    }\n  } catch {\n    // Ignore archive errors\n  }\n}\n\n/**\n * Monitor context budget and trigger compression if needed\n */\nexport function contextBudgetMonitor(_input: HookInput): HookResult {\n  try {\n    const currentTokens = calculateUsage();\n\n    // Guard against division by zero\n    const usageRatio = currentTokens / BUDGET_TOTAL;\n    const usagePercent = Math.floor(usageRatio * 100);\n\n    logHook('context-budget-monitor',\n      `Context usage: ${currentTokens} / ${BUDGET_TOTAL} tokens (${usagePercent}%)`);\n\n    // CC 2.1.7: Check and update MCP deferral state\n    const deferMcp = shouldDeferMcp(currentTokens);\n    updateMcpDeferState(deferMcp, currentTokens);\n\n    // Check if compression needed\n    if (usageRatio > COMPRESS_TRIGGER) {\n      logHook('context-budget-monitor',\n        `WARNING: Context usage (${usagePercent}%) exceeds threshold (${COMPRESS_TRIGGER * 100}%)`);\n      logHook('context-budget-monitor', 'Triggering compression...');\n\n      // Compress session state\n      compressSession();\n\n      // Archive old decisions\n      archiveOldDecisions();\n\n      // Recalculate\n      const newTokens = calculateUsage();\n      const newRatio = newTokens / BUDGET_TOTAL;\n      const newPercent = Math.floor(newRatio * 100);\n\n      logHook('context-budget-monitor',\n        `After compression: ${newTokens} / ${BUDGET_TOTAL} tokens (${newPercent}%)`);\n\n      if (newRatio > COMPRESS_TARGET) {\n        logHook('context-budget-monitor',\n          'WARNING: Still above target. Manual review recommended.');\n      } else {\n        logHook('context-budget-monitor', 'Compression successful. Target achieved.');\n      }\n    } else {\n      logHook('context-budget-monitor', 'Context usage within budget. No compression needed.');\n    }\n  } catch (error) {\n    logHook('context-budget-monitor', `Error: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Coordination Heartbeat - Update heartbeat after each tool use\n * Hook: PostToolUse (*)\n * CC 2.1.6 Compliant: ensures JSON output on all code paths\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, logHook } from '../lib/common.js';\n\n/**\n * Update coordination heartbeat\n */\nexport function coordinationHeartbeat(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const coordLib = `${projectDir}/.claude/coordination/lib/coordination.sh`;\n\n  // Check if coordination lib exists\n  if (!existsSync(coordLib)) {\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Load instance ID if available\n    // CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability,\n    // but we add a defensive fallback to prevent crashes.\n    const instanceEnv = `${projectDir}/.claude/.instance_env`;\n    let instanceId = process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}`;\n\n    if (existsSync(instanceEnv)) {\n      const content = readFileSync(instanceEnv, 'utf8');\n      const match = content.match(/CLAUDE_INSTANCE_ID=[\"']?([^\"'\\n]+)/);\n      if (match) {\n        instanceId = match[1];\n      }\n    }\n\n    // Update heartbeat (lightweight operation)\n    if (instanceId) {\n      execSync(\n        `source \"${coordLib}\" && INSTANCE_ID=\"${instanceId}\" coord_heartbeat 2>/dev/null || true`,\n        {\n          shell: '/bin/bash',\n          stdio: 'ignore',\n          timeout: 5000,\n        }\n      );\n    }\n  } catch (error) {\n    // Coordination update failed, but don't block execution\n    logHook('coordination-heartbeat', `Heartbeat update failed: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Error Collector - Captures all tool errors for pattern analysis\n * Hook: PostToolUse (*)\n *\n * Purpose: Build a database of errors to detect bad practices\n * Analysis: Run .claude/scripts/analyze_errors.py nightly (cron)\n * Cost: $0 - No LLM, just logging\n */\n\nimport { existsSync, appendFileSync, readFileSync, writeFileSync, mkdirSync, statSync, renameSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getSessionId, getField, logHook } from '../lib/common.js';\n\n// Error pattern detection regex\nconst ERROR_PATTERNS = /error:|Error:|ERROR|FATAL|exception|failed|denied|not found|does not exist|connection refused|timeout|ENOENT|EACCES|EPERM/i;\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxBytes: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxBytes) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Collect and log errors from tool execution\n */\nexport function errorCollector(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n  const sessionId = getSessionId();\n  const timestamp = new Date().toISOString();\n\n  // Get tool execution details\n  const toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n  const exitCode = input.exit_code ?? 0;\n  const toolError = String(input.tool_error || getField<string>(input, 'error') || '');\n\n  // Detect errors by multiple signals\n  let isError = false;\n  let errorType = '';\n  let errorMessage = '';\n\n  // Signal 1: Explicit exit code\n  if (exitCode !== 0 && exitCode !== undefined) {\n    isError = true;\n    errorType = 'exit_code';\n    errorMessage = `Exit code: ${exitCode}`;\n  }\n\n  // Signal 2: Error field present\n  if (toolError) {\n    isError = true;\n    errorType = 'tool_error';\n    errorMessage = toolError;\n  }\n\n  // Signal 3: Error patterns in output\n  if (ERROR_PATTERNS.test(toolOutput)) {\n    isError = true;\n    errorType = errorType || 'output_pattern';\n    // Extract the error line\n    const errorLines = toolOutput.split('\\n').filter(line => ERROR_PATTERNS.test(line));\n    errorMessage = errorMessage || errorLines[0] || '';\n  }\n\n  // Only log if there was an error\n  if (isError) {\n    const projectDir = getProjectDir();\n    const errorLog = `${projectDir}/.claude/logs/errors.jsonl`;\n\n    try {\n      mkdirSync(`${projectDir}/.claude/logs`, { recursive: true });\n\n      // Rotate if > 1MB\n      rotateLogFile(errorLog, 1000 * 1024);\n\n      // Get tool input for context\n      const toolInput = input.tool_input || {};\n      const inputHash = createHash('md5').update(JSON.stringify(toolInput)).digest('hex');\n\n      // Truncate long values for storage efficiency\n      const errorMessageTruncated = errorMessage.substring(0, 500);\n      const toolOutputTruncated = toolOutput.substring(0, 1000);\n\n      // Write structured error record (JSONL format)\n      const errorRecord = {\n        timestamp,\n        tool: toolName,\n        session_id: sessionId,\n        error_type: errorType,\n        error_message: errorMessageTruncated,\n        input_hash: inputHash,\n        tool_input: toolInput,\n        output_preview: toolOutputTruncated,\n      };\n\n      appendFileSync(errorLog, JSON.stringify(errorRecord) + '\\n');\n\n      // Also track in session metrics for quick access\n      const metricsFile = '/tmp/claude-session-errors.json';\n      try {\n        let metrics = { error_count: 0, last_error_tool: '', last_error_time: '' };\n        if (existsSync(metricsFile)) {\n          metrics = JSON.parse(readFileSync(metricsFile, 'utf8'));\n        }\n        metrics.error_count = (metrics.error_count || 0) + 1;\n        metrics.last_error_tool = toolName;\n        metrics.last_error_time = timestamp;\n        writeFileSync(metricsFile, JSON.stringify(metrics, null, 2));\n      } catch {\n        // Ignore metrics update errors\n      }\n\n      logHook('error-collector', `ERROR captured: ${toolName} - ${errorType} - ${errorMessage.substring(0, 100)}`);\n    } catch {\n      // Fallback logging\n      logHook('error-collector', `ERROR (fallback): ${toolName} - ${errorType}`);\n    }\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Error Solution Suggester - PostToolUse hook for error remediation\n * Issue #124: Suggests fixes and skills when Bash errors occur\n *\n * This hook analyzes error output from Bash commands and injects contextual\n * solution suggestions via CC 2.1.9 additionalContext.\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext for suggestions\n * Version: 1.0.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getPluginRoot, getSessionId, logHook } from '../lib/common.js';\nimport { createHash } from 'node:crypto';\n\n// Configuration\nconst MAX_CONTEXT_CHARS = 2000;\nconst DEDUP_PROMPT_THRESHOLD = 10;\nconst MAX_SKILLS = 3;\n\ninterface ErrorPattern {\n  id: string;\n  regex: string;\n  category?: string;\n  severity?: string;\n  skills?: string[];\n  solution?: {\n    brief?: string;\n    steps?: string[];\n  };\n}\n\ninterface SolutionsFile {\n  patterns: ErrorPattern[];\n  categories?: Record<string, { related_skills?: string[] }>;\n}\n\ninterface DedupFile {\n  suggestions: Record<string, { pattern_id: string; prompt_count: number }>;\n  prompt_count: number;\n}\n\n/**\n * Check if this was an error output\n */\nfunction isErrorOutput(input: HookInput): boolean {\n  const exitCode = input.exit_code;\n  const toolError = input.tool_error || getField<string>(input, 'error') || '';\n  const toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n\n  // Check exit code\n  if (exitCode !== undefined && exitCode !== null && exitCode !== 0) {\n    return true;\n  }\n\n  // Check tool_error field\n  if (toolError) {\n    return true;\n  }\n\n  // Check output for error patterns\n  const errorPattern = /error:|ERROR|FATAL|exception|failed|denied|not found|does not exist|connection refused|ENOENT|EACCES|EPERM/i;\n  if (errorPattern.test(toolOutput)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Match error text against patterns in solutions file\n */\nfunction matchErrorPattern(errorText: string, solutionsFile: string): ErrorPattern | null {\n  if (!existsSync(solutionsFile)) {\n    logHook('error-solution-suggester', `Solutions file not found: ${solutionsFile}`);\n    return null;\n  }\n\n  try {\n    const content: SolutionsFile = JSON.parse(readFileSync(solutionsFile, 'utf8'));\n    const errorLower = errorText.toLowerCase();\n\n    for (const pattern of content.patterns || []) {\n      if (pattern.regex) {\n        try {\n          const regex = new RegExp(pattern.regex, 'i');\n          if (regex.test(errorLower)) {\n            return pattern;\n          }\n        } catch {\n          // Invalid regex, skip\n        }\n      }\n    }\n  } catch {\n    // Parse error\n  }\n\n  return null;\n}\n\n/**\n * Check if we should suggest for this pattern (deduplication)\n */\nfunction shouldSuggest(patternId: string, errorContext: string, dedupFile: string): boolean {\n  // Initialize dedup file if needed\n  if (!existsSync(dedupFile)) {\n    try {\n      mkdirSync(require('path').dirname(dedupFile), { recursive: true });\n      writeFileSync(dedupFile, JSON.stringify({ suggestions: {}, prompt_count: 0 }));\n    } catch {\n      return true; // Allow if we can't track\n    }\n  }\n\n  try {\n    const dedup: DedupFile = JSON.parse(readFileSync(dedupFile, 'utf8'));\n\n    // Create hash of pattern ID + first 100 chars of error\n    const suggestionHash = createHash('md5')\n      .update(`${patternId}|${errorContext.substring(0, 100)}`)\n      .digest('hex');\n\n    // Increment prompt count\n    const currentCount = (dedup.prompt_count || 0) + 1;\n    dedup.prompt_count = currentCount;\n\n    // Get last suggested prompt count for this hash\n    const lastSuggestedAt = dedup.suggestions[suggestionHash]?.prompt_count || 0;\n\n    // Allow if never suggested or more than threshold prompts ago\n    if (lastSuggestedAt === 0 || (currentCount - lastSuggestedAt) >= DEDUP_PROMPT_THRESHOLD) {\n      // Record this suggestion\n      dedup.suggestions[suggestionHash] = { pattern_id: patternId, prompt_count: currentCount };\n      writeFileSync(dedupFile, JSON.stringify(dedup, null, 2));\n      return true;\n    }\n\n    writeFileSync(dedupFile, JSON.stringify(dedup, null, 2));\n    return false;\n  } catch {\n    return true; // Allow if we can't track\n  }\n}\n\n/**\n * Get skill description from SKILL.md frontmatter\n */\nfunction getSkillDescription(skillName: string, skillsDir: string): string {\n  const skillFile = `${skillsDir}/${skillName}/SKILL.md`;\n\n  if (!existsSync(skillFile)) return '';\n\n  try {\n    const content = readFileSync(skillFile, 'utf8');\n    // Extract description from YAML frontmatter\n    const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (frontmatterMatch) {\n      const descMatch = frontmatterMatch[1].match(/description:\\s*(.+)/);\n      if (descMatch) {\n        return descMatch[1].trim();\n      }\n    }\n  } catch {\n    // Ignore read errors\n  }\n\n  return '';\n}\n\n/**\n * Build skills section for message\n */\nfunction buildSkillsSection(pattern: ErrorPattern, solutionsFile: string, skillsDir: string): string {\n  const category = pattern.category || '';\n\n  // Get skills from pattern\n  const patternSkills = pattern.skills || [];\n\n  // Get skills from category\n  let categorySkills: string[] = [];\n  if (category && existsSync(solutionsFile)) {\n    try {\n      const content: SolutionsFile = JSON.parse(readFileSync(solutionsFile, 'utf8'));\n      categorySkills = content.categories?.[category]?.related_skills || [];\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Combine and dedupe skills\n  const allSkills = [...new Set([...patternSkills, ...categorySkills])].slice(0, MAX_SKILLS);\n\n  if (allSkills.length === 0) return '';\n\n  let section = '### Related Skills\\n\\n';\n\n  for (const skill of allSkills) {\n    const desc = getSkillDescription(skill, skillsDir);\n    if (desc) {\n      section += `- **${skill}**: ${desc}\\n`;\n    } else {\n      section += `- **${skill}**\\n`;\n    }\n  }\n\n  section += '\\nUse `/ork:<skill-name>` or `Read skills/<skill-name>/SKILL.md`';\n\n  return section;\n}\n\n/**\n * Build the suggestion message\n */\nfunction buildSuggestionMessage(pattern: ErrorPattern, solutionsFile: string, skillsDir: string): string {\n  const brief = pattern.solution?.brief || 'An error was detected.';\n  const steps = pattern.solution?.steps || [];\n\n  let msg = '## Error Solution\\n\\n';\n  msg += `**${brief}**\\n\\n`;\n\n  if (steps.length > 0) {\n    msg += '### Quick Fixes\\n\\n';\n    steps.forEach((step, i) => {\n      msg += `  ${i + 1}. ${step}\\n`;\n    });\n    msg += '\\n';\n  }\n\n  // Add skills section\n  const skillsSection = buildSkillsSection(pattern, solutionsFile, skillsDir);\n  if (skillsSection) {\n    msg += skillsSection;\n  }\n\n  // Truncate if too long\n  if (msg.length > MAX_CONTEXT_CHARS) {\n    msg = msg.substring(0, MAX_CONTEXT_CHARS - 20) + '...\\n\\n(truncated)';\n  }\n\n  return msg;\n}\n\n/**\n * Suggest solutions for errors\n */\nexport function errorSolutionSuggester(input: HookInput): HookResult {\n  // Self-guard: Only run for Bash tool\n  if (input.tool_name !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  // Self-guard: Only run if there was an error\n  if (!isErrorOutput(input)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('error-solution-suggester', 'Error detected, analyzing for solutions...');\n\n  // Get error content\n  const toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n  const toolError = String(input.tool_error || getField<string>(input, 'error') || '');\n\n  // Combine error sources (prefer explicit error, then output)\n  let errorText = toolError || toolOutput;\n  errorText = errorText.substring(0, 2000); // Truncate for matching\n\n  if (!errorText) {\n    logHook('error-solution-suggester', 'No error text found');\n    return outputSilentSuccess();\n  }\n\n  const pluginRoot = getPluginRoot();\n  const solutionsFile = `${pluginRoot}/.claude/rules/error_solutions.json`;\n  const skillsDir = `${pluginRoot}/skills`;\n  const sessionId = getSessionId();\n  const dedupFile = `/tmp/claude-error-suggestions-${sessionId}.json`;\n\n  // Match against patterns\n  const matchedPattern = matchErrorPattern(errorText, solutionsFile);\n\n  if (!matchedPattern) {\n    logHook('error-solution-suggester', 'No matching pattern found');\n    return outputSilentSuccess();\n  }\n\n  logHook('error-solution-suggester', `Matched pattern: ${matchedPattern.id}`);\n\n  // Check deduplication\n  if (!shouldSuggest(matchedPattern.id, errorText, dedupFile)) {\n    logHook('error-solution-suggester', `Skipping duplicate suggestion for pattern: ${matchedPattern.id}`);\n    return outputSilentSuccess();\n  }\n\n  // Build suggestion message\n  const suggestionMessage = buildSuggestionMessage(matchedPattern, solutionsFile, skillsDir);\n\n  if (suggestionMessage) {\n    logHook('error-solution-suggester', 'Injecting solution suggestion via additionalContext');\n\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        additionalContext: suggestionMessage,\n      },\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Error Tracker - Tracks and logs tool errors\n * CC 2.1.7 Compliant: Self-contained hook with stdin reading and self-guard\n * Hook: PostToolUse (Bash)\n */\n\nimport { existsSync, readFileSync, writeFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getField, logHook } from '../lib/common.js';\n\n// Trivial commands that don't need tracking\nconst TRIVIAL_COMMANDS = /^(echo |ls |ls$|pwd|cat |head |tail |wc |date|whoami)/;\n\n/**\n * Track and log tool errors\n */\nexport function errorTracker(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only run for non-trivial bash commands\n  if (toolName === 'Bash') {\n    const command = getField<string>(input, 'tool_input.command') || '';\n    if (TRIVIAL_COMMANDS.test(command)) {\n      return outputSilentSuccess();\n    }\n  }\n\n  const toolError = String(input.tool_error || '');\n  const exitCode = input.exit_code;\n\n  // Check if there was an error\n  if (!toolError && (exitCode === 0 || exitCode === undefined || exitCode === null)) {\n    return outputSilentSuccess();\n  }\n\n  logHook('error-tracker', `ERROR: ${toolName} failed (exit: ${exitCode})`);\n\n  // Track error count\n  const metricsFile = '/tmp/claude-session-metrics.json';\n  try {\n    let metrics = { tools: {}, errors: 0, warnings: 0 };\n    if (existsSync(metricsFile)) {\n      const content = readFileSync(metricsFile, 'utf8').trim();\n      if (content) {\n        metrics = JSON.parse(content);\n      }\n    }\n    metrics.errors = (metrics.errors || 0) + 1;\n    writeFileSync(metricsFile, JSON.stringify(metrics, null, 2));\n  } catch {\n    // Ignore metrics update errors\n  }\n\n  // Log error details\n  const projectDir = getProjectDir();\n  const errorLog = `${projectDir}/.claude/logs/errors.log`;\n\n  try {\n    mkdirSync(`${projectDir}/.claude/logs`, { recursive: true });\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    const errorPreview = toolError.substring(0, 200);\n    appendFileSync(errorLog, `[${timestamp}] ${toolName} | exit: ${exitCode} | ${errorPreview}\\n`);\n  } catch {\n    // Ignore log errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Mem0 Webhook Handler - Process incoming webhook events\n * Hook: PostToolUse (for bash/webhook-receiver.py calls)\n * CC 2.1.7 Compliant\n *\n * Features:\n * - Processes webhook events from mem0\n * - Routes to appropriate workflows\n * - Triggers auto-sync, decision sync, cleanup\n *\n * Version: 1.0.0\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, logHook } from '../lib/common.js';\n\n/**\n * Handle incoming mem0 webhook events\n */\nexport function mem0WebhookHandler(input: HookInput): HookResult {\n  logHook('mem0-webhook-handler', 'Mem0 webhook handler starting');\n\n  const toolName = input.tool_name || '';\n  const command = getField<string>(input, 'tool_input.command') || '';\n\n  // Only process webhook-receiver.py calls\n  if (toolName !== 'Bash' || !command.includes('webhook-receiver.py')) {\n    return outputSilentSuccess();\n  }\n\n  // Extract event data from command output or tool result\n  const eventDataStr = getField<string>(input, 'tool_result') || '';\n\n  if (!eventDataStr) {\n    logHook('mem0-webhook-handler', 'No event data found in webhook call');\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Parse event data\n    let eventData: Record<string, unknown>;\n    try {\n      eventData = JSON.parse(eventDataStr);\n    } catch {\n      logHook('mem0-webhook-handler', 'Could not parse event data');\n      return outputSilentSuccess();\n    }\n\n    // Parse event type\n    const eventType = (eventData.result as Record<string, unknown>)?.event_type ||\n                     eventData.event_type || '';\n    const memoryId = (eventData.result as Record<string, unknown>)?.memory_id ||\n                    (eventData.memory as Record<string, unknown>)?.id || '';\n\n    logHook('mem0-webhook-handler', `Processing webhook event: ${eventType} (memory: ${memoryId})`);\n\n    // Route to appropriate handler based on event type\n    switch (eventType) {\n      case 'memory.created':\n        logHook('mem0-webhook-handler', 'Memory created - trigger graph sync');\n        // Trigger sync to knowledge graph\n        // This would call memory-bridge.sh or similar\n        break;\n\n      case 'memory.updated':\n        logHook('mem0-webhook-handler', 'Memory updated - trigger decision sync');\n        // Trigger decision sync\n        break;\n\n      case 'memory.deleted':\n        logHook('mem0-webhook-handler', 'Memory deleted - cleanup graph entities');\n        // Cleanup related graph entities\n        break;\n\n      default:\n        logHook('mem0-webhook-handler', `Unknown event type: ${eventType}`);\n        break;\n    }\n  } catch (error) {\n    logHook('mem0-webhook-handler', `Error processing webhook: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Memory Bridge Hook - Graph-First Memory Sync\n * Triggers on PostToolUse for mcp__mem0__add_memory\n *\n * Graph-First Architecture (v2.1):\n * - Graph is AUTHORITATIVE - always the source of truth\n * - When mem0 is used, ALWAYS sync TO graph (preserve in local storage)\n * - When graph is used (default), NO sync needed (already in primary)\n *\n * Sync Direction: Mem0 -> Graph ONLY (one-way)\n * - mcp__mem0__add_memory -> Extract entities, sync to graph\n * - mcp__memory__create_entities -> No action needed (already in primary)\n *\n * Version: 2.1.1 - CC 2.1.9/2.1.11 compliant, Graph-First Architecture\n * Part of Memory Fabric v2.1 - Graph-First Architecture\n */\n\nimport { existsSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getPluginRoot, logHook } from '../lib/common.js';\n\n// Entity type mapping patterns\nconst ENTITY_PATTERNS: Record<string, RegExp> = {\n  Technology: /fastapi|react|typescript|python|postgres|redis|docker|kubernetes|langchain|langgraph|pgvector|qdrant|openai|anthropic|celery|rabbitmq|kafka|nginx|vite|tailwind|prisma|sqlalchemy|alembic|pydantic|zod/i,\n  Pattern: /singleton|factory|repository|service|controller|adapter|facade|strategy|observer|decorator|middleware|dependency.injection|cursor.pagination|rate.limiting|circuit.breaker/i,\n  Decision: /decided|chose|selected|will.use|adopted|standardized|migrated/i,\n  Architecture: /microservice|monolith|event.driven|cqrs|event.sourcing|hexagonal|clean.architecture|ddd|api.gateway|load.balancer/i,\n  Database: /postgresql|mysql|mongodb|sqlite|dynamodb|cassandra|schema|migration|index|query/i,\n  Security: /jwt|oauth|cors|csrf|xss|sql.injection|rate.limit|encryption|authentication|authorization/i,\n};\n\ninterface Entity {\n  name: string;\n  entityType: string;\n  observations: string[];\n}\n\ninterface Relation {\n  from: string;\n  to: string;\n  relationType: string;\n}\n\n/**\n * Extract entities from text (Mem0 -> Graph)\n */\nfunction extractEntitiesFromText(text: string): Entity[] {\n  const textLower = text.toLowerCase();\n  const entities: Entity[] = [];\n\n  for (const [entityType, pattern] of Object.entries(ENTITY_PATTERNS)) {\n    const matches = textLower.match(pattern);\n    if (matches) {\n      for (const match of [...new Set(matches)].slice(0, 5)) {\n        // Capitalize first letter for entity name\n        const entityName = match\n          .split(/[\\s-_]+/)\n          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n          .join('-');\n\n        // Build observation from surrounding context\n        let observation = 'Used in project context';\n        if (/decided.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Decided to use for project';\n        } else if (/chose.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Chosen for implementation';\n        } else if (/will.use.*/.test(textLower) && textLower.includes(match)) {\n          observation = 'Will be used in project';\n        }\n\n        entities.push({\n          name: entityName,\n          entityType,\n          observations: [observation],\n        });\n      }\n    }\n  }\n\n  return entities;\n}\n\n/**\n * Extract relations from text\n */\nfunction extractRelationsFromText(text: string, entities: Entity[]): Relation[] {\n  const textLower = text.toLowerCase();\n  const relations: Relation[] = [];\n  const entityNames = entities.map(e => e.name);\n\n  for (const entity1 of entityNames) {\n    const entity1Lower = entity1.toLowerCase().replace(/-/g, '.');\n\n    for (const entity2 of entityNames) {\n      if (entity1 === entity2) continue;\n\n      const entity2Lower = entity2.toLowerCase().replace(/-/g, '.');\n      const relationPattern = new RegExp(\n        `${entity1Lower}.*(with|using|and|integrated|connected|for).*${entity2Lower}`,\n        'i'\n      );\n\n      if (relationPattern.test(textLower)) {\n        relations.push({\n          from: entity1,\n          to: entity2,\n          relationType: 'uses',\n        });\n      }\n    }\n  }\n\n  return relations;\n}\n\n/**\n * Sync memory from Mem0 to knowledge graph\n */\nexport function memoryBridge(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process memory-related tools\n  switch (toolName) {\n    case 'mcp__mem0__add_memory': {\n      // Graph-First: Sync mem0 content TO graph (preserve in primary storage)\n      logHook('memory-bridge', 'Processing mcp__mem0__add_memory - syncing to graph (primary)');\n\n      // Get the text that was added\n      const memoryText = getField<string>(input, 'tool_input.text') || '';\n\n      if (!memoryText || memoryText.length < 20) {\n        logHook('memory-bridge', 'Memory text too short, skipping');\n        return outputSilentSuccess();\n      }\n\n      // Check for Memory Fabric Agent\n      const pluginRoot = getPluginRoot();\n      const memoryAgent = `${pluginRoot}/bin/memory-fabric-agent.py`;\n      const hasAgentSdk = existsSync(memoryAgent);\n\n      if (hasAgentSdk) {\n        logHook('memory-bridge', 'Memory Fabric Agent available for bidirectional sync');\n        // Agent SDK would be invoked here for smart entity extraction\n        // For now, fall through to regex extraction\n      }\n\n      // Fallback: Use regex-based extraction\n      const entities = extractEntitiesFromText(memoryText);\n      const entityCount = entities.length;\n\n      if (entityCount === 0) {\n        logHook('memory-bridge', 'No entities extracted');\n        return outputSilentSuccess();\n      }\n\n      // Extract relations\n      const relations = extractRelationsFromText(memoryText, entities);\n      const relationCount = relations.length;\n\n      logHook('memory-bridge', `Extracted ${entityCount} entities and ${relationCount} relations`);\n\n      // Format suggestion message\n      const entityList = entities\n        .slice(0, 5)\n        .map(e => `- ${e.name} (${e.entityType}): ${e.observations[0] || 'observed'}`)\n        .join('\\n');\n\n      let msg = `[Memory Bridge] Sync to Graph (primary storage)\n\nMem0 content should be synced to the knowledge graph for durability.\nDetected ${entityCount} entities to preserve:\n\n${entityList}\n\nStore in graph with mcp__memory__create_entities:\n\\`\\`\\`json\n{\"entities\": ${JSON.stringify(entities)}}\n\\`\\`\\``;\n\n      if (relationCount > 0) {\n        msg += `\n\nThen call mcp__memory__create_relations with:\n\\`\\`\\`json\n{\"relations\": ${JSON.stringify(relations)}}\n\\`\\`\\``;\n      }\n\n      return {\n        continue: true,\n        systemMessage: msg,\n      };\n    }\n\n    case 'mcp__memory__create_entities':\n      // Graph-First: No sync needed when writing to graph (it's already the primary)\n      logHook('memory-bridge', 'mcp__memory__create_entities - graph is primary, no sync needed');\n      return outputSilentSuccess();\n\n    default:\n      // Not a memory tool, skip\n      return outputSilentSuccess();\n  }\n}\n", "/**\n * Realtime Sync Hook - Graph-First Priority-based immediate memory persistence\n * Triggers on PostToolUse for Bash, Write, and Skill completions\n *\n * Purpose: Sync critical decisions immediately to knowledge graph\n *\n * Graph-First Architecture (v2.1):\n * - IMMEDIATE syncs target knowledge graph (mcp__memory__*) - always works\n * - mem0 cloud sync only if API key present AND critical priority\n *\n * Priority Classification:\n * - IMMEDIATE: \"decided\", \"chose\", \"architecture\", \"security\", \"blocked\", \"breaking\"\n * - BATCHED: \"pattern\", \"convention\", \"preference\"\n * - SESSION_END: Everything else (handled by existing Stop hooks)\n *\n * Version: 2.1.0 - CC 2.1.9/2.1.11 compliant, Graph-First Architecture\n * Part of Memory Fabric v2.1 - Graph-First Architecture\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../lib/common.js';\n\n// Priority keywords\nconst IMMEDIATE_KEYWORDS = /decided|chose|architecture|security|blocked|breaking|critical|must|cannot|deprecated|removed|migration/i;\nconst BATCHED_KEYWORDS = /pattern|convention|preference|style|format|naming/i;\n\n// Minimum content length to consider\nconst MIN_CONTENT_LENGTH = 30;\n\n// Context pressure thresholds\nconst CONTEXT_EMERGENCY_THRESHOLD = 85;\nconst CONTEXT_CRITICAL_THRESHOLD = 90;\n\ninterface PendingItem {\n  content: string;\n  category: string;\n  queued_at: string;\n}\n\ninterface PendingFile {\n  pending: PendingItem[];\n  created_at: string;\n}\n\n/**\n * Get current context usage percentage\n */\nfunction getContextPressure(): number {\n  const pressure = parseInt(process.env.CLAUDE_CONTEXT_USED_PERCENTAGE || '0', 10);\n\n  if (pressure === 0) {\n    const tokensUsed = parseInt(process.env.CLAUDE_CONTEXT_TOKENS_USED || '0', 10);\n    const maxTokens = parseInt(process.env.CLAUDE_CONTEXT_MAX_TOKENS || '0', 10);\n    if (maxTokens > 0) {\n      return Math.floor((tokensUsed * 100) / maxTokens);\n    }\n  }\n\n  return pressure;\n}\n\n/**\n * Classify priority of content\n */\nfunction classifyPriority(content: string): 'IMMEDIATE' | 'BATCHED' | 'SESSION_END' {\n  if (IMMEDIATE_KEYWORDS.test(content)) {\n    return 'IMMEDIATE';\n  }\n  if (BATCHED_KEYWORDS.test(content)) {\n    return 'BATCHED';\n  }\n  return 'SESSION_END';\n}\n\n/**\n * Extract the decision/insight from content\n */\nfunction extractDecision(content: string): string {\n  // Try to extract a meaningful decision statement\n  const patterns = [\n    /[^.]*\\b(decided|chose|selected|will use|must|cannot|blocked|breaking)[^.]*/i,\n    /[^.]*\\b(architecture|security|migration|deprecated)[^.]*/i,\n  ];\n\n  for (const pattern of patterns) {\n    const match = content.match(pattern);\n    if (match) {\n      return match[0].trim().substring(0, 300);\n    }\n  }\n\n  // Final fallback: take first meaningful sentence\n  const sentences = content.match(/^[^.]{30,200}\\./);\n  if (sentences) {\n    return sentences[0].trim();\n  }\n\n  return content.substring(0, 300).trim();\n}\n\n/**\n * Detect category from content\n */\nfunction detectCategory(content: string): string {\n  const contentLower = content.toLowerCase();\n\n  if (/security|auth|jwt|oauth|cors|xss/.test(contentLower)) return 'security';\n  if (/architecture|design|structure|system/.test(contentLower)) return 'architecture';\n  if (/database|schema|migration|postgres|sql/.test(contentLower)) return 'database';\n  if (/blocked|issue|bug|problem|cannot/.test(contentLower)) return 'blocker';\n  if (/breaking|deprecated|removed|migration/.test(contentLower)) return 'breaking-change';\n  if (/api|endpoint|route|rest/.test(contentLower)) return 'api';\n  if (/decided|chose|selected/.test(contentLower)) return 'decision';\n\n  return 'general';\n}\n\n/**\n * Initialize pending sync queue\n */\nfunction initPendingQueue(pendingFile: string): void {\n  if (!existsSync(pendingFile)) {\n    try {\n      mkdirSync(require('path').dirname(pendingFile), { recursive: true });\n      writeFileSync(pendingFile, JSON.stringify({\n        pending: [],\n        created_at: new Date().toISOString(),\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Add to pending queue\n */\nfunction addToPendingQueue(content: string, category: string, pendingFile: string): void {\n  initPendingQueue(pendingFile);\n\n  try {\n    const data: PendingFile = JSON.parse(readFileSync(pendingFile, 'utf8'));\n    data.pending.push({\n      content,\n      category,\n      queued_at: new Date().toISOString(),\n    });\n    writeFileSync(pendingFile, JSON.stringify(data, null, 2));\n    logHook('realtime-sync', `Added to pending queue: category=${category}, length=${content.length}`);\n  } catch {\n    // Ignore queue errors\n  }\n}\n\n/**\n * Get pending count\n */\nfunction getPendingCount(pendingFile: string): number {\n  if (!existsSync(pendingFile)) return 0;\n\n  try {\n    const data: PendingFile = JSON.parse(readFileSync(pendingFile, 'utf8'));\n    return data.pending?.length || 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Sync critical decisions in real-time\n */\nexport function realtimeSync(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only process relevant tools\n  if (!['Bash', 'Write', 'Edit', 'Skill', 'Task'].includes(toolName)) {\n    return outputSilentSuccess();\n  }\n\n  // Get tool output/result\n  let toolOutput = '';\n  switch (toolName) {\n    case 'Bash': {\n      toolOutput = String(getField<unknown>(input, 'tool_output') || input.tool_output || '');\n      const command = getField<string>(input, 'tool_input.command') || '';\n      if (command) {\n        toolOutput = `${command}\\n${toolOutput}`;\n      }\n      break;\n    }\n    case 'Write':\n    case 'Edit': {\n      const content = getField<string>(input, 'tool_input.new_string') ||\n                     getField<string>(input, 'tool_input.content') || '';\n      const filePath = getField<string>(input, 'tool_input.file_path') || '';\n      toolOutput = filePath ? `Writing to ${filePath}: ${content}` : content;\n      break;\n    }\n    case 'Skill':\n    case 'Task': {\n      toolOutput = String(getField<unknown>(input, 'tool_result') || input.tool_output || '');\n      break;\n    }\n  }\n\n  // Skip if output is too short\n  if (!toolOutput || toolOutput.length < MIN_CONTENT_LENGTH) {\n    return outputSilentSuccess();\n  }\n\n  // Classify priority\n  let priority = classifyPriority(toolOutput);\n  logHook('realtime-sync', `Tool: ${toolName}, Priority: ${priority}, Content length: ${toolOutput.length}`);\n\n  // Context pressure override\n  const contextPressure = getContextPressure();\n  const projectDir = getProjectDir();\n  const sessionId = getSessionId();\n  const pendingFile = `${projectDir}/.claude/logs/.mem0-pending-sync-${sessionId}.json`;\n\n  // Upgrade BATCHED to IMMEDIATE if context pressure is high\n  if (priority === 'BATCHED' && contextPressure >= CONTEXT_EMERGENCY_THRESHOLD) {\n    priority = 'IMMEDIATE';\n    logHook('realtime-sync', `EMERGENCY: Context at ${contextPressure}%, upgrading BATCHED to IMMEDIATE`);\n  }\n\n  // If critical (>90%), flush pending queue immediately\n  if (contextPressure >= CONTEXT_CRITICAL_THRESHOLD) {\n    const pendingCount = getPendingCount(pendingFile);\n    if (pendingCount > 0) {\n      logHook('realtime-sync', `CRITICAL: Context at ${contextPressure}%, flushing ${pendingCount} pending items`);\n\n      return {\n        continue: true,\n        systemMessage: `[CRITICAL SYNC] Context at ${contextPressure}% - compaction imminent!\n\n${pendingCount} items in pending queue need immediate sync to knowledge graph.\nPending sync file: ${pendingFile}\n\nExecute mcp__memory__create_entities for each item in the pending file NOW\nto preserve session context in the knowledge graph before compaction.`,\n      };\n    }\n  }\n\n  switch (priority) {\n    case 'IMMEDIATE': {\n      const decision = extractDecision(toolOutput);\n\n      if (!decision || decision.length < 20) {\n        logHook('realtime-sync', 'Could not extract meaningful decision');\n        return outputSilentSuccess();\n      }\n\n      const category = detectCategory(decision);\n      logHook('realtime-sync', `IMMEDIATE sync triggered: category=${category}`);\n\n      return {\n        continue: true,\n        systemMessage: `[IMMEDIATE SYNC] Critical decision detected - store in knowledge graph now.\n\nCategory: ${category}\nDecision: \"${decision.substring(0, 200)}\"\n\nStore in knowledge graph with mcp__memory__create_entities:\n\\`\\`\\`json\n{\n  \"entities\": [{\n    \"name\": \"${category}-decision\",\n    \"entityType\": \"Decision\",\n    \"observations\": [\"${decision.substring(0, 300).replace(/\"/g, '\\\\\"')}\"]\n  }]\n}\n\\`\\`\\`\n\nThis decision is critical and should be synced immediately for:\n- Session continuity if interrupted\n- Cross-agent knowledge sharing\n- Future reference in similar contexts`,\n      };\n    }\n\n    case 'BATCHED': {\n      const decision = extractDecision(toolOutput);\n\n      if (decision && decision.length >= 20) {\n        const category = detectCategory(decision);\n        addToPendingQueue(decision, category, pendingFile);\n\n        const pendingCount = getPendingCount(pendingFile);\n\n        // Auto-sync when queue reaches threshold (5+ items)\n        if (pendingCount >= 5) {\n          logHook('realtime-sync', `BATCHED queue has ${pendingCount} items - triggering batch sync`);\n\n          return {\n            continue: true,\n            systemMessage: `[BATCHED SYNC] ${pendingCount} patterns/conventions queued for graph sync.\n\nLatest: \"${decision.substring(0, 100)}...\" (${category})\n\nThese will be synced to knowledge graph at session end, or trigger batch sync now with mcp__memory__create_entities for each item in:\n${pendingFile}`,\n          };\n        }\n      }\n\n      return outputSilentSuccess();\n    }\n\n    case 'SESSION_END':\n    default:\n      // Let existing Stop hooks handle this\n      return outputSilentSuccess();\n  }\n}\n", "/**\n * Session Metrics - Tracks tool usage statistics\n * CC 2.1.7 Compliant: Self-contained hook with stdin reading\n * Hook: PostToolUse (*)\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\nconst METRICS_FILE = '/tmp/claude-session-metrics.json';\nconst LOCKFILE = `${METRICS_FILE}.lock`;\n\ninterface SessionMetrics {\n  tools: Record<string, number>;\n  errors: number;\n  warnings: number;\n}\n\n/**\n * Track tool usage metrics\n */\nexport function sessionMetrics(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  if (!toolName) {\n    return outputSilentSuccess();\n  }\n\n  try {\n    // Initialize metrics file if needed\n    let metrics: SessionMetrics = { tools: {}, errors: 0, warnings: 0 };\n\n    if (existsSync(METRICS_FILE)) {\n      try {\n        const content = readFileSync(METRICS_FILE, 'utf8').trim();\n        if (content) {\n          metrics = JSON.parse(content);\n        }\n      } catch {\n        // Invalid JSON, reinitialize\n        metrics = { tools: {}, errors: 0, warnings: 0 };\n      }\n    }\n\n    // Ensure tools object exists\n    if (!metrics.tools) {\n      metrics.tools = {};\n    }\n\n    // Increment tool counter\n    const currentCount = metrics.tools[toolName] || 0;\n    metrics.tools[toolName] = currentCount + 1;\n\n    // Write updated metrics\n    writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));\n  } catch (error) {\n    logHook('session-metrics', `Error updating metrics: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Edit Pattern Tracker - PostToolUse Hook\n * Tracks edit patterns after skill usage to enable skill evolution\n *\n * Part of: #58 (Skill Evolution System)\n * Triggers on: Write|Edit after skill usage\n * Action: Categorize and log edit patterns for evolution analysis\n * CC 2.1.7 Compliant\n *\n * Version: 1.0.2 - TypeScript port\n */\n\nimport { existsSync, readFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../lib/common.js';\n\n// Edit pattern categories with detection patterns\nconst PATTERN_DEFINITIONS: Array<{ name: string; regex: RegExp }> = [\n  // API/Backend patterns\n  { name: 'add_pagination', regex: /limit.*offset|page.*size|cursor.*pagination|paginate|Paginated/i },\n  { name: 'add_rate_limiting', regex: /rate.?limit|throttl|RateLimiter|requests.?per/i },\n  { name: 'add_caching', regex: /@cache|cache_key|TTL|redis|memcache|@cached/i },\n  { name: 'add_retry_logic', regex: /retry|backoff|max_attempts|tenacity|Retry/i },\n  // Error handling patterns\n  { name: 'add_error_handling', regex: /try.*catch|except|raise.*Exception|throw.*Error|error.*handler/i },\n  { name: 'add_validation', regex: /validate|Validator|@validate|Pydantic|Zod|yup|schema/i },\n  { name: 'add_logging', regex: /logger[.]|logging[.]|console[.]log|winston|pino|structlog/i },\n  // Type safety patterns\n  { name: 'add_types', regex: /: *(str|int|bool|List|Dict|Optional)|interface |type .*=/i },\n  { name: 'add_type_guards', regex: /isinstance|typeof|is.*Type|assert.*type/i },\n  // Code quality patterns\n  { name: 'add_docstring', regex: /docstring|\"\"\"[^\"]+\"\"\"|\\/\\*\\*/i },\n  { name: 'remove_comments', regex: /^-.*#|^-.*\\/\\/|^-.*\\*/m },\n  // Security patterns\n  { name: 'add_auth_check', regex: /@auth|@require_auth|isAuthenticated|requiresAuth|@login_required/i },\n  { name: 'add_input_sanitization', regex: /escape|sanitize|htmlspecialchars|DOMPurify/i },\n  // Testing patterns\n  { name: 'add_test_case', regex: /def test_|it\\(|describe\\(|expect\\(|assert|@pytest/i },\n  { name: 'add_mock', regex: /Mock|patch|jest[.]mock|vi[.]mock|MagicMock/i },\n  // Import/dependency patterns\n  { name: 'modify_imports', regex: /^[+-].*import|^[+-].*from.*import|^[+-].*require\\(/m },\n  // Async patterns\n  { name: 'add_async', regex: /async |await |Promise|asyncio|async def/i },\n];\n\n/**\n * Get recent skill usage from session state\n */\nfunction getRecentSkill(sessionStateFile: string): string {\n  if (!existsSync(sessionStateFile)) {\n    return '';\n  }\n\n  try {\n    const content = JSON.parse(readFileSync(sessionStateFile, 'utf8'));\n    const now = Math.floor(Date.now() / 1000);\n    const cutoff = now - 300; // 5 minutes\n\n    const recentSkills = (content.recentSkills || [])\n      .filter((s: { timestamp: number }) => s.timestamp > cutoff)\n      .sort((a: { timestamp: number }, b: { timestamp: number }) => b.timestamp - a.timestamp);\n\n    return recentSkills[0]?.skillId || '';\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Detect edit patterns in content diff\n */\nfunction detectPatterns(diffContent: string): string[] {\n  const detected: string[] = [];\n\n  for (const { name, regex } of PATTERN_DEFINITIONS) {\n    if (regex.test(diffContent)) {\n      detected.push(name);\n    }\n  }\n\n  return detected;\n}\n\n/**\n * Log edit pattern to JSONL file\n */\nfunction logEditPattern(\n  skillId: string,\n  filePath: string,\n  patterns: string[],\n  editPatternsFile: string\n): void {\n  const sessionId = getSessionId();\n  const timestamp = new Date().toISOString();\n\n  const entry = {\n    timestamp,\n    skill_id: skillId,\n    file_path: filePath,\n    session_id: sessionId,\n    patterns,\n  };\n\n  try {\n    mkdirSync(require('path').dirname(editPatternsFile), { recursive: true });\n    appendFileSync(editPatternsFile, JSON.stringify(entry) + '\\n');\n  } catch {\n    // Ignore write errors\n  }\n}\n\n/**\n * Track skill edit patterns\n */\nexport function skillEditTracker(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Write/Edit tools\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  // Get file path from tool input\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Get recently used skill\n  const projectDir = getProjectDir();\n  const sessionStateFile = `${projectDir}/.claude/session/state.json`;\n  const skillId = getRecentSkill(sessionStateFile);\n\n  if (!skillId) {\n    // No recent skill usage - nothing to track\n    return outputSilentSuccess();\n  }\n\n  // Get the diff/edit content\n  let editContent = '';\n\n  if (toolName === 'Edit') {\n    // For Edit tool, analyze old_string -> new_string diff\n    const oldString = getField<string>(input, 'tool_input.old_string') || '';\n    const newString = getField<string>(input, 'tool_input.new_string') || '';\n\n    if (oldString && newString) {\n      // Create pseudo-diff (+ for added, - for removed lines)\n      const oldLines = oldString.split('\\n');\n      const newLines = newString.split('\\n');\n      editContent = oldLines.map(l => `-${l}`).join('\\n') + '\\n' +\n                   newLines.map(l => `+${l}`).join('\\n');\n    }\n  } else {\n    // For Write tool, analyze the new content\n    editContent = getField<string>(input, 'tool_input.content') || '';\n  }\n\n  if (!editContent) {\n    return outputSilentSuccess();\n  }\n\n  // Detect patterns\n  const patterns = detectPatterns(editContent);\n\n  // Only log if patterns detected\n  if (patterns.length > 0) {\n    const editPatternsFile = `${projectDir}/.claude/feedback/edit-patterns.jsonl`;\n    logEditPattern(skillId, filePath, patterns, editPatternsFile);\n\n    // Debug log\n    if (process.env.CLAUDE_HOOK_DEBUG) {\n      logHook('skill-edit-tracker', `Detected ${patterns.length} patterns for ${skillId}: ${JSON.stringify(patterns)}`);\n    }\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: `Working with ${agentTitle}`,\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Calibration Tracker - PostToolUse Hook for Tracking Task Completions\n * Issue #197: Agent Orchestration Layer\n *\n * Tracks agent task completions for calibration:\n * - Captures dispatch-outcome pairs\n * - Records to calibration engine\n * - Triggers on TaskUpdate tool calls\n *\n * CC 2.1.9 Compliant: Silent hook that tracks in background\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport { recordOutcome } from '../lib/calibration-engine.js';\nimport { getTaskById } from '../lib/task-integration.js';\nimport { getLastClassification, loadConfig } from '../lib/orchestration-state.js';\nimport type { AgentOutcome } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Extract task ID from TaskUpdate tool input\n */\nfunction extractTaskId(input: HookInput): string | null {\n  const toolInput = input.tool_input || {};\n\n  // TaskUpdate has taskId parameter\n  if (typeof toolInput.taskId === 'string') {\n    return toolInput.taskId;\n  }\n\n  return null;\n}\n\n/**\n * Check if this is a task status update\n */\nfunction isTaskStatusUpdate(input: HookInput): boolean {\n  if (input.tool_name !== 'TaskUpdate') {\n    return false;\n  }\n\n  const toolInput = input.tool_input || {};\n  return typeof toolInput.status === 'string';\n}\n\n/**\n * Map task status to agent outcome\n */\nfunction statusToOutcome(status: string): AgentOutcome | null {\n  switch (status) {\n    case 'completed':\n      return 'success';\n    case 'pending':\n      // Pending after in_progress might indicate failure\n      return null;\n    default:\n      return null;\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Calibration tracker hook\n *\n * Monitors TaskUpdate tool calls to track agent outcomes:\n * 1. Checks if this is a task status update to 'completed'\n * 2. Looks up the task to find associated agent\n * 3. Records outcome to calibration engine\n */\nexport function calibrationTracker(input: HookInput): HookResult {\n  // Only track TaskUpdate calls\n  if (!isTaskStatusUpdate(input)) {\n    return outputSilentSuccess();\n  }\n\n  // Check if calibration is enabled\n  const config = loadConfig();\n  if (!config.enableCalibration) {\n    return outputSilentSuccess();\n  }\n\n  const toolInput = input.tool_input || {};\n  const taskId = extractTaskId(input);\n  const status = toolInput.status as string;\n\n  if (!taskId) {\n    return outputSilentSuccess();\n  }\n\n  // Only track completions\n  const outcome = statusToOutcome(status);\n  if (!outcome) {\n    return outputSilentSuccess();\n  }\n\n  logHook('calibration-tracker', `Tracking task ${taskId} status update to ${status}`);\n\n  // Look up task\n  const task = getTaskById(taskId);\n  if (!task) {\n    logHook('calibration-tracker', `Task ${taskId} not found in registry`);\n    return outputSilentSuccess();\n  }\n\n  // Get agent from task\n  const agent = task.agent;\n  if (!agent) {\n    logHook('calibration-tracker', `No agent associated with task ${taskId}`);\n    return outputSilentSuccess();\n  }\n\n  // Get last classification for keywords\n  const lastClassification = getLastClassification();\n  const agentMatch = lastClassification?.agents.find(a => a.agent === agent);\n\n  const matchedKeywords = agentMatch?.matchedKeywords || [];\n  const confidence = task.confidence || agentMatch?.confidence || 0;\n\n  // Calculate duration if possible\n  const durationMs = task.createdAt\n    ? Date.now() - new Date(task.createdAt).getTime()\n    : undefined;\n\n  // Record to calibration engine\n  recordOutcome(\n    '', // Prompt not available in PostTool context\n    agent,\n    matchedKeywords,\n    confidence,\n    outcome,\n    durationMs\n  );\n\n  logHook(\n    'calibration-tracker',\n    `Recorded calibration: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n\n  return outputSilentSuccess();\n}\n", "/**\n * Code Style Learner - Learn user's code style preferences from written code\n * Hook: PostToolUse/Write (#133)\n * CC 2.1.7 Compliant\n *\n * Tracks:\n * - Indentation (tabs vs spaces, indent size)\n * - Quote style (single vs double quotes)\n * - Naming patterns (detected from code)\n * - Import order (stdlib first, third-party, local)\n *\n * Storage: .claude/feedback/code-style-profile.json\n * Memory Fabric v2.1: Cross-project learning via patterns queue\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface StyleProfile {\n  version: string;\n  last_updated: string | null;\n  samples_count: number;\n  languages: Record<string, LanguageProfile>;\n  global_preferences: {\n    indentation: { style: string; size: number; confidence: number };\n    quotes: { style: string; confidence: number };\n  };\n}\n\ninterface LanguageProfile {\n  samples: number;\n  indentation: { tabs: number; spaces_2: number; spaces_4: number };\n  quotes: { single: number; double: number };\n  semicolons: { always: number; omit: number };\n  trailing_comma: { always: number; minimal: number };\n  type_hints: { used: number; not_used: number };\n  docstring_style: Record<string, number>;\n}\n\nconst CODE_EXTENSIONS = ['py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java'];\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py': return 'python';\n    case 'ts':\n    case 'tsx': return 'typescript';\n    case 'js':\n    case 'jsx': return 'javascript';\n    case 'go': return 'go';\n    case 'rs': return 'rust';\n    case 'java': return 'java';\n    default: return null;\n  }\n}\n\n/**\n * Detect indentation style from code content\n */\nfunction detectIndentation(content: string): { style: string; size: number } {\n  let tabCount = 0;\n  let space2Count = 0;\n  let space4Count = 0;\n\n  for (const line of content.split('\\n')) {\n    if (line.startsWith('\\t')) {\n      tabCount++;\n    } else if (line.startsWith('    ')) {\n      space4Count++;\n    } else if (line.match(/^  [^ ]/)) {\n      space2Count++;\n    }\n  }\n\n  if (tabCount > space2Count + space4Count) {\n    return { style: 'tabs', size: 1 };\n  }\n  if (space2Count > space4Count) {\n    return { style: 'spaces', size: 2 };\n  }\n  if (space4Count > 0) {\n    return { style: 'spaces', size: 4 };\n  }\n\n  return { style: 'unknown', size: 4 };\n}\n\n/**\n * Detect quote style from code content\n */\nfunction detectQuoteStyle(content: string): string {\n  const singleCount = (content.match(/'/g) || []).length;\n  const doubleCount = (content.match(/\"/g) || []).length;\n\n  return singleCount > doubleCount ? 'single' : 'double';\n}\n\n/**\n * Detect semicolon usage (JS/TS)\n */\nfunction detectSemicolonStyle(content: string): string {\n  let withSemi = 0;\n  let withoutSemi = 0;\n\n  for (const line of content.split('\\n')) {\n    // Skip empty lines and comments\n    const trimmed = line.trim();\n    if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('*')) continue;\n\n    if (/;\\s*$/.test(line)) {\n      withSemi++;\n    } else if (/[a-zA-Z0-9\\)\\]\\'\\\"]\\\\s*$/.test(line)) {\n      withoutSemi++;\n    }\n  }\n\n  return withSemi > withoutSemi ? 'always' : 'omit';\n}\n\n/**\n * Detect trailing comma preference\n */\nfunction detectTrailingComma(content: string): string {\n  const trailingCount = (content.match(/,\\s*$/gm) || []).length;\n  return trailingCount > 5 ? 'always' : 'minimal';\n}\n\n/**\n * Detect Python-specific patterns\n */\nfunction detectPythonPatterns(content: string): { typeHints: boolean; docstringStyle: string } {\n  const hasTypeHints = /\\) -> |: [A-Z][a-zA-Z]+(\\[|$| =)/.test(content);\n\n  let docstringStyle = 'unknown';\n  if (/\"\"\"[^\"]+\"\"\"/.test(content)) {\n    if (/:param |:returns:|:raises:/.test(content)) {\n      docstringStyle = 'sphinx';\n    } else if (/Args:|Returns:|Raises:/.test(content)) {\n      docstringStyle = 'google';\n    } else if (/Parameters|Returns\\n-+/.test(content)) {\n      docstringStyle = 'numpy';\n    } else {\n      docstringStyle = 'simple';\n    }\n  }\n\n  return { typeHints: hasTypeHints, docstringStyle };\n}\n\n/**\n * Load or initialize style profile\n */\nfunction loadProfile(profilePath: string): StyleProfile {\n  if (existsSync(profilePath)) {\n    try {\n      return JSON.parse(readFileSync(profilePath, 'utf8'));\n    } catch {\n      // Invalid JSON, reinitialize\n    }\n  }\n\n  return {\n    version: '1.0.0',\n    last_updated: null,\n    samples_count: 0,\n    languages: {},\n    global_preferences: {\n      indentation: { style: 'unknown', size: 4, confidence: 0 },\n      quotes: { style: 'unknown', confidence: 0 },\n    },\n  };\n}\n\n/**\n * Update style profile with new observations\n */\nfunction updateProfile(\n  profile: StyleProfile,\n  language: string,\n  indentation: { style: string; size: number },\n  quoteStyle: string,\n  semiStyle: string,\n  trailingComma: string,\n  typeHints: boolean | null,\n  docstringStyle: string\n): void {\n  profile.last_updated = new Date().toISOString();\n  profile.samples_count++;\n\n  // Initialize language profile if needed\n  if (!profile.languages[language]) {\n    profile.languages[language] = {\n      samples: 0,\n      indentation: { tabs: 0, spaces_2: 0, spaces_4: 0 },\n      quotes: { single: 0, double: 0 },\n      semicolons: { always: 0, omit: 0 },\n      trailing_comma: { always: 0, minimal: 0 },\n      type_hints: { used: 0, not_used: 0 },\n      docstring_style: {},\n    };\n  }\n\n  const lang = profile.languages[language];\n  lang.samples++;\n\n  // Update indentation\n  if (indentation.style === 'tabs') {\n    lang.indentation.tabs++;\n  } else if (indentation.size === 2) {\n    lang.indentation.spaces_2++;\n  } else {\n    lang.indentation.spaces_4++;\n  }\n\n  // Update quotes\n  if (quoteStyle === 'single') {\n    lang.quotes.single++;\n  } else {\n    lang.quotes.double++;\n  }\n\n  // Update semicolons (JS/TS only)\n  if (semiStyle !== 'unknown') {\n    if (semiStyle === 'always') {\n      lang.semicolons.always++;\n    } else {\n      lang.semicolons.omit++;\n    }\n  }\n\n  // Update trailing comma\n  if (trailingComma !== 'unknown') {\n    if (trailingComma === 'always') {\n      lang.trailing_comma.always++;\n    } else {\n      lang.trailing_comma.minimal++;\n    }\n  }\n\n  // Update type hints (Python)\n  if (typeHints !== null) {\n    if (typeHints) {\n      lang.type_hints.used++;\n    } else {\n      lang.type_hints.not_used++;\n    }\n  }\n\n  // Update docstring style (Python)\n  if (docstringStyle !== 'unknown') {\n    lang.docstring_style[docstringStyle] = (lang.docstring_style[docstringStyle] || 0) + 1;\n  }\n}\n\n/**\n * Learn code style from written files\n */\nexport function codeStyleLearner(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Guard: Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Get file extension to determine language\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  if (!CODE_EXTENSIONS.includes(ext)) {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  // Try to get file content from tool_input or read the file\n  let content = getField<string>(input, 'tool_input.content') || '';\n\n  if (!content) {\n    const projectDir = getProjectDir();\n    const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n    if (existsSync(fullPath)) {\n      try {\n        // Read first 100 lines\n        content = readFileSync(fullPath, 'utf8').split('\\n').slice(0, 100).join('\\n');\n      } catch {\n        return outputSilentSuccess();\n      }\n    }\n  }\n\n  if (!content) {\n    return outputSilentSuccess();\n  }\n\n  // Analyze the code\n  const indentation = detectIndentation(content);\n  const quoteStyle = detectQuoteStyle(content);\n\n  let semiStyle = 'unknown';\n  let trailingComma = 'unknown';\n  let typeHints: boolean | null = null;\n  let docstringStyle = 'unknown';\n\n  // Language-specific detection\n  switch (language) {\n    case 'javascript':\n    case 'typescript':\n      semiStyle = detectSemicolonStyle(content);\n      trailingComma = detectTrailingComma(content);\n      break;\n    case 'python': {\n      const pyPatterns = detectPythonPatterns(content);\n      typeHints = pyPatterns.typeHints;\n      docstringStyle = pyPatterns.docstringStyle;\n      trailingComma = detectTrailingComma(content);\n      break;\n    }\n  }\n\n  // Load and update profile\n  const projectDir = getProjectDir();\n  const profilePath = `${projectDir}/.claude/feedback/code-style-profile.json`;\n\n  try {\n    mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n    const profile = loadProfile(profilePath);\n    updateProfile(profile, language, indentation, quoteStyle, semiStyle, trailingComma, typeHints, docstringStyle);\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n  } catch (error) {\n    logHook('code-style-learner', `Error updating profile: ${error}`);\n  }\n\n  logHook('code-style-learner',\n    `Analyzed ${language} file: indent=${indentation.style}(${indentation.size}) quotes=${quoteStyle}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Test Coverage Predictor - LLM-powered validation hook\n * Predicts if new code has adequate test coverage\n * CC 2.1.3 Feature: Post-write analysis\n */\n\nimport { existsSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir } from '../../lib/common.js';\n\n/**\n * Predict test coverage for written files\n */\nexport function coveragePredictor(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only run for Write tool\n  if (toolName !== 'Write') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') ||\n                   process.env.TOOL_OUTPUT_FILE_PATH || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Only analyze source code files (not tests themselves)\n  if (filePath.includes('test') || filePath.includes('spec') || filePath.includes('__tests__')) {\n    return outputSilentSuccess();\n  }\n\n  // Only analyze code files\n  if (!/\\.(py|ts|tsx|js|jsx)$/.test(filePath)) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n\n  // Determine corresponding test file location\n  let testPattern = '';\n  const basename = filePath.split('/').pop() || '';\n\n  if (filePath.endsWith('.py')) {\n    // Python: backend/app/services/foo.py -> backend/tests/unit/test_foo.py\n    const nameWithoutExt = basename.replace('.py', '');\n    testPattern = `test_${nameWithoutExt}.py`;\n  } else if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // TypeScript: src/components/Foo.tsx -> src/components/__tests__/Foo.test.tsx\n    const nameWithoutExt = basename.replace(/\\.[^.]+$/, '');\n    testPattern = `${nameWithoutExt}.test.*`;\n  } else {\n    return outputSilentSuccess();\n  }\n\n  // Check if test file exists\n  let testExists = '';\n  try {\n    const findResult = execSync(\n      `find \"${projectDir}\" -type f -name \"${testPattern}\" 2>/dev/null | head -1`,\n      { encoding: 'utf8', timeout: 5000 }\n    ).trim();\n    testExists = findResult;\n  } catch {\n    // find command failed, assume no test\n  }\n\n  // Log results\n  const logDir = `${projectDir}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n    const timestamp = new Date().toISOString();\n\n    if (testExists) {\n      appendFileSync(\n        `${logDir}/coverage-predictor.log`,\n        `[${timestamp}] COVERAGE_OK: ${filePath} has tests at ${testExists}\\n`\n      );\n    } else {\n      appendFileSync(\n        `${logDir}/coverage-predictor.log`,\n        `[${timestamp}] COVERAGE_WARN: ${filePath} may lack test coverage (expected: ${testPattern})\\n`\n      );\n\n      // Return subtle reminder (not blocking)\n      return {\n        continue: true,\n        systemMessage: `Consider adding tests for: ${filePath}`,\n      };\n    }\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Naming Convention Learner - Learn project naming conventions from written code\n * Hook: PostToolUse/Write (#134)\n * CC 2.1.7 Compliant\n *\n * Tracks:\n * - Variable naming (camelCase, snake_case, PascalCase, SCREAMING_CASE)\n * - Function naming patterns\n * - Class naming patterns\n * - File naming conventions\n * - Constant naming\n *\n * Storage: .claude/feedback/naming-conventions.json\n * Memory Fabric v2.1: Cross-project learning via patterns queue\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ntype NamingCase = 'camelCase' | 'snake_case' | 'PascalCase' | 'SCREAMING_SNAKE_CASE' | 'private_snake_case' | 'dunder' | 'mixed' | 'unknown';\n\ninterface NamingProfile {\n  version: string;\n  last_updated: string | null;\n  samples_count: number;\n  languages: Record<string, LanguageNamingProfile>;\n  file_naming: Record<string, number>;\n  detected_patterns: {\n    functions: Record<string, number>;\n    classes: Record<string, number>;\n    variables: Record<string, number>;\n    constants: Record<string, number>;\n    types: Record<string, number>;\n  };\n}\n\ninterface LanguageNamingProfile {\n  samples: number;\n  functions: Record<NamingCase, number>;\n  classes: Record<NamingCase, number>;\n  variables: Record<NamingCase, number>;\n  constants: Record<NamingCase, number>;\n  types: Record<NamingCase, number>;\n}\n\nconst CODE_EXTENSIONS = ['py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java'];\n\n/**\n * Detect naming case from an identifier\n */\nfunction detectCase(name: string): NamingCase {\n  if (name.length < 2 || /^[_0-9]+$/.test(name)) {\n    return 'unknown';\n  }\n\n  if (/^[A-Z][A-Z0-9_]*$/.test(name)) {\n    return 'SCREAMING_SNAKE_CASE';\n  }\n  if (/^[A-Z][a-zA-Z0-9]*$/.test(name)) {\n    return 'PascalCase';\n  }\n  if (/^[a-z][a-zA-Z0-9]*$/.test(name) && !name.includes('_')) {\n    return 'camelCase';\n  }\n  if (/^[a-z][a-z0-9_]*$/.test(name)) {\n    return 'snake_case';\n  }\n  if (/^_[a-z][a-z0-9_]*$/.test(name)) {\n    return 'private_snake_case';\n  }\n  if (/^__[a-z][a-z0-9_]*__$/.test(name)) {\n    return 'dunder';\n  }\n\n  return 'mixed';\n}\n\n/**\n * Extract Python identifiers from code\n */\nfunction extractPythonIdentifiers(content: string): {\n  functions: string[];\n  classes: string[];\n  variables: string[];\n  constants: string[];\n} {\n  const functions = (content.match(/def ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('def ', ''));\n\n  const classes = (content.match(/class ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('class ', ''));\n\n  const variables = (content.match(/^\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*=/gm) || [])\n    .map(m => m.replace(/\\s*=.*/, '').trim());\n\n  const constants = (content.match(/^([A-Z][A-Z0-9_]*)\\s*=/gm) || [])\n    .map(m => m.replace(/\\s*=.*/, '').trim());\n\n  return { functions, classes, variables, constants };\n}\n\n/**\n * Extract TypeScript/JavaScript identifiers from code\n */\nfunction extractJsIdentifiers(content: string): {\n  functions: string[];\n  classes: string[];\n  variables: string[];\n  interfaces: string[];\n  types: string[];\n} {\n  const functions = [\n    ...(content.match(/(function|async function) ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n      .map(m => m.replace(/(async )?function /, '')),\n    ...(content.match(/const ([a-zA-Z_][a-zA-Z0-9_]*)\\s*=\\s*\\(/g) || [])\n      .map(m => m.replace(/const /, '').replace(/\\s*=.*/, '')),\n  ];\n\n  const classes = (content.match(/class ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('class ', ''));\n\n  const interfaces = (content.match(/interface ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('interface ', ''));\n\n  const types = (content.match(/type ([A-Za-z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace('type ', ''));\n\n  const variables = (content.match(/(const|let|var) ([a-zA-Z_][a-zA-Z0-9_]*)/g) || [])\n    .map(m => m.replace(/(const|let|var) /, ''));\n\n  return { functions, classes, variables, interfaces, types };\n}\n\n/**\n * Count naming cases for a list of identifiers\n */\nfunction countCases(identifiers: string[]): Record<NamingCase, number> {\n  const counts: Record<NamingCase, number> = {\n    camelCase: 0,\n    snake_case: 0,\n    PascalCase: 0,\n    SCREAMING_SNAKE_CASE: 0,\n    private_snake_case: 0,\n    dunder: 0,\n    mixed: 0,\n    unknown: 0,\n  };\n\n  for (const name of identifiers) {\n    if (!name) continue;\n    const caseType = detectCase(name);\n    counts[caseType]++;\n  }\n\n  return counts;\n}\n\n/**\n * Detect file naming convention from file path\n */\nfunction detectFileNaming(filePath: string): string {\n  const filename = filePath.split('/').pop() || '';\n  const nameWithoutExt = filename.replace(/\\.[^.]+$/, '');\n\n  if (/^[a-z][a-z0-9_]*$/.test(nameWithoutExt)) {\n    return 'snake_case';\n  }\n  if (/^[a-z][a-z0-9-]*$/.test(nameWithoutExt)) {\n    return 'kebab-case';\n  }\n  if (/^[A-Z][a-zA-Z0-9]*$/.test(nameWithoutExt)) {\n    return 'PascalCase';\n  }\n  if (/^[a-z][a-zA-Z0-9]*$/.test(nameWithoutExt)) {\n    return 'camelCase';\n  }\n\n  return 'mixed';\n}\n\n/**\n * Get language from file extension\n */\nfunction getLanguage(filePath: string): string | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'py': return 'python';\n    case 'ts':\n    case 'tsx': return 'typescript';\n    case 'js':\n    case 'jsx': return 'javascript';\n    case 'go': return 'go';\n    case 'rs': return 'rust';\n    case 'java': return 'java';\n    default: return null;\n  }\n}\n\n/**\n * Load or initialize naming profile\n */\nfunction loadProfile(profilePath: string): NamingProfile {\n  if (existsSync(profilePath)) {\n    try {\n      return JSON.parse(readFileSync(profilePath, 'utf8'));\n    } catch {\n      // Invalid JSON, reinitialize\n    }\n  }\n\n  return {\n    version: '1.0.0',\n    last_updated: null,\n    samples_count: 0,\n    languages: {},\n    file_naming: {},\n    detected_patterns: {\n      functions: {},\n      classes: {},\n      variables: {},\n      constants: {},\n      types: {},\n    },\n  };\n}\n\n/**\n * Initialize language profile\n */\nfunction initLanguageProfile(): LanguageNamingProfile {\n  return {\n    samples: 0,\n    functions: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    classes: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    variables: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    constants: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n    types: { camelCase: 0, snake_case: 0, PascalCase: 0, SCREAMING_SNAKE_CASE: 0, private_snake_case: 0, dunder: 0, mixed: 0, unknown: 0 },\n  };\n}\n\n/**\n * Learn naming conventions from written files\n */\nexport function namingConventionLearner(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  // Guard: Skip internal files\n  if (!filePath || filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock')) {\n    return outputSilentSuccess();\n  }\n\n  // Get file extension to determine language\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  if (!CODE_EXTENSIONS.includes(ext)) {\n    return outputSilentSuccess();\n  }\n\n  const language = getLanguage(filePath);\n  if (!language) {\n    return outputSilentSuccess();\n  }\n\n  // Try to get file content from tool_input or read the file\n  let content = getField<string>(input, 'tool_input.content') || '';\n\n  if (!content) {\n    const projectDir = getProjectDir();\n    const fullPath = filePath.startsWith('/') ? filePath : `${projectDir}/${filePath}`;\n\n    if (existsSync(fullPath)) {\n      try {\n        // Read first 150 lines\n        content = readFileSync(fullPath, 'utf8').split('\\n').slice(0, 150).join('\\n');\n      } catch {\n        return outputSilentSuccess();\n      }\n    }\n  }\n\n  if (!content) {\n    return outputSilentSuccess();\n  }\n\n  // Detect file naming convention\n  const fileNaming = detectFileNaming(filePath);\n\n  // Extract identifiers based on language\n  let funcCases: Record<NamingCase, number> = countCases([]);\n  let classCases: Record<NamingCase, number> = countCases([]);\n  let varCases: Record<NamingCase, number> = countCases([]);\n  let constCases: Record<NamingCase, number> = countCases([]);\n  let typeCases: Record<NamingCase, number> = countCases([]);\n\n  switch (language) {\n    case 'python': {\n      const ids = extractPythonIdentifiers(content);\n      funcCases = countCases(ids.functions);\n      classCases = countCases(ids.classes);\n      varCases = countCases(ids.variables);\n      constCases = countCases(ids.constants);\n      break;\n    }\n    case 'typescript':\n    case 'javascript': {\n      const ids = extractJsIdentifiers(content);\n      funcCases = countCases(ids.functions);\n      classCases = countCases(ids.classes);\n      varCases = countCases(ids.variables);\n      typeCases = countCases([...ids.interfaces, ...ids.types]);\n      break;\n    }\n  }\n\n  // Load and update profile\n  const projectDir = getProjectDir();\n  const profilePath = `${projectDir}/.claude/feedback/naming-conventions.json`;\n\n  try {\n    mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n    const profile = loadProfile(profilePath);\n\n    // Update profile\n    profile.last_updated = new Date().toISOString();\n    profile.samples_count++;\n\n    // Update file naming counts\n    profile.file_naming[fileNaming] = (profile.file_naming[fileNaming] || 0) + 1;\n\n    // Initialize language entry if needed\n    if (!profile.languages[language]) {\n      profile.languages[language] = initLanguageProfile();\n    }\n\n    const lang = profile.languages[language];\n    lang.samples++;\n\n    // Update naming case counts\n    for (const caseType of Object.keys(funcCases) as NamingCase[]) {\n      lang.functions[caseType] = (lang.functions[caseType] || 0) + funcCases[caseType];\n      lang.classes[caseType] = (lang.classes[caseType] || 0) + classCases[caseType];\n      lang.variables[caseType] = (lang.variables[caseType] || 0) + varCases[caseType];\n      lang.constants[caseType] = (lang.constants[caseType] || 0) + constCases[caseType];\n      lang.types[caseType] = (lang.types[caseType] || 0) + typeCases[caseType];\n    }\n\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n  } catch (error) {\n    logHook('naming-convention-learner', `Error updating profile: ${error}`);\n  }\n\n  logHook('naming-convention-learner', `Analyzed ${language} file (${filePath}): file=${fileNaming}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * README Sync Hook for Claude Code\n * After significant code changes, suggests README updates\n * Tracks: new exports, API changes, config changes\n * Hook: PostToolUse (Write)\n * Issue: #140\n */\n\nimport { existsSync, statSync, appendFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface ChangeAnalysis {\n  changeType: string;\n  readmeSection: string;\n  suggestion: string;\n}\n\n/**\n * Analyze file for README-relevant changes\n */\nfunction analyzeFileChange(filePath: string, projectDir: string): ChangeAnalysis | null {\n  const filename = filePath.split('/').pop() || '';\n  const dirname = filePath.split('/').slice(0, -1).join('/');\n  const extLower = (filePath.split('.').pop() || '').toLowerCase();\n\n  // 1. Package configuration files\n  switch (filename) {\n    case 'package.json':\n      if (existsSync(`${projectDir}/${filePath}`)) {\n        try {\n          const pkg = require(`${projectDir}/${filePath}`);\n          const scriptCount = Object.keys(pkg.scripts || {}).length;\n          if (scriptCount > 5) {\n            return {\n              changeType: 'scripts',\n              readmeSection: 'Available Scripts',\n              suggestion: 'Update README with new npm scripts',\n            };\n          }\n        } catch {\n          // Ignore parse errors\n        }\n      }\n      break;\n\n    case 'pyproject.toml':\n    case 'setup.py':\n    case 'setup.cfg':\n      return {\n        changeType: 'python-config',\n        readmeSection: 'Installation',\n        suggestion: 'Verify README installation instructions match project config',\n      };\n\n    case 'Dockerfile':\n    case 'docker-compose.yml':\n    case 'docker-compose.yaml':\n      return {\n        changeType: 'docker',\n        readmeSection: 'Docker / Deployment',\n        suggestion: 'Update README Docker instructions',\n      };\n\n    case '.env.example':\n    case '.env.template':\n      return {\n        changeType: 'env',\n        readmeSection: 'Environment Variables',\n        suggestion: 'Update README environment variable documentation',\n      };\n  }\n\n  // 2. API routes and endpoints\n  if (filePath.includes('/api/') || filePath.includes('/routes/') || filePath.includes('/endpoints/')) {\n    return {\n      changeType: 'api',\n      readmeSection: 'API Endpoints',\n      suggestion: 'Update README API documentation or OpenAPI spec',\n    };\n  }\n\n  // 3. Configuration directories\n  if (dirname.includes('/config') || dirname.includes('/settings')) {\n    return {\n      changeType: 'config',\n      readmeSection: 'Configuration',\n      suggestion: 'Document new configuration options in README',\n    };\n  }\n\n  // 4. Main entry points / index files\n  if (['index.ts', 'index.js', 'main.py', 'app.py', '__init__.py'].includes(filename)) {\n    const depth = filePath.split('/').length;\n    if (depth <= 4) {\n      return {\n        changeType: 'entry-point',\n        readmeSection: 'Getting Started',\n        suggestion: 'Review README getting started section for accuracy',\n      };\n    }\n  }\n\n  // 5. CLI tools and bin scripts\n  if (filePath.includes('/bin/') || filePath.includes('/cli/') || filePath.includes('/scripts/')) {\n    if (['sh', 'py', 'ts'].includes(extLower)) {\n      return {\n        changeType: 'cli',\n        readmeSection: 'CLI / Commands',\n        suggestion: 'Update README CLI usage documentation',\n      };\n    }\n  }\n\n  // 6. Public exports (index files with exports)\n  if (filename === 'index.ts' || filename === 'index.js') {\n    const fullPath = `${projectDir}/${filePath}`;\n    if (existsSync(fullPath)) {\n      try {\n        const { readFileSync } = require('fs');\n        const content = readFileSync(fullPath, 'utf8');\n        const exportCount = (content.match(/^export/gm) || []).length;\n        if (exportCount > 5) {\n          return {\n            changeType: 'exports',\n            readmeSection: 'API Reference',\n            suggestion: 'Consider updating API reference with new exports',\n          };\n        }\n      } catch {\n        // Ignore read errors\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find README file in project\n */\nfunction findReadme(projectDir: string): string | null {\n  for (const name of ['README.md', 'Readme.md', 'readme.md', 'README.rst', 'README']) {\n    if (existsSync(`${projectDir}/${name}`)) {\n      return `${projectDir}/${name}`;\n    }\n  }\n  return null;\n}\n\n/**\n * Sync README suggestions\n */\nexport function readmeSync(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only run for Write tool\n  if (toolName !== 'Write') {\n    return outputSilentSuccess();\n  }\n\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Skip internal files\n  if (filePath.includes('/.claude/') ||\n      filePath.includes('/node_modules/') ||\n      filePath.includes('/.git/') ||\n      filePath.includes('/dist/') ||\n      filePath.endsWith('.lock') ||\n      filePath.endsWith('.log')) {\n    return outputSilentSuccess();\n  }\n\n  // Skip test files - they don't typically require README updates\n  if (filePath.includes('test') || filePath.includes('spec') || filePath.includes('__tests__')) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n\n  // Analyze file for README-relevant changes\n  const analysis = analyzeFileChange(filePath, projectDir);\n\n  if (!analysis) {\n    return outputSilentSuccess();\n  }\n\n  // Check if README exists\n  const readmePath = findReadme(projectDir);\n\n  let contextMsg: string;\n\n  if (readmePath) {\n    // Check when README was last modified\n    let daysOld = 0;\n    try {\n      const stats = statSync(readmePath);\n      const mtime = stats.mtime.getTime();\n      const now = Date.now();\n      daysOld = Math.floor((now - mtime) / (86400 * 1000));\n    } catch {\n      // Ignore stat errors\n    }\n\n    let suggestion = analysis.suggestion;\n    if (daysOld > 30) {\n      suggestion = `${suggestion} (README last updated ${daysOld}+ days ago)`;\n    }\n\n    contextMsg = `README sync: ${analysis.changeType} change in ${filePath.split('/').pop()}. Section: '${analysis.readmeSection}'. ${suggestion}`;\n  } else {\n    contextMsg = `README sync: ${analysis.changeType} change detected but no README.md found. Consider creating one.`;\n  }\n\n  // Truncate if too long\n  if (contextMsg.length > 200) {\n    contextMsg = `README sync: ${analysis.changeType} change detected. Consider updating '${analysis.readmeSection}' section.`;\n  }\n\n  // Log the suggestion\n  const logDir = `${projectDir}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n    const timestamp = new Date().toISOString();\n    appendFileSync(\n      `${logDir}/readme-sync.log`,\n      `[${timestamp}] README_SYNC: ${analysis.changeType} change in ${filePath} -> ${analysis.readmeSection}\\n`\n    );\n  } catch {\n    // Ignore log errors\n  }\n\n  logHook('readme-sync', `README_SYNC: ${analysis.changeType} change suggests README update`);\n\n  // Output using CC 2.1.9 additionalContext format\n  return {\n    continue: true,\n    hookSpecificOutput: {\n      additionalContext: contextMsg,\n    },\n  };\n}\n", "/**\n * Release Lock on Commit - PostToolUse Hook\n * Releases file locks after successful git commit\n *\n * Triggers on: Bash with git commit that succeeded\n * Action: Release locks on committed files\n * CC 2.1.7 Compliant: Proper JSON output\n *\n * Version: 1.0.1\n * Part of Multi-Worktree Coordination System\n */\n\nimport { existsSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../../lib/common.js';\n\n/**\n * Release file locks after Write operations\n * Note: This hook is for Write tool - locks are released on session end or explicit release\n */\nexport function releaseLockOnCommit(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const coordLib = `${projectDir}/.claude/coordination/lib/coordination.sh`;\n\n  // Check if coordination lib exists\n  if (!existsSync(coordLib)) {\n    return outputSilentSuccess();\n  }\n\n  // This hook runs after Write tool - we don't release locks here\n  // Locks are released on session end or explicit release\n  // The coordination system handles auto-expiration of stale locks\n\n  return outputSilentSuccess();\n}\n", "/**\n * Issue Progress Commenter - Queue commit progress for GitHub issue updates\n * Part of OrchestKit Plugin - Issue Progress Tracking\n *\n * Triggers: After successful git commit commands\n * Function: Extracts issue number from branch name or commit message and queues\n *           progress for batch commenting at session end\n *\n * CC 2.1.9 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getSessionId, logHook } from '../../lib/common.js';\n\ninterface ProgressFile {\n  session_id: string;\n  issues: Record<string, IssueProgress>;\n}\n\ninterface IssueProgress {\n  commits: CommitInfo[];\n  tasks_completed: string[];\n  pr_url: string | null;\n  branch: string;\n}\n\ninterface CommitInfo {\n  sha: string;\n  message: string;\n  timestamp: string;\n}\n\n/**\n * Extract issue number from branch name (e.g., issue/123-description, fix/123-bug)\n */\nfunction extractIssueFromBranch(branch: string): string | null {\n  // Pattern: issue/123-*, fix/123-*, feature/123-*, etc.\n  let match = branch.match(/^(issue|fix|feature|bug|feat)\\/(\\d+)/);\n  if (match) {\n    return match[2];\n  }\n\n  // Pattern: 123-description (issue number at start)\n  match = branch.match(/^(\\d+)-/);\n  if (match) {\n    return match[1];\n  }\n\n  return null;\n}\n\n/**\n * Extract issue number from commit message (e.g., \"fix(#123): message\" or \"closes #123\")\n */\nfunction extractIssueFromCommit(message: string): string | null {\n  // Pattern: (#123) or #123 in message\n  let match = message.match(/#(\\d+)/);\n  if (match) {\n    return match[1];\n  }\n\n  // Pattern: fixes/closes/resolves #123\n  match = message.match(/(fix|fixes|close|closes|resolve|resolves)\\s+#?(\\d+)/i);\n  if (match) {\n    return match[2];\n  }\n\n  return null;\n}\n\n/**\n * Get current branch name\n */\nfunction getCurrentBranch(): string {\n  try {\n    return execSync('git branch --show-current 2>/dev/null || git rev-parse --abbrev-ref HEAD 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Get latest commit info\n */\nfunction getLatestCommit(): CommitInfo | null {\n  try {\n    const sha = execSync('git rev-parse --short HEAD 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    const message = execSync('git log -1 --pretty=%s 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    const timestamp = execSync('git log -1 --pretty=%cI 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim() || new Date().toISOString();\n\n    return { sha, message, timestamp };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Initialize progress file if needed\n */\nfunction initProgressFile(progressFile: string, sessionId: string): void {\n  if (!existsSync(progressFile)) {\n    try {\n      mkdirSync(require('path').dirname(progressFile), { recursive: true });\n      writeFileSync(progressFile, JSON.stringify({\n        session_id: sessionId,\n        issues: {},\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Add commit to issue progress queue\n */\nfunction queueCommitProgress(\n  issueNum: string,\n  commit: CommitInfo,\n  branch: string,\n  progressFile: string,\n  sessionId: string\n): boolean {\n  initProgressFile(progressFile, sessionId);\n\n  try {\n    const data: ProgressFile = JSON.parse(readFileSync(progressFile, 'utf8'));\n\n    if (!data.issues[issueNum]) {\n      data.issues[issueNum] = {\n        commits: [],\n        tasks_completed: [],\n        pr_url: null,\n        branch,\n      };\n    }\n\n    data.issues[issueNum].commits.push(commit);\n    data.issues[issueNum].branch = branch;\n\n    writeFileSync(progressFile, JSON.stringify(data, null, 2));\n    logHook('issue-progress-commenter', `Queued commit for issue #${issueNum}`);\n    return true;\n  } catch {\n    logHook('issue-progress-commenter', `Error queuing commit for issue #${issueNum}`);\n    return false;\n  }\n}\n\n/**\n * Queue commit progress for GitHub issue updates\n */\nexport function issueProgressCommenter(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  // Only process successful git commit commands\n  if (!/git\\s+commit/i.test(command) || exitCode !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-progress-commenter', 'Processing git commit command...');\n\n  // Check if gh CLI is available\n  try {\n    execSync('which gh', { stdio: 'ignore', timeout: 2000 });\n  } catch {\n    logHook('issue-progress-commenter', 'gh CLI not available, skipping issue progress tracking');\n    return outputSilentSuccess();\n  }\n\n  // Check if we're in a git repo with GitHub remote\n  try {\n    const remote = execSync('git remote get-url origin 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    });\n    if (!remote.includes('github')) {\n      logHook('issue-progress-commenter', 'Not a GitHub repository, skipping');\n      return outputSilentSuccess();\n    }\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Get branch and commit info\n  const branch = getCurrentBranch();\n  if (!branch) {\n    logHook('issue-progress-commenter', 'Could not determine current branch');\n    return outputSilentSuccess();\n  }\n\n  // Try to extract issue number\n  let issueNum = extractIssueFromBranch(branch);\n\n  // If not found in branch, try commit message\n  if (!issueNum) {\n    try {\n      const commitMsg = execSync('git log -1 --pretty=%s 2>/dev/null', {\n        encoding: 'utf8',\n        timeout: 5000,\n      }).trim();\n      issueNum = extractIssueFromCommit(commitMsg);\n    } catch {\n      // Ignore\n    }\n  }\n\n  // If no issue number found, skip silently\n  if (!issueNum) {\n    logHook('issue-progress-commenter', `No issue number found in branch '${branch}' or commit message`);\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-progress-commenter', `Found issue #${issueNum}`);\n\n  // Verify issue exists (quick check)\n  try {\n    execSync(`gh issue view ${issueNum} --json number`, { stdio: 'ignore', timeout: 5000 });\n  } catch {\n    logHook('issue-progress-commenter', `Issue #${issueNum} not found or not accessible`);\n    return outputSilentSuccess();\n  }\n\n  // Get commit info and queue it\n  const commit = getLatestCommit();\n  if (!commit) {\n    logHook('issue-progress-commenter', 'Could not get commit info');\n    return outputSilentSuccess();\n  }\n\n  // Sanitize session ID - prefer input.session_id, fallback to getSessionId()\n  const sessionId = (input.session_id || getSessionId()).replace(/[^a-zA-Z0-9_-]/g, '');\n  const progressFile = `/tmp/claude-session-${sessionId}/issue-progress.json`;\n\n  queueCommitProgress(issueNum, commit, branch, progressFile, sessionId);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Issue Subtask Updater - Auto-update issue checkboxes based on commit messages\n * Part of OrchestKit Plugin - Issue Progress Tracking\n *\n * Triggers: After successful git commit commands\n * Function: Parses commit message for task completion keywords and updates\n *           corresponding checkboxes in the GitHub issue body\n *\n * CC 2.1.9 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getSessionId, logHook } from '../../lib/common.js';\n\ninterface ProgressFile {\n  session_id: string;\n  issues: Record<string, IssueProgress>;\n}\n\ninterface IssueProgress {\n  commits: unknown[];\n  tasks_completed: string[];\n  pr_url: string | null;\n}\n\n/**\n * Extract action and subject from commit message\n * e.g., \"feat(#123): Add input validation\" -> \"Add input validation\"\n */\nfunction extractTaskFromCommit(message: string): string {\n  // Remove conventional commit prefix: type(scope):\n  let task = message.replace(/^[a-z]+(\\([^)]*\\))?:\\s*/i, '');\n\n  // Remove issue references like (#123)\n  task = task.replace(/\\(#\\d+\\)/g, '');\n\n  return task.trim();\n}\n\n/**\n * Normalize text for comparison (lowercase, remove extra spaces)\n */\nfunction normalizeText(text: string): string {\n  return text.toLowerCase().replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Check if commit task matches a checkbox item\n */\nfunction matchesCheckbox(commitTask: string, checkboxText: string): boolean {\n  const normCommit = normalizeText(commitTask);\n  const normCheckbox = normalizeText(checkboxText);\n\n  // Exact match (after normalization)\n  if (normCommit === normCheckbox) {\n    return true;\n  }\n\n  // Commit task contains checkbox text\n  if (normCommit.includes(normCheckbox)) {\n    return true;\n  }\n\n  // Checkbox text contains commit task\n  if (normCheckbox.includes(normCommit)) {\n    return true;\n  }\n\n  // Check if they share significant words (at least 2 words matching)\n  const commitWords = new Set(normCommit.split(' ').filter(w => w.length >= 3));\n  const checkboxWords = normCheckbox.split(' ').filter(w => w.length >= 3);\n  let matchingWords = 0;\n\n  for (const word of checkboxWords) {\n    if (commitWords.has(word)) {\n      matchingWords++;\n    }\n  }\n\n  return matchingWords >= 2;\n}\n\n/**\n * Extract issue number from branch name\n */\nfunction extractIssueFromBranch(branch: string): string | null {\n  let match = branch.match(/^(issue|fix|feature|bug|feat)\\/(\\d+)/);\n  if (match) {\n    return match[2];\n  }\n\n  match = branch.match(/^(\\d+)-/);\n  if (match) {\n    return match[1];\n  }\n\n  return null;\n}\n\n/**\n * Extract issue number from commit message\n */\nfunction extractIssueFromCommit(message: string): string | null {\n  const match = message.match(/#(\\d+)/);\n  return match ? match[1] : null;\n}\n\n/**\n * Get unchecked tasks from issue body\n */\nfunction getUncheckedTasks(issueNum: string): string[] {\n  try {\n    const body = execSync(`gh issue view ${issueNum} --json body -q '.body' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 10000,\n    });\n\n    // Extract unchecked checkbox items: - [ ] text\n    const lines = body.split('\\n');\n    const unchecked: string[] = [];\n\n    for (const line of lines) {\n      const match = line.match(/^\\s*-\\s*\\[\\s*\\]\\s+(.+)/);\n      if (match) {\n        unchecked.push(match[1].trim());\n      }\n    }\n\n    return unchecked;\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Update a checkbox from unchecked to checked\n */\nfunction updateCheckbox(issueNum: string, checkboxText: string): boolean {\n  logHook('issue-subtask-updater', `Attempting to update checkbox: '${checkboxText}' in issue #${issueNum}`);\n\n  try {\n    // Get current body\n    const body = execSync(`gh issue view ${issueNum} --json body -q '.body' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 10000,\n    });\n\n    // Escape special regex characters in checkbox text\n    const escapedText = checkboxText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    // Replace unchecked with checked\n    const updatedBody = body.replace(\n      new RegExp(`(^\\\\s*-\\\\s*)\\\\[\\\\s*\\\\](\\\\s+${escapedText})`, 'm'),\n      '$1[x]$2'\n    );\n\n    // Check if anything changed\n    if (body === updatedBody) {\n      logHook('issue-subtask-updater', `No change needed for checkbox: '${checkboxText}'`);\n      return false;\n    }\n\n    // Get repo info\n    const repo = execSync(`gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null`, {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    // Update issue body via API\n    const bodyJson = JSON.stringify(updatedBody);\n    execSync(`gh api -X PATCH \"repos/${repo}/issues/${issueNum}\" -f body=${bodyJson}`, {\n      stdio: 'ignore',\n      timeout: 10000,\n    });\n\n    logHook('issue-subtask-updater', `Successfully updated checkbox: '${checkboxText}'`);\n    return true;\n  } catch (error) {\n    logHook('issue-subtask-updater', `Failed to update issue body: ${error}`);\n    return false;\n  }\n}\n\n/**\n * Record completed task in progress file\n */\nfunction recordTaskCompletion(issueNum: string, taskText: string, progressFile: string): void {\n  if (!existsSync(progressFile)) {\n    return;\n  }\n\n  try {\n    const data: ProgressFile = JSON.parse(readFileSync(progressFile, 'utf8'));\n\n    if (!data.issues[issueNum]) {\n      data.issues[issueNum] = {\n        commits: [],\n        tasks_completed: [],\n        pr_url: null,\n      };\n    }\n\n    if (!data.issues[issueNum].tasks_completed.includes(taskText)) {\n      data.issues[issueNum].tasks_completed.push(taskText);\n      writeFileSync(progressFile, JSON.stringify(data, null, 2));\n    }\n  } catch {\n    // Ignore errors\n  }\n}\n\n/**\n * Update issue subtasks based on commit\n */\nexport function issueSubtaskUpdater(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  // Only process successful git commit commands\n  if (!/git\\s+commit/i.test(command) || exitCode !== 0) {\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', 'Processing git commit for subtask updates...');\n\n  // Check if gh CLI is available\n  try {\n    execSync('which gh', { stdio: 'ignore', timeout: 2000 });\n  } catch {\n    logHook('issue-subtask-updater', 'gh CLI not available, skipping subtask updates');\n    return outputSilentSuccess();\n  }\n\n  // Check if we're in a git repo with GitHub remote\n  try {\n    const remote = execSync('git remote get-url origin 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    });\n    if (!remote.includes('github')) {\n      logHook('issue-subtask-updater', 'Not a GitHub repository, skipping');\n      return outputSilentSuccess();\n    }\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Get branch and commit message\n  let branch = '';\n  let commitMsg = '';\n\n  try {\n    branch = execSync('git branch --show-current 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n\n    commitMsg = execSync('git log -1 --pretty=%s 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 5000,\n    }).trim();\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Extract issue number\n  let issueNum = extractIssueFromBranch(branch);\n  if (!issueNum) {\n    issueNum = extractIssueFromCommit(commitMsg);\n  }\n\n  if (!issueNum) {\n    logHook('issue-subtask-updater', 'No issue number found');\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', `Found issue #${issueNum}, checking for matching subtasks...`);\n\n  // Extract task from commit message\n  const commitTask = extractTaskFromCommit(commitMsg);\n  if (!commitTask) {\n    logHook('issue-subtask-updater', 'Could not extract task from commit message');\n    return outputSilentSuccess();\n  }\n\n  logHook('issue-subtask-updater', `Commit task: '${commitTask}'`);\n\n  // Get unchecked tasks from issue\n  const uncheckedTasks = getUncheckedTasks(issueNum);\n  if (uncheckedTasks.length === 0) {\n    logHook('issue-subtask-updater', `No unchecked tasks in issue #${issueNum}`);\n    return outputSilentSuccess();\n  }\n\n  // Check each unchecked task for a match\n  let matched = false;\n  const sessionId = (input.session_id || getSessionId()).replace(/[^a-zA-Z0-9_-]/g, '');\n  const progressFile = `/tmp/claude-session-${sessionId}/issue-progress.json`;\n\n  for (const checkboxText of uncheckedTasks) {\n    if (matchesCheckbox(commitTask, checkboxText)) {\n      logHook('issue-subtask-updater', `Found matching checkbox: '${checkboxText}'`);\n\n      if (updateCheckbox(issueNum, checkboxText)) {\n        recordTaskCompletion(issueNum, checkboxText, progressFile);\n        matched = true;\n      }\n    }\n  }\n\n  if (!matched) {\n    logHook('issue-subtask-updater', `No matching checkboxes found for task: '${commitTask}'`);\n    return outputSilentSuccess();\n  }\n\n  // Provide additionalContext to Claude when tasks are updated (CC 2.1.9)\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: `Issue #${issueNum}: Automatically marked sub-task as complete based on commit.`,\n    },\n  };\n}\n", "/**\n * Pattern Extractor - Automatic pattern extraction from bash events\n * Part of OrchestKit Plugin - Cross-Project Patterns (#48) + Best Practices (#49)\n *\n * Automatically extracts patterns from:\n * - git commit messages\n * - gh pr merge\n * - test results (pass/fail)\n * - build results\n *\n * CC 2.1.9 Compliant: Uses additionalContext for pattern injection\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, logHook } from '../../lib/common.js';\n\ninterface PatternQueue {\n  patterns: PatternEntry[];\n}\n\ninterface PatternEntry {\n  text: string;\n  category: string;\n  outcome: string;\n  source: string;\n  timestamp: string;\n  project: string;\n}\n\n// Tech detection patterns\nconst TECH_PATTERNS: Record<string, RegExp> = {\n  JWT: /jwt|jsonwebtoken/i,\n  OAuth2: /oauth|oauth2/i,\n  PostgreSQL: /postgres|postgresql|psql/i,\n  Redis: /redis/i,\n  React: /react/i,\n  FastAPI: /fastapi/i,\n  SQLAlchemy: /sqlalchemy/i,\n  Alembic: /alembic/i,\n  'cursor-pagination': /cursor.based|keyset/i,\n  'offset-pagination': /offset.pagination/i,\n  WebSocket: /websocket/i,\n  SSE: /sse|server.sent/i,\n  GraphQL: /graphql/i,\n  REST: /rest.api|restful/i,\n};\n\n// Category patterns from commit prefixes\nconst CATEGORY_PATTERNS: Record<string, RegExp> = {\n  feature: /^feat:|^feature:/i,\n  bugfix: /^fix:|^bugfix:/i,\n  refactor: /^refactor:/i,\n  optimization: /^perf:|^performance:/i,\n  security: /^security:|^sec:/i,\n  testing: /^test:|^tests:/i,\n};\n\n// Best practice category detection\nconst BEST_PRACTICE_CATEGORIES: Record<string, RegExp> = {\n  pagination: /cursor|pagination|offset|limit|page/i,\n  caching: /cache|redis|memcache|ttl/i,\n  authentication: /auth|jwt|oauth|token|login/i,\n  validation: /validate|validation|schema|pydantic|zod/i,\n  testing: /test|spec|coverage|mock/i,\n  security: /security|encrypt|hash|secret|credential/i,\n  performance: /performance|optimize|cache|index/i,\n  error_handling: /error|exception|retry|fallback/i,\n};\n\n/**\n * Get project ID from directory\n */\nfunction getProjectId(): string {\n  const projectDir = getProjectDir();\n  return projectDir.split('/').pop() || 'unknown';\n}\n\n/**\n * Extract tech and pattern info from text\n */\nfunction extractPatternInfo(text: string): { tech: string; pattern: string } {\n  const textLower = text.toLowerCase();\n  let tech = 'unknown';\n  let pattern = 'general';\n\n  // Detect technologies\n  for (const [name, regex] of Object.entries(TECH_PATTERNS)) {\n    if (regex.test(textLower)) {\n      tech = name;\n      break;\n    }\n  }\n\n  // Detect patterns from commit prefixes\n  for (const [name, regex] of Object.entries(CATEGORY_PATTERNS)) {\n    if (regex.test(text)) {\n      pattern = name;\n      break;\n    }\n  }\n\n  return { tech, pattern };\n}\n\n/**\n * Detect best practice category\n */\nfunction detectBestPracticeCategory(text: string): string {\n  for (const [category, regex] of Object.entries(BEST_PRACTICE_CATEGORIES)) {\n    if (regex.test(text)) {\n      return category;\n    }\n  }\n  return 'general';\n}\n\n/**\n * Queue a pattern for storage (batched on session end)\n */\nfunction queuePattern(\n  text: string,\n  category: string,\n  outcome: string,\n  source: string,\n  patternsQueue: string\n): void {\n  const timestamp = new Date().toISOString();\n  const projectId = getProjectId();\n\n  // Initialize queue file if needed\n  if (!existsSync(patternsQueue)) {\n    try {\n      mkdirSync(require('path').dirname(patternsQueue), { recursive: true });\n      writeFileSync(patternsQueue, JSON.stringify({ patterns: [] }));\n    } catch {\n      return;\n    }\n  }\n\n  try {\n    const data: PatternQueue = JSON.parse(readFileSync(patternsQueue, 'utf8'));\n    data.patterns.push({\n      text,\n      category,\n      outcome,\n      source,\n      timestamp,\n      project: projectId,\n    });\n    writeFileSync(patternsQueue, JSON.stringify(data, null, 2));\n    logHook('pattern-extractor', `Queued pattern: category=${category} outcome=${outcome} source=${source}`);\n  } catch {\n    // Ignore queue errors\n  }\n}\n\n/**\n * Handle git commit pattern extraction\n */\nfunction handleGitCommit(command: string, exitCode: number, patternsQueue: string): void {\n  // Extract commit message\n  let commitMsg = '';\n  const msgMatch = command.match(/-m\\s+[\"']([^\"']+)[\"']/) ||\n                   command.match(/-m\\s+([^\\s]+)/);\n  if (msgMatch) {\n    commitMsg = msgMatch[1];\n  }\n\n  if (!commitMsg) {\n    return;\n  }\n\n  const { tech, pattern } = extractPatternInfo(commitMsg);\n  const category = detectBestPracticeCategory(commitMsg);\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n\n  // Build descriptive text\n  let patternText = commitMsg;\n  if (tech !== 'unknown') {\n    patternText = `[${tech}] ${commitMsg}`;\n  }\n\n  queuePattern(patternText, category, outcome, 'commit', patternsQueue);\n}\n\n/**\n * Handle PR merge pattern extraction\n */\nfunction handlePrMerge(command: string, exitCode: number, patternsQueue: string): void {\n  if (exitCode !== 0) {\n    return;\n  }\n\n  // PR merge is always a success pattern (reviewed code)\n  let prInfo = 'PR merged successfully';\n  const prMatch = command.match(/gh\\s+pr\\s+merge\\s+(\\d+)/);\n  if (prMatch) {\n    prInfo = `PR #${prMatch[1]} merged`;\n  }\n\n  queuePattern(prInfo, 'decision', 'success', 'pr-merge', patternsQueue);\n}\n\n/**\n * Handle test result pattern extraction\n */\nfunction handleTestResult(command: string, exitCode: number, patternsQueue: string): void {\n  let testFramework = 'unknown';\n\n  if (/pytest|py\\.test/.test(command)) testFramework = 'pytest';\n  else if (/jest/.test(command)) testFramework = 'jest';\n  else if (/vitest/.test(command)) testFramework = 'vitest';\n  else if (/npm\\s+test|yarn\\s+test|bun\\s+test/.test(command)) testFramework = 'npm-test';\n  else if (/go\\s+test/.test(command)) testFramework = 'go-test';\n\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n  const patternText = `Tests ${outcome === 'success' ? 'passed' : 'failed'} (${testFramework})`;\n\n  queuePattern(patternText, 'testing', outcome, 'test-run', patternsQueue);\n}\n\n/**\n * Handle build result pattern extraction\n */\nfunction handleBuildResult(command: string, exitCode: number, patternsQueue: string): void {\n  let buildTool = 'unknown';\n\n  if (/npm\\s+run\\s+build/.test(command)) buildTool = 'npm';\n  else if (/yarn\\s+build/.test(command)) buildTool = 'yarn';\n  else if (/cargo\\s+build/.test(command)) buildTool = 'cargo';\n  else if (/make/.test(command)) buildTool = 'make';\n  else if (/docker\\s+build/.test(command)) buildTool = 'docker';\n\n  const outcome = exitCode === 0 ? 'success' : 'failed';\n  const patternText = `Build ${outcome === 'success' ? 'succeeded' : 'failed'} (${buildTool})`;\n\n  queuePattern(patternText, 'build', outcome, 'build', patternsQueue);\n}\n\n/**\n * Extract patterns from bash events\n */\nexport function patternExtractor(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Only process Bash tool\n  if (toolName !== 'Bash') {\n    return outputSilentSuccess();\n  }\n\n  const command = getField<string>(input, 'tool_input.command') || '';\n  const exitCode = input.exit_code ?? 0;\n\n  if (!command) {\n    return outputSilentSuccess();\n  }\n\n  const commandLower = command.toLowerCase();\n  const projectDir = getProjectDir();\n  const patternsQueue = `${projectDir}/.claude/feedback/patterns-queue.json`;\n\n  // Route to appropriate handler\n  if (/git\\s+commit/.test(commandLower)) {\n    handleGitCommit(command, exitCode, patternsQueue);\n  } else if (/gh\\s+pr\\s+merge/.test(commandLower)) {\n    handlePrMerge(command, exitCode, patternsQueue);\n  } else if (/pytest|jest|vitest|npm\\s+test|yarn\\s+test|bun\\s+test|go\\s+test/.test(commandLower)) {\n    handleTestResult(command, exitCode, patternsQueue);\n  } else if (/npm\\s+run\\s+build|yarn\\s+build|cargo\\s+build|make|docker\\s+build/.test(commandLower)) {\n    handleBuildResult(command, exitCode, patternsQueue);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Skill Usage Optimizer - Track skill usage and suggest consolidation\n * Hook: PostToolUse (Skill)\n * Issue: #127 (CRITICAL)\n *\n * Tracks which skills are used and how often.\n * Stores metrics in .claude/feedback/skill-usage.json\n * Suggests skill consolidation if overlap detected.\n *\n * CC 2.1.9 Compliant: Uses additionalContext for suggestions\n * Version: 1.0.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../../lib/common.js';\n\ninterface SkillUsageFile {\n  version: string;\n  skills: Record<string, number>;\n  sessions: Record<string, string[]>;\n  last_updated: string;\n}\n\n// Skill overlap definitions for consolidation suggestions\nconst SKILL_OVERLAPS: Record<string, string> = {\n  'api-design-framework|fastapi-advanced': 'Both relate to API design. Consider using api-design-framework for patterns, fastapi-advanced for implementation.',\n  'sqlalchemy-2-async|database-schema-designer': 'Both relate to database. Use database-schema-designer for schema design, sqlalchemy-2-async for async patterns.',\n  'caching-strategies|performance-optimization': 'Both optimize performance. Consider consolidating caching queries.',\n  'auth-patterns|owasp-top-10': 'Both relate to security. auth-patterns for implementation, owasp-top-10 for validation.',\n  'asyncio-advanced|connection-pooling': 'Both relate to async. asyncio-advanced for patterns, connection-pooling for specific optimization.',\n};\n\n/**\n * Initialize usage file if it doesn't exist\n */\nfunction initUsageFile(usageFile: string): void {\n  if (!existsSync(usageFile)) {\n    try {\n      mkdirSync(require('path').dirname(usageFile), { recursive: true });\n      writeFileSync(usageFile, JSON.stringify({\n        version: '1.0',\n        skills: {},\n        sessions: {},\n        last_updated: '',\n      }));\n    } catch {\n      // Ignore init errors\n    }\n  }\n}\n\n/**\n * Load usage data\n */\nfunction loadUsageData(usageFile: string): SkillUsageFile {\n  initUsageFile(usageFile);\n\n  try {\n    return JSON.parse(readFileSync(usageFile, 'utf8'));\n  } catch {\n    return {\n      version: '1.0',\n      skills: {},\n      sessions: {},\n      last_updated: '',\n    };\n  }\n}\n\n/**\n * Update skill usage count\n */\nfunction updateUsage(skill: string, sessionId: string, usageFile: string): void {\n  const data = loadUsageData(usageFile);\n  const timestamp = new Date().toISOString();\n\n  // Update skill count\n  data.skills[skill] = (data.skills[skill] || 0) + 1;\n\n  // Track session usage\n  if (!data.sessions[sessionId]) {\n    data.sessions[sessionId] = [];\n  }\n  if (!data.sessions[sessionId].includes(skill)) {\n    data.sessions[sessionId].push(skill);\n  }\n\n  // Update timestamp\n  data.last_updated = timestamp;\n\n  try {\n    writeFileSync(usageFile, JSON.stringify(data, null, 2));\n    logHook('skill-usage-optimizer', `Updated usage for skill: ${skill} (session: ${sessionId})`);\n  } catch {\n    // Ignore write errors\n  }\n}\n\n/**\n * Get session skills for overlap detection\n */\nfunction getSessionSkills(sessionId: string, usageFile: string): string[] {\n  const data = loadUsageData(usageFile);\n  return data.sessions[sessionId] || [];\n}\n\n/**\n * Check for skill overlaps and suggest consolidation\n */\nfunction checkOverlaps(currentSkill: string, sessionSkills: string[]): string | null {\n  for (const [overlapKey, suggestion] of Object.entries(SKILL_OVERLAPS)) {\n    const [skill1, skill2] = overlapKey.split('|');\n\n    // Check if current skill and any session skill form an overlap\n    if (currentSkill === skill1 || currentSkill === skill2) {\n      const otherSkill = currentSkill === skill1 ? skill2 : skill1;\n\n      if (sessionSkills.includes(otherSkill)) {\n        logHook('skill-usage-optimizer', `Overlap detected: ${skill1} + ${skill2}`);\n        return suggestion;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get top used skills for context\n */\nfunction getUsageStats(usageFile: string): string {\n  const data = loadUsageData(usageFile);\n\n  // Get top 3 skills with counts\n  const entries = Object.entries(data.skills);\n  if (entries.length === 0) return '';\n\n  return entries\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([skill, count]) => `${skill}:${count}`)\n    .join(', ');\n}\n\n/**\n * Track and optimize skill usage\n */\nexport function skillUsageOptimizer(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n  const skillName = getField<string>(input, 'tool_input.skill') ||\n                   getField<string>(input, 'tool_name') || '';\n\n  // Filter: Only process Skill tool uses\n  if (toolName !== 'Skill' && !skillName?.startsWith('skills/')) {\n    if (!skillName) {\n      return outputSilentSuccess();\n    }\n  }\n\n  if (!skillName) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n  const usageFile = `${projectDir}/.claude/feedback/skill-usage.json`;\n  const sessionId = getSessionId();\n\n  // Update usage\n  updateUsage(skillName, sessionId, usageFile);\n\n  // Check for overlaps\n  const sessionSkills = getSessionSkills(sessionId, usageFile);\n  const overlapSuggestion = checkOverlaps(skillName, sessionSkills);\n\n  // Get usage stats\n  const usageStats = getUsageStats(usageFile);\n\n  // Build context message if we have suggestions or stats\n  let contextMsg = '';\n\n  if (overlapSuggestion) {\n    contextMsg = `Skill overlap: ${overlapSuggestion}`;\n    logHook('skill-usage-optimizer', `Suggesting consolidation for: ${skillName}`);\n  }\n\n  // Add stats info periodically (every 5th use of any skill)\n  const data = loadUsageData(usageFile);\n  const currentSkillCount = data.skills[skillName] || 0;\n\n  if (currentSkillCount > 0 && currentSkillCount % 5 === 0 && usageStats) {\n    if (contextMsg) {\n      contextMsg = `${contextMsg} | Top skills: ${usageStats}`;\n    } else {\n      contextMsg = `Top skills this project: ${usageStats}`;\n    }\n  }\n\n  // Output with context if we have something to say\n  if (contextMsg) {\n    // Truncate if too long\n    if (contextMsg.length > 200) {\n      contextMsg = contextMsg.substring(0, 197) + '...';\n    }\n\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        additionalContext: contextMsg,\n      },\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * File Lock Release - Release locks after successful Write/Edit\n * CC 2.1.7 Compliant: Self-contained hook with stdin reading and self-guard\n * Hook: PostToolUse (Write|Edit)\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../../types.js';\nimport { outputSilentSuccess, getField, getProjectDir, getSessionId, logHook } from '../../lib/common.js';\n\n/**\n * Check if multi-instance coordination is enabled\n */\nfunction isMultiInstanceEnabled(): boolean {\n  try {\n    execSync('which sqlite3', { stdio: 'ignore', timeout: 2000 });\n    const projectDir = getProjectDir();\n    const dbPath = `${projectDir}/.claude/coordination/.claude.db`;\n    return existsSync(dbPath);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Release file lock in coordination database\n */\nfunction releaseFileLock(filePath: string, instanceId: string): boolean {\n  const projectDir = getProjectDir();\n  const dbPath = `${projectDir}/.claude/coordination/.claude.db`;\n\n  if (!existsSync(dbPath)) {\n    return false;\n  }\n\n  try {\n    // Escape single quotes for SQLite\n    const escapedPath = filePath.replace(/'/g, \"''\");\n    const escapedInstance = instanceId.replace(/'/g, \"''\");\n\n    execSync(\n      `sqlite3 \"${dbPath}\" \"DELETE FROM file_locks WHERE file_path = '${escapedPath}' AND instance_id = '${escapedInstance}';\"`,\n      { stdio: 'ignore', timeout: 5000 }\n    );\n\n    logHook('file-lock-release', `Released lock for ${filePath}`);\n    return true;\n  } catch (error) {\n    logHook('file-lock-release', `Failed to release lock for ${filePath}: ${error}`);\n    return false;\n  }\n}\n\n/**\n * Get instance ID from environment or session\n */\nfunction getInstanceId(): string {\n  // Check environment first\n  if (process.env.INSTANCE_ID) {\n    return process.env.INSTANCE_ID;\n  }\n\n  // Check instance env file\n  const projectDir = getProjectDir();\n  const instanceEnv = `${projectDir}/.claude/.instance_env`;\n\n  if (existsSync(instanceEnv)) {\n    try {\n      const content = readFileSync(instanceEnv, 'utf8');\n      const match = content.match(/CLAUDE_INSTANCE_ID=[\"']?([^\"'\\n]+)/);\n      if (match) {\n        return match[1];\n      }\n    } catch {\n      // Ignore read errors\n    }\n  }\n\n  // Fall back to session ID\n  return getSessionId();\n}\n\n/**\n * Release file locks after Write/Edit operations\n */\nexport function fileLockRelease(input: HookInput): HookResult {\n  const toolName = input.tool_name || '';\n\n  // Self-guard: Only run for Write/Edit\n  if (toolName !== 'Write' && toolName !== 'Edit') {\n    return outputSilentSuccess();\n  }\n\n  // Self-guard: Only run if multi-instance coordination is enabled\n  if (!isMultiInstanceEnabled()) {\n    return outputSilentSuccess();\n  }\n\n  // Get file path\n  const filePath = getField<string>(input, 'tool_input.file_path') || '';\n\n  if (!filePath) {\n    return outputSilentSuccess();\n  }\n\n  // Skip coordination directory files\n  if (filePath.includes('/.claude/coordination/')) {\n    return outputSilentSuccess();\n  }\n\n  // Check for errors in tool result\n  const toolResult = String(getField<unknown>(input, 'tool_result') || '');\n  if (toolResult.includes('error') || toolResult.includes('Error')) {\n    // Keep lock on error, will auto-expire\n    return outputSilentSuccess();\n  }\n\n  // Release lock\n  const instanceId = getInstanceId();\n  releaseFileLock(filePath, instanceId);\n\n  return outputSilentSuccess();\n}\n", "/**\n * PostTool Hooks Entry Point\n *\n * Hooks that run after tool execution (PostToolUse)\n * Bundle: posttool.mjs (~45 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\nexport * from '../lib/git.js';\n\n// PostTool hooks - Root (13)\nimport { auditLogger } from '../posttool/audit-logger.js';\nimport { autoLint } from '../posttool/auto-lint.js';\nimport { contextBudgetMonitor } from '../posttool/context-budget-monitor.js';\nimport { coordinationHeartbeat } from '../posttool/coordination-heartbeat.js';\nimport { errorCollector } from '../posttool/error-collector.js';\nimport { errorSolutionSuggester } from '../posttool/error-solution-suggester.js';\nimport { errorTracker } from '../posttool/error-tracker.js';\nimport { mem0WebhookHandler } from '../posttool/mem0-webhook-handler.js';\nimport { memoryBridge } from '../posttool/memory-bridge.js';\nimport { realtimeSync } from '../posttool/realtime-sync.js';\nimport { sessionMetrics } from '../posttool/session-metrics.js';\nimport { skillEditTracker } from '../posttool/skill-edit-tracker.js';\nimport { calibrationTracker } from '../posttool/calibration-tracker.js';\n\n// PostTool/Write hooks (5)\nimport { codeStyleLearner } from '../posttool/write/code-style-learner.js';\nimport { coveragePredictor } from '../posttool/write/coverage-predictor.js';\nimport { namingConventionLearner } from '../posttool/write/naming-convention-learner.js';\nimport { readmeSync } from '../posttool/write/readme-sync.js';\nimport { releaseLockOnCommit } from '../posttool/write/release-lock-on-commit.js';\n\n// PostTool/Bash hooks (3)\nimport { issueProgressCommenter } from '../posttool/bash/issue-progress-commenter.js';\nimport { issueSubtaskUpdater } from '../posttool/bash/issue-subtask-updater.js';\nimport { patternExtractor } from '../posttool/bash/pattern-extractor.js';\n\n// PostTool/Skill hooks (1)\nimport { skillUsageOptimizer } from '../posttool/skill/skill-usage-optimizer.js';\n\n// PostTool/Write-Edit hooks (1)\nimport { fileLockRelease } from '../posttool/write-edit/file-lock-release.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * PostTool hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  // PostTool hooks - Root (13)\n  'posttool/audit-logger': auditLogger,\n  'posttool/auto-lint': autoLint,\n  'posttool/context-budget-monitor': contextBudgetMonitor,\n  'posttool/coordination-heartbeat': coordinationHeartbeat,\n  'posttool/error-collector': errorCollector,\n  'posttool/error-solution-suggester': errorSolutionSuggester,\n  'posttool/error-tracker': errorTracker,\n  'posttool/mem0-webhook-handler': mem0WebhookHandler,\n  'posttool/memory-bridge': memoryBridge,\n  'posttool/realtime-sync': realtimeSync,\n  'posttool/session-metrics': sessionMetrics,\n  'posttool/skill-edit-tracker': skillEditTracker,\n  'posttool/calibration-tracker': calibrationTracker,\n\n  // PostTool/Write hooks (5)\n  'posttool/write/code-style-learner': codeStyleLearner,\n  'posttool/write/coverage-predictor': coveragePredictor,\n  'posttool/write/naming-convention-learner': namingConventionLearner,\n  'posttool/write/readme-sync': readmeSync,\n  'posttool/write/release-lock-on-commit': releaseLockOnCommit,\n\n  // PostTool/Bash hooks (3)\n  'posttool/bash/issue-progress-commenter': issueProgressCommenter,\n  'posttool/bash/issue-subtask-updater': issueSubtaskUpdater,\n  'posttool/bash/pattern-extractor': patternExtractor,\n\n  // PostTool/Skill hooks (1)\n  'posttool/skill/skill-usage-optimizer': skillUsageOptimizer,\n\n  // PostTool/Write-Edit hooks (1)\n  'posttool/write-edit/file-lock-release': fileLockRelease,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": ";;;yPAkLO,SAASA,GAAYC,EAA0C,CACpE,OAAO,OAAOA,EAAM,SAAY,QAClC,CAEO,SAASC,GAAaD,EAA2C,CACtE,OAAO,OAAOA,EAAM,WAAc,UAAY,OAAOA,EAAM,SAAY,QACzE,CAEO,SAASE,GAAYF,EAA0C,CACpE,OACE,OAAOA,EAAM,WAAc,UAC3B,OAAOA,EAAM,YAAe,UAC5B,OAAOA,EAAM,YAAe,QAEhC,CAEO,SAASG,GAAYH,EAA0C,CACpE,OAAO,OAAOA,EAAM,WAAc,UAAYA,EAAM,UAAY,MAClE,CC/LA,OAAS,kBAAAI,EAAgB,cAAAC,EAAY,YAAAC,GAAU,cAAAC,GAAY,aAAAC,OAAiB,UAWrE,SAASC,GAAoB,CAClC,OAAI,QAAQ,IAAI,mBACP,GAAG,QAAQ,IAAI,IAAI,oBAErB,GAAGC,EAAc,CAAC,eAC3B,CAMO,SAASA,GAAwB,CACtC,OAAO,QAAQ,IAAI,oBAAsB,GAC3C,CAMO,SAASC,GAAwB,CACtC,OAAO,QAAQ,IAAI,oBAAsB,QAAQ,IAAI,oBAAsB,GAC7E,CAQO,SAASC,GAAuB,CACrC,OAAO,QAAQ,IAAI,mBAAqB,YAAY,QAAQ,GAAG,IAAI,KAAK,IAAI,CAAC,EAC/E,CAMO,SAASC,GAAgBC,EAA6B,CAC3D,GAAI,QAAQ,IAAI,kBACd,OAAO,QAAQ,IAAI,kBAGrB,GAAM,CAAE,SAAAC,CAAS,EAAI,EAAQ,oBAAoB,EACjD,GAAI,CACF,IAAMC,EAASD,EAAS,4BAA6B,CACnD,IAAKD,GAAcJ,EAAc,EACjC,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EAAE,KAAK,EACR,eAAQ,IAAI,kBAAoBM,EACzBA,CACT,MAAQ,CACN,MAAO,SACT,CACF,CAKO,SAASC,IAAsB,CACpC,OAAO,QAAQ,IAAI,sBAAwB,MAC7C,CAKO,SAASC,GAAUC,EAAqD,CAC7E,IAAMC,EAAS,CAAC,QAAS,OAAQ,OAAQ,OAAO,EAChD,OAAOA,EAAO,QAAQD,CAAK,GAAKC,EAAO,QAAQH,GAAY,CAAC,CAC9D,CASO,SAASI,GAAkC,CAChD,MAAO,CAAE,SAAU,GAAM,eAAgB,EAAK,CAChD,CAKO,SAASC,IAAgC,CAC9C,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAAE,mBAAoB,OAAQ,CACpD,CACF,CAKO,SAASC,GAAYC,EAA4B,CACtD,MAAO,CACL,SAAU,GACV,WAAYA,EACZ,mBAAoB,CAClB,mBAAoB,OACpB,yBAA0BA,CAC5B,CACF,CACF,CAMO,SAASC,GAAkBC,EAAyB,CACzD,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAClB,cAAe,cACf,kBAAmBA,CACrB,CACF,CACF,CAMO,SAASC,GAAoBD,EAAyB,CAC3D,MAAO,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAClB,cAAe,mBACf,kBAAmBA,CACrB,CACF,CACF,CAKO,SAASE,GAAuBF,EAAaG,EAAoC,CACtF,IAAMC,EAAqB,CACzB,SAAU,GACV,mBAAoB,CAClB,cAAe,aACf,kBAAmBJ,EACnB,mBAAoB,OACtB,CACF,EAEA,OAAIG,EACFC,EAAO,cAAgBD,EAEvBC,EAAO,eAAiB,GAGnBA,CACT,CAKO,SAASC,GAAYC,EAA6B,CACvD,MAAO,CAAE,SAAU,GAAM,cAAeA,CAAQ,CAClD,CAKO,SAASC,GAAcD,EAA6B,CACzD,MAAO,CAAE,SAAU,GAAM,cAAe,UAAUA,CAAO,EAAG,CAC9D,CAKO,SAASE,GAAWV,EAA4B,CACrD,MAAO,CACL,SAAU,GACV,WAAYA,EACZ,mBAAoB,CAClB,cAAe,aACf,mBAAoB,OACpB,yBAA0BA,CAC5B,CACF,CACF,CAMA,IAAMW,GAAwB,IAAM,KAC9BC,GAA0B,IAAM,KAKtC,SAASC,EAAcC,EAAiBC,EAAuB,CAC7D,GAAKlC,EAAWiC,CAAO,EAEvB,GAAI,CAEF,GADchC,GAASgC,CAAO,EACpB,KAAOC,EAAS,CACxB,IAAMC,EAAU,GAAGF,CAAO,QAAQ,KAAK,IAAI,CAAC,GAC5C/B,GAAW+B,EAASE,CAAO,CAC7B,CACF,MAAQ,CAER,CACF,CAKA,SAASC,EAAUC,EAAmB,CAC/BrC,EAAWqC,CAAG,GACjBlC,GAAUkC,EAAK,CAAE,UAAW,EAAK,CAAC,CAEtC,CAMO,SAASC,EAAQC,EAAkBZ,EAAiBb,EAA6C,QAAe,CAErH,GAAI,CAACD,GAAUC,CAAK,EAClB,OAGF,IAAM0B,EAASpC,EAAU,EACnB6B,EAAU,GAAGO,CAAM,aAEzB,GAAI,CACFJ,EAAUI,CAAM,EAChBR,EAAcC,EAASH,EAAqB,EAE5C,IAAMW,EAAY,IAAI,KAAK,EAAE,YAAY,EAAE,QAAQ,IAAK,GAAG,EAAE,MAAM,EAAG,EAAE,EACxE1C,EAAekC,EAAS,IAAIQ,CAAS,MAAM3B,EAAM,YAAY,CAAC,MAAMyB,CAAQ,KAAKZ,CAAO;AAAA,CAAI,CAC9F,MAAQ,CAER,CACF,CAMO,SAASe,GACdC,EACAxB,EACAyB,EACM,CACN,IAAMJ,EAASpC,EAAU,EACnB6B,EAAU,GAAGO,CAAM,2BAEzB,GAAI,CACFJ,EAAUI,CAAM,EAChBR,EAAcC,EAASF,EAAuB,EAE9C,IAAMU,EAAY,IAAI,KAAK,EAAE,YAAY,EACnCI,EAAYD,GAAqB,WAAa,QAAQ,IAAI,gBAAkB,UAC5EE,EAAaF,GAAqB,YAAcrC,EAAa,EAEnER,EACEkC,EACA,GAAGQ,CAAS,MAAME,CAAQ,MAAMxB,CAAM,WAAW0B,CAAQ,cAAcC,CAAS;AAAA,CAClF,CACF,MAAQ,CAER,CACF,CAUO,SAASC,IAA2B,CACzC,GAAI,CAEF,IAAMC,EAAmB,CAAC,EAEpBC,EAAM,OAAO,YAAY,GAAO,EAElCC,EACEC,EAAK,EAGL,CAAE,SAAAC,CAAS,EAAI,EAAQ,SAAS,EACtC,OACE,GAAI,CAEF,GADAF,EAAYE,EAASD,EAAIF,EAAK,EAAG,IAAS,IAAI,EAC1CC,IAAc,EAAG,MACrBF,EAAO,KAAK,OAAO,KAAKC,EAAI,SAAS,EAAGC,CAAS,CAAC,CAAC,CACrD,MAAQ,CACN,KACF,CAGF,IAAMN,EAAQ,OAAO,OAAOI,CAAM,EAAE,SAAS,MAAM,EAAE,KAAK,EAC1D,OAAKJ,EAIE,KAAK,MAAMA,CAAK,EAHd,CAAE,UAAW,GAAI,WAAYrC,EAAa,EAAG,WAAY,CAAC,CAAE,CAIvE,MAAQ,CACN,MAAO,CAAE,UAAW,GAAI,WAAYA,EAAa,EAAG,WAAY,CAAC,CAAE,CACrE,CACF,CAKO,SAAS8C,EAAYT,EAAkBU,EAA6B,CACzE,IAAMC,EAAQD,EAAK,QAAQ,MAAO,EAAE,EAAE,MAAM,GAAG,EAC3CE,EAAiBZ,EAErB,QAAWa,KAAQF,EAAO,CACxB,GAAIC,GAAU,KAA6B,OAC3CA,EAASA,EAAkCC,CAAI,CACjD,CAEA,OAAOD,CACT,CAUO,SAASE,GAAiBC,EAAyB,CACxD,OAAOA,EACJ,QAAQ,gBAAiB,GAAG,EAC5B,QAAQ,MAAO,GAAG,EAClB,QAAQ,OAAQ,GAAG,EACnB,KAAK,CACV,CAKO,SAASC,GAAYC,EAAqB,CAC/C,OAAOA,EAAI,QAAQ,sBAAuB,MAAM,CAClD,CC3WA,OAAS,YAAAC,MAAgB,qBAMlB,SAASC,GAAiBC,EAA6B,CAC5D,IAAMC,EAAMD,GAAcE,EAAc,EACxC,GAAI,CACF,OAAOC,EAAS,4BAA6B,CAC3C,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EAAE,KAAK,CACV,MAAQ,CACN,MAAO,SACT,CACF,CAKO,SAASG,GAAkBC,EAA0B,CAC1D,IAAMC,EAAgBD,GAAUN,GAAiB,EACjD,MAAO,CAAC,MAAO,OAAQ,QAAQ,EAAE,SAASO,CAAa,CACzD,CAKO,SAASC,GAAYP,EAA6B,CACvD,IAAMC,EAAMD,GAAcE,EAAc,EACxC,GAAI,CACF,OAAOC,EAAS,gCAAiC,CAC/C,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EAAE,KAAK,CACV,MAAQ,CACN,OAAOA,CACT,CACF,CAKO,SAASO,GAAUR,EAA8B,CACtD,IAAMC,EAAMD,GAAcE,EAAc,EACxC,GAAI,CACF,OAAAC,EAAS,0BAA2B,CAClC,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EACM,EACT,MAAQ,CACN,MAAO,EACT,CACF,CAKO,SAASQ,GAAaT,EAA6B,CACxD,IAAMC,EAAMD,GAAcE,EAAc,EACxC,GAAI,CACF,OAAOC,EAAS,qBAAsB,CACpC,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EAAE,KAAK,CACV,MAAQ,CACN,MAAO,EACT,CACF,CAKO,SAASS,GAAsBV,EAA8B,CAClE,OAAOS,GAAaT,CAAU,EAAE,OAAS,CAC3C,CAKO,SAASW,GAAiBX,EAA6B,CAC5D,IAAMC,EAAMD,GAAcE,EAAc,EACxC,GAAI,CAEF,OAAAC,EAAS,8BAA+B,CACtC,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EACM,MACT,MAAQ,CACN,GAAI,CAEF,OAAAE,EAAS,gCAAiC,CACxC,IAAKF,EACL,SAAU,OACV,QAAS,IACT,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EACM,QACT,MAAQ,CACN,MAAO,MACT,CACF,CACF,CAMO,SAASW,GAAmBP,EAA+B,CAEhE,IAAMQ,EAAW,CACf,gBACA,kBACA,cACA,cACA,eACA,UACA,UACA,QACF,EAEA,QAAWC,KAAWD,EAAU,CAC9B,IAAME,EAAQV,EAAO,MAAMS,CAAO,EAClC,GAAIC,EACF,OAAO,SAASA,EAAM,CAAC,EAAG,EAAE,CAEhC,CAEA,OAAO,IACT,CAMO,SAASC,GAAmBX,EAA+B,CAEhE,GAAID,GAAkBC,CAAM,EAC1B,OAAO,KAIT,IAAMY,EAAgB,CACpB,SACA,WACA,OACA,OACA,QACA,SACA,QACA,YACA,QACA,MACA,QACA,SACA,WACA,SACF,EAGA,OADuBA,EAAc,KAAMC,GAAWb,EAAO,WAAWa,CAAM,CAAC,EAM3Eb,EAAO,WAAW,QAAQ,GAAK,CAACO,GAAmBP,CAAM,EACpD,+EAGF,KARE,iDAAiDY,EAAc,KAAK,IAAI,CAAC,EASpF,CCtLA,OAAS,kBAAAE,GAAgB,cAAAC,EAAY,aAAAC,GAAW,YAAAC,GAAU,cAAAC,OAAkB,UAK5E,IAAMC,EAAgB,yBAKf,SAASC,EAAYC,EAA8B,CACxD,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAI,CAAC,OAAQ,OAAQ,MAAM,EAAE,SAASC,CAAQ,EAC5C,GAAI,CACF,GAAM,CAAE,aAAAC,EAAc,cAAAC,CAAc,EAAI,EAAQ,SAAS,EACrDC,EAAY,EAChB,GAAI,CACFA,EAAY,SAASF,EAAaJ,EAAe,MAAM,EAAE,KAAK,EAAG,EAAE,GAAK,CAC1E,MAAQ,CAER,CAIA,GAHAM,IACAD,EAAcL,EAAe,OAAOM,CAAS,CAAC,EAE1CA,EAAY,KAAO,EACrB,OAAOC,EAAoB,CAE/B,MAAQ,CAER,CAGF,IAAMC,EAAa,QAAQ,IAAI,oBAAsB,IAC/CC,EAAW,GAAGD,CAAU,0BAE9B,GAAI,CAEF,IAAME,EAAS,GAAGF,CAAU,gBACvBG,EAAWD,CAAM,GACpBE,GAAUF,EAAQ,CAAE,UAAW,EAAK,CAAC,EAIvCG,GAAcJ,EAAU,IAAM,IAAI,EAElC,IAAMK,EAAY,IAAI,KAAK,EAAE,YAAY,EAAE,QAAQ,IAAK,GAAG,EAAE,MAAM,EAAG,EAAE,EAGpEC,EAAU,GACd,OAAQZ,EAAU,CAChB,IAAK,OAAQ,CAEXY,GADYC,EAAiBd,EAAO,oBAAoB,GAAK,IAC/C,UAAU,EAAG,GAAG,EAC9B,KACF,CACA,IAAK,QACL,IAAK,OAAQ,CACXa,EAAUC,EAAiBd,EAAO,sBAAsB,GAAK,GAC7D,KACF,CACA,IAAK,OAAQ,CACXa,EAAUC,EAAiBd,EAAO,0BAA0B,GAAK,GACjE,KACF,CACF,CAEA,IAAMe,EAAWF,EACb,IAAID,CAAS,KAAKX,CAAQ,MAAMY,CAAO;AAAA,EACvC,IAAID,CAAS,KAAKX,CAAQ;AAAA,EAE9Be,GAAeT,EAAUQ,CAAQ,CACnC,MAAQ,CAER,CAEA,OAAOV,EAAoB,CAC7B,CAKA,SAASM,GAAcM,EAAiBC,EAAwB,CAC9D,GAAKT,EAAWQ,CAAO,EAEvB,GAAI,CAEF,GADcE,GAASF,CAAO,EACpB,KAAOC,EAAU,CACzB,IAAME,EAAU,GAAGH,CAAO,QAAQ,KAAK,IAAI,CAAC,GAC5CI,GAAWJ,EAASG,CAAO,CAC7B,CACF,MAAQ,CAER,CACF,CC3FA,OAAS,cAAAE,OAAkB,UAC3B,OAAS,YAAAC,MAAgB,qBAOzB,SAASC,GAAYC,EAAiC,CAEpD,OADYA,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,EACtC,CACX,IAAK,KACH,MAAO,SACT,IAAK,KACL,IAAK,MACH,MAAO,aACT,IAAK,KACL,IAAK,MACH,MAAO,aACT,IAAK,OACH,MAAO,OACT,IAAK,MACL,IAAK,OACH,MAAO,MACT,QACE,OAAO,IACX,CACF,CAKA,SAASC,EAAcC,EAAsB,CAC3C,GAAI,CACF,OAAAC,EAAS,SAASD,CAAG,GAAI,CAAE,MAAO,QAAS,CAAC,EACrC,EACT,MAAQ,CACN,MAAO,EACT,CACF,CAKO,SAASE,EAASC,EAA8B,CACrD,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,SAAWA,IAAa,OACvC,OAAOC,EAAoB,EAG7B,IAAMP,EAAWQ,EAAiBH,EAAO,sBAAsB,GAAK,GAGpE,GAAI,CAACL,GAAYA,EAAS,SAAS,WAAW,GAC1CA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,OAAO,EAC3B,OAAOO,EAAoB,EAI7B,IAAME,EAAa,QAAQ,IAAI,oBAAsB,IAC/CC,EAAWV,EAAS,WAAW,GAAG,EAAIA,EAAW,GAAGS,CAAU,IAAIT,CAAQ,GAEhF,GAAI,CAACW,GAAWD,CAAQ,EACtB,OAAOH,EAAoB,EAI7B,GAAI,QAAQ,IAAI,iBAAmB,IACjC,OAAOA,EAAoB,EAG7B,IAAMK,EAAWb,GAAYC,CAAQ,EACrC,GAAI,CAACY,EACH,OAAOL,EAAoB,EAG7B,IAAIM,EAAa,EACbC,EAAe,GAEnB,GAAI,CACF,OAAQF,EAAU,CAChB,IAAK,SACH,GAAIX,EAAc,MAAM,EAAG,CACzB,GAAI,CACF,IAAMc,EAAYZ,EAAS,kDAAkDO,CAAQ,SAAU,CAC7F,SAAU,OACV,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EACGK,IACFF,EAAaE,EAAU,MAAM;AAAA,CAAI,EAAE,OAAO,OAAO,EAAE,OACnDZ,EAAS,qDAAqDO,CAAQ,gBAAiB,CACrF,MAAO,QACT,CAAC,EACDI,EAAe,GAEnB,MAAQ,CAER,CACA,GAAI,CACFX,EAAS,2BAA2BO,CAAQ,gBAAiB,CAAE,MAAO,QAAS,CAAC,CAClF,MAAQ,CAER,CACF,CACA,MAEF,IAAK,aACL,IAAK,aACH,GAAIT,EAAc,OAAO,EACvB,GAAI,CACF,IAAMe,EAAWb,EAAS,mCAAmCO,CAAQ,SAAU,CAC7E,SAAU,OACV,MAAO,CAAC,OAAQ,OAAQ,MAAM,CAChC,CAAC,EACGM,EAAS,SAAS,OAAO,IAC3BF,EAAe,IAEbE,EAAS,SAAS,OAAO,IAC3BH,GAAcG,EAAS,MAAM,QAAQ,GAAK,CAAC,GAAG,OAElD,MAAQ,CAER,CAEF,MAEF,IAAK,OACL,IAAK,MACH,GAAIf,EAAc,OAAO,EACvB,GAAI,CACFE,EAAS,oCAAoCO,CAAQ,gBAAiB,CACpE,MAAO,QACT,CAAC,EACDI,EAAe,EACjB,MAAQ,CAER,CAEF,KACJ,CACF,OAASG,EAAO,CACdC,EAAQ,YAAa,UAAUD,CAAK,EAAE,CACxC,CAGA,GAAIH,GAAgBD,EAAa,EAAG,CAClC,IAAMM,EAAWnB,EAAS,MAAM,GAAG,EAAE,IAAI,EACzC,MAAO,CACL,SAAU,GACV,cAAe,4BAA4Ba,CAAU,iBAAiBM,CAAQ,EAChF,CACF,CAEA,OAAOZ,EAAoB,CAC7B,CC9JA,OAAS,cAAAa,EAAY,gBAAAC,GAAc,iBAAAC,EAAe,YAAAC,GAAU,aAAAC,OAAiB,UAK7E,IAAMC,EAAe,KACfC,EAAmB,GACnBC,GAAkB,GAClBC,GAAoB,GAK1B,SAASC,GAAeC,EAA0B,CAChD,GAAI,CAACC,EAAWD,CAAQ,EAAG,MAAO,GAElC,GAAI,CACF,IAAME,EAAQC,GAASH,CAAQ,EAC/B,OAAO,KAAK,MAAME,EAAM,KAAO,CAAC,CAClC,MAAQ,CACN,MAAO,EACT,CACF,CAKA,SAASE,GAAyB,CAEhC,IAAMC,EAAa,GADAC,EAAc,CACD,WAE1BC,EAAoB,CACxB,GAAGF,CAAU,iBACb,GAAGA,CAAU,sBACb,GAAGA,CAAU,wBACb,GAAGA,CAAU,kCACf,EAEIG,EAAQ,EACZ,QAAWC,KAAQF,EACjBC,GAAST,GAAeU,CAAI,EAG9B,OAAOD,CACT,CAKA,SAASE,IAAoC,CAC3C,IAAMC,EAAa,SAAS,QAAQ,IAAI,oBAAsB,SAAU,EAAE,EAE1E,OAAO,KAAK,MAAMA,GAAc,IADR,IACiC,GAAG,CAC9D,CAKA,SAASC,GAAeC,EAAgC,CACtD,IAAMC,EAAkBJ,GAA0B,EAClD,OAAII,IAAoB,EAAU,GAEfD,EAAgBC,EACfhB,EACtB,CAKA,SAASiB,GAAoBC,EAAsBH,EAA6B,CAE9E,IAAMI,EAAY,+BADAC,EAAa,CAC2B,QACpDJ,EAAkBJ,GAA0B,EAE5CS,EAAQ,CACZ,aAAcH,EACd,eAAgBH,EAChB,iBAAkBC,EAClB,WAAY,IAAI,KAAK,EAAE,YAAY,EACnC,OAAQE,EAAc,0BAA4B,uBACpD,EAEA,GAAI,CACFI,EAAcH,EAAW,KAAK,UAAUE,EAAO,KAAM,CAAC,CAAC,CACzD,MAAQ,CAER,CAEAE,EAAQ,yBACN,kCAAkCL,CAAW,YAAYH,CAAa,YAAYC,CAAe,EAAE,CACvG,CAKA,SAASQ,IAAwB,CAE/B,IAAMC,EAAc,GADDjB,EAAc,CACA,8BAEjC,GAAKL,EAAWsB,CAAW,EAE3B,GAAI,CACF,IAAMC,EAAU,KAAK,MAAMC,GAAaF,EAAa,MAAM,CAAC,EAEtDG,EAAa,CACjB,WAAYF,EAAQ,WACpB,QAASA,EAAQ,QACjB,aAAcA,EAAQ,aACtB,YAAaA,EAAQ,YAAc,CAAC,GAAG,MAAM,EAAE,EAC/C,SAAUA,EAAQ,SAClB,YAAa,GACb,eAAgB,IAAI,KAAK,EAAE,YAAY,EACvC,yBAA0BA,EAAQ,eAAiB,CAAC,GAAG,OACvD,qBAAsBA,EAAQ,wBAA0B,CAAC,GAAG,MAC9D,EAEAJ,EAAcG,EAAa,KAAK,UAAUG,EAAY,KAAM,CAAC,CAAC,EAC9DL,EAAQ,yBAA0B,0BAA0B,CAC9D,MAAQ,CAER,CACF,CAKA,SAASM,IAA4B,CACnC,IAAMC,EAAatB,EAAc,EAC3BuB,EAAgB,GAAGD,CAAU,2CAEnC,GAAK3B,EAAW4B,CAAa,EAE7B,GAAI,CACF,IAAML,EAAU,KAAK,MAAMC,GAAaI,EAAe,MAAM,CAAC,EACxDC,EAAYN,EAAQ,WAAa,CAAC,EAExC,GAAIM,EAAU,OAAS,GAAI,CACzBT,EAAQ,yBAA0B,+CAA+C,EAGjF,IAAMU,EAAa,GAAGH,CAAU,6BAChCI,GAAUD,EAAY,CAAE,UAAW,EAAK,CAAC,EAGzC,IAAME,EAAO,IAAI,KACXC,EAAc,GAAGH,CAAU,IAAIE,EAAK,YAAY,CAAC,IAAI,OAAOA,EAAK,SAAS,EAAI,CAAC,EAAE,SAAS,EAAG,GAAG,CAAC,QACvGb,EAAcc,EAAa,KAAK,UAAUJ,EAAU,MAAM,EAAG,EAAE,EAAG,KAAM,CAAC,CAAC,EAG1EN,EAAQ,UAAYM,EAAU,MAAM,EAAE,EACtCV,EAAcS,EAAe,KAAK,UAAUL,EAAS,KAAM,CAAC,CAAC,EAE7DH,EAAQ,yBAA0B,YAAYS,EAAU,OAAS,CAAC,iBAAiBI,CAAW,EAAE,CAClG,CACF,MAAQ,CAER,CACF,CAKO,SAASC,GAAqBC,EAA+B,CAClE,GAAI,CACF,IAAMvB,EAAgBT,EAAe,EAG/BiC,EAAaxB,EAAgBlB,EAC7B2C,EAAe,KAAK,MAAMD,EAAa,GAAG,EAEhDhB,EAAQ,yBACN,kBAAkBR,CAAa,MAAMlB,CAAY,YAAY2C,CAAY,IAAI,EAG/E,IAAMC,EAAW3B,GAAeC,CAAa,EAI7C,GAHAE,GAAoBwB,EAAU1B,CAAa,EAGvCwB,EAAazC,EAAkB,CACjCyB,EAAQ,yBACN,2BAA2BiB,CAAY,yBAAyB1C,EAAmB,GAAG,IAAI,EAC5FyB,EAAQ,yBAA0B,2BAA2B,EAG7DC,GAAgB,EAGhBK,GAAoB,EAGpB,IAAMa,EAAYpC,EAAe,EAC3BqC,EAAWD,EAAY7C,EACvB+C,EAAa,KAAK,MAAMD,EAAW,GAAG,EAE5CpB,EAAQ,yBACN,sBAAsBmB,CAAS,MAAM7C,CAAY,YAAY+C,CAAU,IAAI,EAEzED,EAAW5C,GACbwB,EAAQ,yBACN,yDAAyD,EAE3DA,EAAQ,yBAA0B,0CAA0C,CAEhF,MACEA,EAAQ,yBAA0B,qDAAqD,CAE3F,OAASsB,EAAO,CACdtB,EAAQ,yBAA0B,UAAUsB,CAAK,EAAE,CACrD,CAEA,OAAOC,EAAoB,CAC7B,CCxNA,OAAS,cAAAC,GAAY,gBAAAC,OAAoB,UACzC,OAAS,YAAAC,OAAgB,qBAOlB,SAASC,GAAsBC,EAA+B,CACnE,IAAMC,EAAaC,EAAc,EAC3BC,EAAW,GAAGF,CAAU,4CAG9B,GAAI,CAACG,GAAWD,CAAQ,EACtB,OAAOE,EAAoB,EAG7B,GAAI,CAIF,IAAMC,EAAc,GAAGL,CAAU,yBAC7BM,EAAa,QAAQ,IAAI,mBAAqB,YAAY,QAAQ,GAAG,GAEzE,GAAIH,GAAWE,CAAW,EAAG,CAE3B,IAAME,EADUC,GAAaH,EAAa,MAAM,EAC1B,MAAM,oCAAoC,EAC5DE,IACFD,EAAaC,EAAM,CAAC,EAExB,CAGID,GACFG,GACE,WAAWP,CAAQ,qBAAqBI,CAAU,wCAClD,CACE,MAAO,YACP,MAAO,SACP,QAAS,GACX,CACF,CAEJ,OAASI,EAAO,CAEdC,EAAQ,yBAA0B,4BAA4BD,CAAK,EAAE,CACvE,CAEA,OAAON,EAAoB,CAC7B,CC9CA,OAAS,cAAAQ,GAAY,kBAAAC,GAAgB,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,GAAW,YAAAC,GAAU,cAAAC,OAAkB,UACzG,OAAS,cAAAC,OAAkB,cAK3B,IAAMC,GAAiB,6HAKvB,SAASC,GAAcC,EAAiBC,EAAwB,CAC9D,GAAKC,GAAWF,CAAO,EAEvB,GAAI,CAEF,GADcG,GAASH,CAAO,EACpB,KAAOC,EAAU,CACzB,IAAMG,EAAU,GAAGJ,CAAO,QAAQ,KAAK,IAAI,CAAC,GAC5CK,GAAWL,EAASI,CAAO,CAC7B,CACF,MAAQ,CAER,CACF,CAKO,SAASE,GAAeC,EAA8B,CAC3D,IAAMC,EAAWD,EAAM,WAAa,GAC9BE,EAAYC,EAAa,EACzBC,EAAY,IAAI,KAAK,EAAE,YAAY,EAGnCC,EAAa,OAAOC,EAAkBN,EAAO,aAAa,GAAKA,EAAM,aAAe,EAAE,EACtFO,EAAWP,EAAM,WAAa,EAC9BQ,EAAY,OAAOR,EAAM,YAAcM,EAAiBN,EAAO,OAAO,GAAK,EAAE,EAG/ES,EAAU,GACVC,EAAY,GACZC,EAAe,GAiBnB,GAdIJ,IAAa,GAAKA,IAAa,SACjCE,EAAU,GACVC,EAAY,YACZC,EAAe,cAAcJ,CAAQ,IAInCC,IACFC,EAAU,GACVC,EAAY,aACZC,EAAeH,GAIbjB,GAAe,KAAKc,CAAU,EAAG,CACnCI,EAAU,GACVC,EAAYA,GAAa,iBAEzB,IAAME,EAAaP,EAAW,MAAM;AAAA,CAAI,EAAE,OAAOQ,GAAQtB,GAAe,KAAKsB,CAAI,CAAC,EAClFF,EAAeA,GAAgBC,EAAW,CAAC,GAAK,EAClD,CAGA,GAAIH,EAAS,CACX,IAAMK,EAAaC,EAAc,EAC3BC,EAAW,GAAGF,CAAU,6BAE9B,GAAI,CACFG,GAAU,GAAGH,CAAU,gBAAiB,CAAE,UAAW,EAAK,CAAC,EAG3DtB,GAAcwB,EAAU,IAAO,IAAI,EAGnC,IAAME,EAAYlB,EAAM,YAAc,CAAC,EACjCmB,EAAYC,GAAW,KAAK,EAAE,OAAO,KAAK,UAAUF,CAAS,CAAC,EAAE,OAAO,KAAK,EAG5EG,EAAwBV,EAAa,UAAU,EAAG,GAAG,EACrDW,EAAsBjB,EAAW,UAAU,EAAG,GAAI,EAcxDkB,GAAeP,EAAU,KAAK,UAXV,CAClB,UAAAZ,EACA,KAAMH,EACN,WAAYC,EACZ,WAAYQ,EACZ,cAAeW,EACf,WAAYF,EACZ,WAAYD,EACZ,eAAgBI,CAClB,CAEmD,EAAI;AAAA,CAAI,EAG3D,IAAME,EAAc,kCACpB,GAAI,CACF,IAAIC,EAAU,CAAE,YAAa,EAAG,gBAAiB,GAAI,gBAAiB,EAAG,EACrE9B,GAAW6B,CAAW,IACxBC,EAAU,KAAK,MAAMC,GAAaF,EAAa,MAAM,CAAC,GAExDC,EAAQ,aAAeA,EAAQ,aAAe,GAAK,EACnDA,EAAQ,gBAAkBxB,EAC1BwB,EAAQ,gBAAkBrB,EAC1BuB,GAAcH,EAAa,KAAK,UAAUC,EAAS,KAAM,CAAC,CAAC,CAC7D,MAAQ,CAER,CAEAG,EAAQ,kBAAmB,mBAAmB3B,CAAQ,MAAMS,CAAS,MAAMC,EAAa,UAAU,EAAG,GAAG,CAAC,EAAE,CAC7G,MAAQ,CAENiB,EAAQ,kBAAmB,qBAAqB3B,CAAQ,MAAMS,CAAS,EAAE,CAC3E,CACF,CAEA,OAAOmB,EAAoB,CAC7B,CCxHA,OAAS,cAAAC,EAAY,gBAAAC,EAAc,iBAAAC,EAAe,aAAAC,OAAiB,UAGnE,OAAS,cAAAC,OAAkB,cAG3B,IAAMC,GAAoB,IACpBC,GAAyB,GACzBC,GAAa,EA2BnB,SAASC,GAAcC,EAA2B,CAChD,IAAMC,EAAWD,EAAM,UACjBE,EAAYF,EAAM,YAAcG,EAAiBH,EAAO,OAAO,GAAK,GACpEI,EAAa,OAAOD,EAAkBH,EAAO,aAAa,GAAKA,EAAM,aAAe,EAAE,EAc5F,MAXI,GAA0BC,GAAa,MAAQA,IAAa,GAK5DC,GAKiB,8GACJ,KAAKE,CAAU,EAKlC,CAKA,SAASC,GAAkBC,EAAmBC,EAA4C,CACxF,GAAI,CAACC,EAAWD,CAAa,EAC3B,OAAAE,EAAQ,2BAA4B,6BAA6BF,CAAa,EAAE,EACzE,KAGT,GAAI,CACF,IAAMG,EAAyB,KAAK,MAAMC,EAAaJ,EAAe,MAAM,CAAC,EACvEK,EAAaN,EAAU,YAAY,EAEzC,QAAWO,KAAWH,EAAQ,UAAY,CAAC,EACzC,GAAIG,EAAQ,MACV,GAAI,CAEF,GADc,IAAI,OAAOA,EAAQ,MAAO,GAAG,EACjC,KAAKD,CAAU,EACvB,OAAOC,CAEX,MAAQ,CAER,CAGN,MAAQ,CAER,CAEA,OAAO,IACT,CAKA,SAASC,GAAcC,EAAmBC,EAAsBC,EAA4B,CAE1F,GAAI,CAACT,EAAWS,CAAS,EACvB,GAAI,CACFC,GAAU,EAAQ,MAAM,EAAE,QAAQD,CAAS,EAAG,CAAE,UAAW,EAAK,CAAC,EACjEE,EAAcF,EAAW,KAAK,UAAU,CAAE,YAAa,CAAC,EAAG,aAAc,CAAE,CAAC,CAAC,CAC/E,MAAQ,CACN,MAAO,EACT,CAGF,GAAI,CACF,IAAMG,EAAmB,KAAK,MAAMT,EAAaM,EAAW,MAAM,CAAC,EAG7DI,EAAiB1B,GAAW,KAAK,EACpC,OAAO,GAAGoB,CAAS,IAAIC,EAAa,UAAU,EAAG,GAAG,CAAC,EAAE,EACvD,OAAO,KAAK,EAGTM,GAAgBF,EAAM,cAAgB,GAAK,EACjDA,EAAM,aAAeE,EAGrB,IAAMC,EAAkBH,EAAM,YAAYC,CAAc,GAAG,cAAgB,EAG3E,OAAIE,IAAoB,GAAMD,EAAeC,GAAoB1B,IAE/DuB,EAAM,YAAYC,CAAc,EAAI,CAAE,WAAYN,EAAW,aAAcO,CAAa,EACxFH,EAAcF,EAAW,KAAK,UAAUG,EAAO,KAAM,CAAC,CAAC,EAChD,KAGTD,EAAcF,EAAW,KAAK,UAAUG,EAAO,KAAM,CAAC,CAAC,EAChD,GACT,MAAQ,CACN,MAAO,EACT,CACF,CAKA,SAASI,GAAoBC,EAAmBC,EAA2B,CACzE,IAAMC,EAAY,GAAGD,CAAS,IAAID,CAAS,YAE3C,GAAI,CAACjB,EAAWmB,CAAS,EAAG,MAAO,GAEnC,GAAI,CAGF,IAAMC,EAFUjB,EAAagB,EAAW,MAAM,EAEb,MAAM,uBAAuB,EAC9D,GAAIC,EAAkB,CACpB,IAAMC,EAAYD,EAAiB,CAAC,EAAE,MAAM,qBAAqB,EACjE,GAAIC,EACF,OAAOA,EAAU,CAAC,EAAE,KAAK,CAE7B,CACF,MAAQ,CAER,CAEA,MAAO,EACT,CAKA,SAASC,GAAmBjB,EAAuBN,EAAuBmB,EAA2B,CACnG,IAAMK,EAAWlB,EAAQ,UAAY,GAG/BmB,EAAgBnB,EAAQ,QAAU,CAAC,EAGrCoB,EAA2B,CAAC,EAChC,GAAIF,GAAYvB,EAAWD,CAAa,EACtC,GAAI,CAEF0B,EAD+B,KAAK,MAAMtB,EAAaJ,EAAe,MAAM,CAAC,EACpD,aAAawB,CAAQ,GAAG,gBAAkB,CAAC,CACtE,MAAQ,CAER,CAIF,IAAMG,EAAY,CAAC,GAAG,IAAI,IAAI,CAAC,GAAGF,EAAe,GAAGC,CAAc,CAAC,CAAC,EAAE,MAAM,EAAGnC,EAAU,EAEzF,GAAIoC,EAAU,SAAW,EAAG,MAAO,GAEnC,IAAIC,EAAU;AAAA;AAAA,EAEd,QAAWC,KAASF,EAAW,CAC7B,IAAMG,EAAOb,GAAoBY,EAAOV,CAAS,EAC7CW,EACFF,GAAW,OAAOC,CAAK,OAAOC,CAAI;AAAA,EAElCF,GAAW,OAAOC,CAAK;AAAA,CAE3B,CAEA,OAAAD,GAAW,mEAEJA,CACT,CAKA,SAASG,GAAuBzB,EAAuBN,EAAuBmB,EAA2B,CACvG,IAAMa,EAAQ1B,EAAQ,UAAU,OAAS,yBACnC2B,EAAQ3B,EAAQ,UAAU,OAAS,CAAC,EAEtC4B,EAAM;AAAA;AAAA,EACVA,GAAO,KAAKF,CAAK;AAAA;AAAA,EAEbC,EAAM,OAAS,IACjBC,GAAO;AAAA;AAAA,EACPD,EAAM,QAAQ,CAACE,EAAMC,IAAM,CACzBF,GAAO,KAAKE,EAAI,CAAC,KAAKD,CAAI;AAAA,CAC5B,CAAC,EACDD,GAAO;AAAA,GAIT,IAAMG,EAAgBd,GAAmBjB,EAASN,EAAemB,CAAS,EAC1E,OAAIkB,IACFH,GAAOG,GAILH,EAAI,OAAS7C,KACf6C,EAAMA,EAAI,UAAU,EAAG7C,GAAoB,EAAE,EAAI;AAAA;AAAA,cAG5C6C,CACT,CAKO,SAASI,GAAuB7C,EAA8B,CAEnE,GAAIA,EAAM,YAAc,OACtB,OAAO8C,EAAoB,EAI7B,GAAI,CAAC/C,GAAcC,CAAK,EACtB,OAAO8C,EAAoB,EAG7BrC,EAAQ,2BAA4B,4CAA4C,EAGhF,IAAML,EAAa,OAAOD,EAAkBH,EAAO,aAAa,GAAKA,EAAM,aAAe,EAAE,EAIxFM,EAHc,OAAON,EAAM,YAAcG,EAAiBH,EAAO,OAAO,GAAK,EAAE,GAGtDI,EAG7B,GAFAE,EAAYA,EAAU,UAAU,EAAG,GAAI,EAEnC,CAACA,EACH,OAAAG,EAAQ,2BAA4B,qBAAqB,EAClDqC,EAAoB,EAG7B,IAAMC,EAAaC,EAAc,EAC3BzC,EAAgB,GAAGwC,CAAU,sCAC7BrB,EAAY,GAAGqB,CAAU,UAEzB9B,EAAY,iCADAgC,EAAa,CAC6B,QAGtDC,EAAiB7C,GAAkBC,EAAWC,CAAa,EAEjE,GAAI,CAAC2C,EACH,OAAAzC,EAAQ,2BAA4B,2BAA2B,EACxDqC,EAAoB,EAM7B,GAHArC,EAAQ,2BAA4B,oBAAoByC,EAAe,EAAE,EAAE,EAGvE,CAACpC,GAAcoC,EAAe,GAAI5C,EAAWW,CAAS,EACxD,OAAAR,EAAQ,2BAA4B,8CAA8CyC,EAAe,EAAE,EAAE,EAC9FJ,EAAoB,EAI7B,IAAMK,EAAoBb,GAAuBY,EAAgB3C,EAAemB,CAAS,EAEzF,OAAIyB,GACF1C,EAAQ,2BAA4B,qDAAqD,EAElF,CACL,SAAU,GACV,mBAAoB,CAClB,kBAAmB0C,CACrB,CACF,GAGKL,EAAoB,CAC7B,CChTA,OAAS,cAAAM,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,kBAAAC,GAAgB,aAAAC,OAAiB,UAKnF,IAAMC,GAAmB,wDAKlB,SAASC,GAAaC,EAA8B,CACzD,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,OAAQ,CACvB,IAAMC,EAAUC,EAAiBH,EAAO,oBAAoB,GAAK,GACjE,GAAIF,GAAiB,KAAKI,CAAO,EAC/B,OAAOE,EAAoB,CAE/B,CAEA,IAAMC,EAAY,OAAOL,EAAM,YAAc,EAAE,EACzCM,EAAWN,EAAM,UAGvB,GAAI,CAACK,IAAcC,IAAa,GAAKA,IAAa,QAAaA,IAAa,MAC1E,OAAOF,EAAoB,EAG7BG,EAAQ,gBAAiB,UAAUN,CAAQ,kBAAkBK,CAAQ,GAAG,EAGxE,IAAME,EAAc,mCACpB,GAAI,CACF,IAAIC,EAAU,CAAE,MAAO,CAAC,EAAG,OAAQ,EAAG,SAAU,CAAE,EAClD,GAAIC,GAAWF,CAAW,EAAG,CAC3B,IAAMG,EAAUC,GAAaJ,EAAa,MAAM,EAAE,KAAK,EACnDG,IACFF,EAAU,KAAK,MAAME,CAAO,EAEhC,CACAF,EAAQ,QAAUA,EAAQ,QAAU,GAAK,EACzCI,GAAcL,EAAa,KAAK,UAAUC,EAAS,KAAM,CAAC,CAAC,CAC7D,MAAQ,CAER,CAGA,IAAMK,EAAaC,EAAc,EAC3BC,EAAW,GAAGF,CAAU,2BAE9B,GAAI,CACFG,GAAU,GAAGH,CAAU,gBAAiB,CAAE,UAAW,EAAK,CAAC,EAC3D,IAAMI,EAAY,IAAI,KAAK,EAAE,YAAY,EAAE,QAAQ,IAAK,GAAG,EAAE,MAAM,EAAG,EAAE,EAClEC,EAAed,EAAU,UAAU,EAAG,GAAG,EAC/Ce,GAAeJ,EAAU,IAAIE,CAAS,KAAKjB,CAAQ,YAAYK,CAAQ,MAAMa,CAAY;AAAA,CAAI,CAC/F,MAAQ,CAER,CAEA,OAAOf,EAAoB,CAC7B,CChDO,SAASiB,GAAmBC,EAA8B,CAC/DC,EAAQ,uBAAwB,+BAA+B,EAE/D,IAAMC,EAAWF,EAAM,WAAa,GAC9BG,EAAUC,EAAiBJ,EAAO,oBAAoB,GAAK,GAGjE,GAAIE,IAAa,QAAU,CAACC,EAAQ,SAAS,qBAAqB,EAChE,OAAOE,EAAoB,EAI7B,IAAMC,EAAeF,EAAiBJ,EAAO,aAAa,GAAK,GAE/D,GAAI,CAACM,EACH,OAAAL,EAAQ,uBAAwB,qCAAqC,EAC9DI,EAAoB,EAG7B,GAAI,CAEF,IAAIE,EACJ,GAAI,CACFA,EAAY,KAAK,MAAMD,CAAY,CACrC,MAAQ,CACN,OAAAL,EAAQ,uBAAwB,4BAA4B,EACrDI,EAAoB,CAC7B,CAGA,IAAMG,EAAaD,EAAU,QAAoC,YAChDA,EAAU,YAAc,GACnCE,EAAYF,EAAU,QAAoC,WAC/CA,EAAU,QAAoC,IAAM,GAKrE,OAHAN,EAAQ,uBAAwB,6BAA6BO,CAAS,aAAaC,CAAQ,GAAG,EAGtFD,EAAW,CACjB,IAAK,iBACHP,EAAQ,uBAAwB,qCAAqC,EAGrE,MAEF,IAAK,iBACHA,EAAQ,uBAAwB,wCAAwC,EAExE,MAEF,IAAK,iBACHA,EAAQ,uBAAwB,yCAAyC,EAEzE,MAEF,QACEA,EAAQ,uBAAwB,uBAAuBO,CAAS,EAAE,EAClE,KACJ,CACF,OAASE,EAAO,CACdT,EAAQ,uBAAwB,6BAA6BS,CAAK,EAAE,CACtE,CAEA,OAAOL,EAAoB,CAC7B,CClEA,OAAS,cAAAM,OAAkB,UAK3B,IAAMC,GAA0C,CAC9C,WAAY,0MACZ,QAAS,8KACT,SAAU,iEACV,aAAc,qHACd,SAAU,mFACV,SAAU,2FACZ,EAiBA,SAASC,GAAwBC,EAAwB,CACvD,IAAMC,EAAYD,EAAK,YAAY,EAC7BE,EAAqB,CAAC,EAE5B,OAAW,CAACC,EAAYC,CAAO,IAAK,OAAO,QAAQN,EAAe,EAAG,CACnE,IAAMO,EAAUJ,EAAU,MAAMG,CAAO,EACvC,GAAIC,EACF,QAAWC,IAAS,CAAC,GAAG,IAAI,IAAID,CAAO,CAAC,EAAE,MAAM,EAAG,CAAC,EAAG,CAErD,IAAME,EAAaD,EAChB,MAAM,SAAS,EACf,IAAIE,GAAQA,EAAK,OAAO,CAAC,EAAE,YAAY,EAAIA,EAAK,MAAM,CAAC,EAAE,YAAY,CAAC,EACtE,KAAK,GAAG,EAGPC,EAAc,0BACd,YAAY,KAAKR,CAAS,GAAKA,EAAU,SAASK,CAAK,EACzDG,EAAc,6BACL,UAAU,KAAKR,CAAS,GAAKA,EAAU,SAASK,CAAK,EAC9DG,EAAc,4BACL,aAAa,KAAKR,CAAS,GAAKA,EAAU,SAASK,CAAK,IACjEG,EAAc,2BAGhBP,EAAS,KAAK,CACZ,KAAMK,EACN,WAAAJ,EACA,aAAc,CAACM,CAAW,CAC5B,CAAC,CACH,CAEJ,CAEA,OAAOP,CACT,CAKA,SAASQ,GAAyBV,EAAcE,EAAgC,CAC9E,IAAMD,EAAYD,EAAK,YAAY,EAC7BW,EAAwB,CAAC,EACzBC,EAAcV,EAAS,IAAIW,GAAKA,EAAE,IAAI,EAE5C,QAAWC,KAAWF,EAAa,CACjC,IAAMG,EAAeD,EAAQ,YAAY,EAAE,QAAQ,KAAM,GAAG,EAE5D,QAAWE,KAAWJ,EAAa,CACjC,GAAIE,IAAYE,EAAS,SAEzB,IAAMC,EAAeD,EAAQ,YAAY,EAAE,QAAQ,KAAM,GAAG,EACpC,IAAI,OAC1B,GAAGD,CAAY,gDAAgDE,CAAY,GAC3E,GACF,EAEoB,KAAKhB,CAAS,GAChCU,EAAU,KAAK,CACb,KAAMG,EACN,GAAIE,EACJ,aAAc,MAChB,CAAC,CAEL,CACF,CAEA,OAAOL,CACT,CAKO,SAASO,GAAaC,EAA8B,CAIzD,OAHiBA,EAAM,WAAa,GAGlB,CAChB,IAAK,wBAAyB,CAE5BC,EAAQ,gBAAiB,+DAA+D,EAGxF,IAAMC,EAAaC,EAAiBH,EAAO,iBAAiB,GAAK,GAEjE,GAAI,CAACE,GAAcA,EAAW,OAAS,GACrC,OAAAD,EAAQ,gBAAiB,iCAAiC,EACnDG,EAAoB,EAK7B,IAAMC,EAAc,GADDC,EAAc,CACA,8BACbC,GAAWF,CAAW,GAGxCJ,EAAQ,gBAAiB,sDAAsD,EAMjF,IAAMlB,EAAWH,GAAwBsB,CAAU,EAC7CM,EAAczB,EAAS,OAE7B,GAAIyB,IAAgB,EAClB,OAAAP,EAAQ,gBAAiB,uBAAuB,EACzCG,EAAoB,EAI7B,IAAMZ,EAAYD,GAAyBW,EAAYnB,CAAQ,EACzD0B,EAAgBjB,EAAU,OAEhCS,EAAQ,gBAAiB,aAAaO,CAAW,iBAAiBC,CAAa,YAAY,EAG3F,IAAMC,EAAa3B,EAChB,MAAM,EAAG,CAAC,EACV,IAAIW,GAAK,KAAKA,EAAE,IAAI,KAAKA,EAAE,UAAU,MAAMA,EAAE,aAAa,CAAC,GAAK,UAAU,EAAE,EAC5E,KAAK;AAAA,CAAI,EAERiB,EAAM;AAAA;AAAA;AAAA,WAGLH,CAAW;AAAA;AAAA,EAEpBE,CAAU;AAAA;AAAA;AAAA;AAAA,eAIG,KAAK,UAAU3B,CAAQ,CAAC;AAAA,QAGjC,OAAI0B,EAAgB,IAClBE,GAAO;AAAA;AAAA;AAAA;AAAA,gBAIC,KAAK,UAAUnB,CAAS,CAAC;AAAA,SAI5B,CACL,SAAU,GACV,cAAemB,CACjB,CACF,CAEA,IAAK,+BAEH,OAAAV,EAAQ,gBAAiB,iEAAiE,EACnFG,EAAoB,EAE7B,QAEE,OAAOA,EAAoB,CAC/B,CACF,CCxLA,OAAS,cAAAQ,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAKnE,IAAMC,GAAqB,0GACrBC,GAAmB,qDAGnBC,GAAqB,GAGrBC,GAA8B,GAC9BC,GAA6B,GAgBnC,SAASC,IAA6B,CACpC,IAAMC,EAAW,SAAS,QAAQ,IAAI,gCAAkC,IAAK,EAAE,EAE/E,GAAIA,IAAa,EAAG,CAClB,IAAMC,EAAa,SAAS,QAAQ,IAAI,4BAA8B,IAAK,EAAE,EACvEC,EAAY,SAAS,QAAQ,IAAI,2BAA6B,IAAK,EAAE,EAC3E,GAAIA,EAAY,EACd,OAAO,KAAK,MAAOD,EAAa,IAAOC,CAAS,CAEpD,CAEA,OAAOF,CACT,CAKA,SAASG,GAAiBC,EAA0D,CAClF,OAAIV,GAAmB,KAAKU,CAAO,EAC1B,YAELT,GAAiB,KAAKS,CAAO,EACxB,UAEF,aACT,CAKA,SAASC,GAAgBD,EAAyB,CAEhD,IAAME,EAAW,CACf,8EACA,2DACF,EAEA,QAAWC,KAAWD,EAAU,CAC9B,IAAME,EAAQJ,EAAQ,MAAMG,CAAO,EACnC,GAAIC,EACF,OAAOA,EAAM,CAAC,EAAE,KAAK,EAAE,UAAU,EAAG,GAAG,CAE3C,CAGA,IAAMC,EAAYL,EAAQ,MAAM,iBAAiB,EACjD,OAAIK,EACKA,EAAU,CAAC,EAAE,KAAK,EAGpBL,EAAQ,UAAU,EAAG,GAAG,EAAE,KAAK,CACxC,CAKA,SAASM,GAAeN,EAAyB,CAC/C,IAAMO,EAAeP,EAAQ,YAAY,EAEzC,MAAI,mCAAmC,KAAKO,CAAY,EAAU,WAC9D,uCAAuC,KAAKA,CAAY,EAAU,eAClE,yCAAyC,KAAKA,CAAY,EAAU,WACpE,mCAAmC,KAAKA,CAAY,EAAU,UAC9D,wCAAwC,KAAKA,CAAY,EAAU,kBACnE,0BAA0B,KAAKA,CAAY,EAAU,MACrD,yBAAyB,KAAKA,CAAY,EAAU,WAEjD,SACT,CAKA,SAASC,GAAiBC,EAA2B,CACnD,GAAI,CAACC,GAAWD,CAAW,EACzB,GAAI,CACFE,GAAU,EAAQ,MAAM,EAAE,QAAQF,CAAW,EAAG,CAAE,UAAW,EAAK,CAAC,EACnEG,GAAcH,EAAa,KAAK,UAAU,CACxC,QAAS,CAAC,EACV,WAAY,IAAI,KAAK,EAAE,YAAY,CACrC,CAAC,CAAC,CACJ,MAAQ,CAER,CAEJ,CAKA,SAASI,GAAkBb,EAAiBc,EAAkBL,EAA2B,CACvFD,GAAiBC,CAAW,EAE5B,GAAI,CACF,IAAMM,EAAoB,KAAK,MAAMC,GAAaP,EAAa,MAAM,CAAC,EACtEM,EAAK,QAAQ,KAAK,CAChB,QAAAf,EACA,SAAAc,EACA,UAAW,IAAI,KAAK,EAAE,YAAY,CACpC,CAAC,EACDF,GAAcH,EAAa,KAAK,UAAUM,EAAM,KAAM,CAAC,CAAC,EACxDE,EAAQ,gBAAiB,oCAAoCH,CAAQ,YAAYd,EAAQ,MAAM,EAAE,CACnG,MAAQ,CAER,CACF,CAKA,SAASkB,GAAgBT,EAA6B,CACpD,GAAI,CAACC,GAAWD,CAAW,EAAG,MAAO,GAErC,GAAI,CAEF,OAD0B,KAAK,MAAMO,GAAaP,EAAa,MAAM,CAAC,EAC1D,SAAS,QAAU,CACjC,MAAQ,CACN,MAAO,EACT,CACF,CAKO,SAASU,GAAaC,EAA8B,CACzD,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAI,CAAC,CAAC,OAAQ,QAAS,OAAQ,QAAS,MAAM,EAAE,SAASC,CAAQ,EAC/D,OAAOC,EAAoB,EAI7B,IAAIC,EAAa,GACjB,OAAQF,EAAU,CAChB,IAAK,OAAQ,CACXE,EAAa,OAAOC,EAAkBJ,EAAO,aAAa,GAAKA,EAAM,aAAe,EAAE,EACtF,IAAMK,EAAUD,EAAiBJ,EAAO,oBAAoB,GAAK,GAC7DK,IACFF,EAAa,GAAGE,CAAO;AAAA,EAAKF,CAAU,IAExC,KACF,CACA,IAAK,QACL,IAAK,OAAQ,CACX,IAAMvB,EAAUwB,EAAiBJ,EAAO,uBAAuB,GAChDI,EAAiBJ,EAAO,oBAAoB,GAAK,GAC1DM,EAAWF,EAAiBJ,EAAO,sBAAsB,GAAK,GACpEG,EAAaG,EAAW,cAAcA,CAAQ,KAAK1B,CAAO,GAAKA,EAC/D,KACF,CACA,IAAK,QACL,IAAK,OAAQ,CACXuB,EAAa,OAAOC,EAAkBJ,EAAO,aAAa,GAAKA,EAAM,aAAe,EAAE,EACtF,KACF,CACF,CAGA,GAAI,CAACG,GAAcA,EAAW,OAAS/B,GACrC,OAAO8B,EAAoB,EAI7B,IAAIK,EAAW5B,GAAiBwB,CAAU,EAC1CN,EAAQ,gBAAiB,SAASI,CAAQ,eAAeM,CAAQ,qBAAqBJ,EAAW,MAAM,EAAE,EAGzG,IAAMK,EAAkBjC,GAAmB,EACrCkC,EAAaC,EAAc,EAC3BC,EAAYC,EAAa,EACzBvB,EAAc,GAAGoB,CAAU,oCAAoCE,CAAS,QAS9E,GANIJ,IAAa,WAAaC,GAAmBnC,KAC/CkC,EAAW,YACXV,EAAQ,gBAAiB,yBAAyBW,CAAe,mCAAmC,GAIlGA,GAAmBlC,GAA4B,CACjD,IAAMuC,EAAef,GAAgBT,CAAW,EAChD,GAAIwB,EAAe,EACjB,OAAAhB,EAAQ,gBAAiB,wBAAwBW,CAAe,eAAeK,CAAY,gBAAgB,EAEpG,CACL,SAAU,GACV,cAAe,8BAA8BL,CAAe;AAAA;AAAA,EAElEK,CAAY;AAAA,qBACOxB,CAAW;AAAA;AAAA;AAAA,sEAI1B,CAEJ,CAEA,OAAQkB,EAAU,CAChB,IAAK,YAAa,CAChB,IAAMO,EAAWjC,GAAgBsB,CAAU,EAE3C,GAAI,CAACW,GAAYA,EAAS,OAAS,GACjC,OAAAjB,EAAQ,gBAAiB,uCAAuC,EACzDK,EAAoB,EAG7B,IAAMR,EAAWR,GAAe4B,CAAQ,EACxC,OAAAjB,EAAQ,gBAAiB,sCAAsCH,CAAQ,EAAE,EAElE,CACL,SAAU,GACV,cAAe;AAAA;AAAA,YAEXA,CAAQ;AAAA,aACPoB,EAAS,UAAU,EAAG,GAAG,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAMxBpB,CAAQ;AAAA;AAAA,wBAECoB,EAAS,UAAU,EAAG,GAAG,EAAE,QAAQ,KAAM,KAAK,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uCASjE,CACF,CAEA,IAAK,UAAW,CACd,IAAMA,EAAWjC,GAAgBsB,CAAU,EAE3C,GAAIW,GAAYA,EAAS,QAAU,GAAI,CACrC,IAAMpB,EAAWR,GAAe4B,CAAQ,EACxCrB,GAAkBqB,EAAUpB,EAAUL,CAAW,EAEjD,IAAMwB,EAAef,GAAgBT,CAAW,EAGhD,GAAIwB,GAAgB,EAClB,OAAAhB,EAAQ,gBAAiB,qBAAqBgB,CAAY,gCAAgC,EAEnF,CACL,SAAU,GACV,cAAe,kBAAkBA,CAAY;AAAA;AAAA,WAE9CC,EAAS,UAAU,EAAG,GAAG,CAAC,SAASpB,CAAQ;AAAA;AAAA;AAAA,EAGpDL,CAAW,EACH,CAEJ,CAEA,OAAOa,EAAoB,CAC7B,CAGA,QAEE,OAAOA,EAAoB,CAC/B,CACF,CCtTA,OAAS,cAAAa,GAAY,gBAAAC,GAAc,iBAAAC,OAAqB,UAIxD,IAAMC,EAAe,mCACfC,GAAW,GAAGD,CAAY,QAWzB,SAASE,GAAeC,EAA8B,CAC3D,IAAMC,EAAWD,EAAM,WAAa,GAEpC,GAAI,CAACC,EACH,OAAOC,EAAoB,EAG7B,GAAI,CAEF,IAAIC,EAA0B,CAAE,MAAO,CAAC,EAAG,OAAQ,EAAG,SAAU,CAAE,EAElE,GAAIC,GAAWP,CAAY,EACzB,GAAI,CACF,IAAMQ,EAAUC,GAAaT,EAAc,MAAM,EAAE,KAAK,EACpDQ,IACFF,EAAU,KAAK,MAAME,CAAO,EAEhC,MAAQ,CAENF,EAAU,CAAE,MAAO,CAAC,EAAG,OAAQ,EAAG,SAAU,CAAE,CAChD,CAIGA,EAAQ,QACXA,EAAQ,MAAQ,CAAC,GAInB,IAAMI,EAAeJ,EAAQ,MAAMF,CAAQ,GAAK,EAChDE,EAAQ,MAAMF,CAAQ,EAAIM,EAAe,EAGzCC,GAAcX,EAAc,KAAK,UAAUM,EAAS,KAAM,CAAC,CAAC,CAC9D,OAASM,EAAO,CACdC,EAAQ,kBAAmB,2BAA2BD,CAAK,EAAE,CAC/D,CAEA,OAAOP,EAAoB,CAC7B,CCjDA,OAAS,cAAAS,GAAY,gBAAAC,GAAc,kBAAAC,GAAgB,aAAAC,OAAiB,UAKpE,IAAMC,GAA8D,CAElE,CAAE,KAAM,iBAAkB,MAAO,iEAAkE,EACnG,CAAE,KAAM,oBAAqB,MAAO,gDAAiD,EACrF,CAAE,KAAM,cAAe,MAAO,8CAA+C,EAC7E,CAAE,KAAM,kBAAmB,MAAO,4CAA6C,EAE/E,CAAE,KAAM,qBAAsB,MAAO,iEAAkE,EACvG,CAAE,KAAM,iBAAkB,MAAO,uDAAwD,EACzF,CAAE,KAAM,cAAe,MAAO,4DAA6D,EAE3F,CAAE,KAAM,YAAa,MAAO,2DAA4D,EACxF,CAAE,KAAM,kBAAmB,MAAO,0CAA2C,EAE7E,CAAE,KAAM,gBAAiB,MAAO,+BAAgC,EAChE,CAAE,KAAM,kBAAmB,MAAO,wBAAyB,EAE3D,CAAE,KAAM,iBAAkB,MAAO,mEAAoE,EACrG,CAAE,KAAM,yBAA0B,MAAO,6CAA8C,EAEvF,CAAE,KAAM,gBAAiB,MAAO,oDAAqD,EACrF,CAAE,KAAM,WAAY,MAAO,6CAA8C,EAEzE,CAAE,KAAM,iBAAkB,MAAO,qDAAsD,EAEvF,CAAE,KAAM,YAAa,MAAO,0CAA2C,CACzE,EAKA,SAASC,GAAeC,EAAkC,CACxD,GAAI,CAACC,GAAWD,CAAgB,EAC9B,MAAO,GAGT,GAAI,CACF,IAAME,EAAU,KAAK,MAAMC,GAAaH,EAAkB,MAAM,CAAC,EAE3DI,EADM,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EACnB,IAMrB,OAJsBF,EAAQ,cAAgB,CAAC,GAC5C,OAAQG,GAA6BA,EAAE,UAAYD,CAAM,EACzD,KAAK,CAACE,EAA0BC,IAA6BA,EAAE,UAAYD,EAAE,SAAS,EAErE,CAAC,GAAG,SAAW,EACrC,MAAQ,CACN,MAAO,EACT,CACF,CAKA,SAASE,GAAeC,EAA+B,CACrD,IAAMC,EAAqB,CAAC,EAE5B,OAAW,CAAE,KAAAC,EAAM,MAAAC,CAAM,IAAKd,GACxBc,EAAM,KAAKH,CAAW,GACxBC,EAAS,KAAKC,CAAI,EAItB,OAAOD,CACT,CAKA,SAASG,GACPC,EACAC,EACAC,EACAC,EACM,CACN,IAAMC,EAAYC,EAAa,EAGzBC,EAAQ,CACZ,UAHgB,IAAI,KAAK,EAAE,YAAY,EAIvC,SAAUN,EACV,UAAWC,EACX,WAAYG,EACZ,SAAAF,CACF,EAEA,GAAI,CACFK,GAAU,EAAQ,MAAM,EAAE,QAAQJ,CAAgB,EAAG,CAAE,UAAW,EAAK,CAAC,EACxEK,GAAeL,EAAkB,KAAK,UAAUG,CAAK,EAAI;AAAA,CAAI,CAC/D,MAAQ,CAER,CACF,CAKO,SAASG,GAAiBC,EAA8B,CAC7D,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,SAAWA,IAAa,OACvC,OAAOC,EAAoB,EAI7B,IAAMX,EAAWY,EAAiBH,EAAO,sBAAsB,GAAK,GAEpE,GAAI,CAACT,EACH,OAAOW,EAAoB,EAI7B,IAAME,EAAaC,EAAc,EAC3B7B,EAAmB,GAAG4B,CAAU,8BAChCd,EAAUf,GAAeC,CAAgB,EAE/C,GAAI,CAACc,EAEH,OAAOY,EAAoB,EAI7B,IAAII,EAAc,GAElB,GAAIL,IAAa,OAAQ,CAEvB,IAAMM,EAAYJ,EAAiBH,EAAO,uBAAuB,GAAK,GAChEQ,EAAYL,EAAiBH,EAAO,uBAAuB,GAAK,GAEtE,GAAIO,GAAaC,EAAW,CAE1B,IAAMC,EAAWF,EAAU,MAAM;AAAA,CAAI,EAC/BG,EAAWF,EAAU,MAAM;AAAA,CAAI,EACrCF,EAAcG,EAAS,IAAIE,GAAK,IAAIA,CAAC,EAAE,EAAE,KAAK;AAAA,CAAI,EAAI;AAAA,EACzCD,EAAS,IAAIC,GAAK,IAAIA,CAAC,EAAE,EAAE,KAAK;AAAA,CAAI,CACnD,CACF,MAEEL,EAAcH,EAAiBH,EAAO,oBAAoB,GAAK,GAGjE,GAAI,CAACM,EACH,OAAOJ,EAAoB,EAI7B,IAAMV,EAAWR,GAAesB,CAAW,EAG3C,GAAId,EAAS,OAAS,EAAG,CACvB,IAAMC,EAAmB,GAAGW,CAAU,wCACtCf,GAAeC,EAASC,EAAUC,EAAUC,CAAgB,EAGxD,QAAQ,IAAI,mBACdmB,EAAQ,qBAAsB,YAAYpB,EAAS,MAAM,iBAAiBF,CAAO,KAAK,KAAK,UAAUE,CAAQ,CAAC,EAAE,CAEpH,CAEA,OAAOU,EAAoB,CAC7B,CCxKA,OAAS,cAAAW,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UACnE,OAAS,cAAAC,OAAkB,cAc3B,IAAMC,GAAc,IAMpB,IAAMC,GAAiB,GAGjBC,GAAkB,EASxB,SAASC,IAA6B,CACpC,MAAO,GAAGC,EAAc,CAAC,yCAC3B,CAEA,SAASC,IAAkB,CACzB,IAAMC,EAAM,GAAGF,EAAc,CAAC,oBAC9B,GAAI,CAACG,GAAWD,CAAG,EACjB,GAAI,CACFE,GAAUF,EAAK,CAAE,UAAW,EAAK,CAAC,CACpC,MAAQ,CAER,CAEJ,CAKO,SAASG,IAAuC,CACrD,IAAMC,EAAOP,GAAmB,EAEhC,GAAII,GAAWG,CAAI,EACjB,GAAI,CACF,OAAO,KAAK,MAAMC,GAAaD,EAAM,MAAM,CAAC,CAC9C,MAAQ,CACNE,EAAQ,qBAAsB,iDAAiD,CACjF,CAGF,MAAO,CACL,cAAe,QACf,UAAW,IAAI,KAAK,EAAE,YAAY,EAClC,UAAW,IAAI,KAAK,EAAE,YAAY,EAClC,QAAS,CAAC,EACV,YAAa,CAAC,EACd,MAAO,CACL,gBAAiB,EACjB,YAAa,EACb,cAAe,EACf,UAAW,CAAC,CACd,CACF,CACF,CAKO,SAASC,GAAoBC,EAA6B,CAC/DT,GAAU,EACV,IAAMK,EAAOP,GAAmB,EAEhCW,EAAK,UAAY,IAAI,KAAK,EAAE,YAAY,EAExC,GAAI,CACFC,GAAcL,EAAM,KAAK,UAAUI,EAAM,KAAM,CAAC,CAAC,EACjDF,EAAQ,qBAAsB,wBAAwB,CACxD,OAASI,EAAK,CACZJ,EAAQ,qBAAsB,oCAAoCI,CAAG,EAAE,CACzE,CACF,CASO,SAASC,GAAWC,EAAwB,CACjD,OAAOC,GAAW,QAAQ,EAAE,OAAOD,EAAO,YAAY,EAAE,KAAK,CAAC,EAAE,OAAO,KAAK,EAAE,MAAM,EAAG,EAAE,CAC3F,CAKO,SAASE,GACdF,EACAG,EACAC,EACAC,EACAC,EACAC,EACAC,EACM,CACN,IAAMZ,EAAOL,GAAoB,EAE3BkB,EAA4B,CAChC,UAAW,IAAI,KAAK,EAAE,YAAY,EAClC,UAAWC,EAAa,EACxB,MAAAP,EACA,WAAYJ,GAAWC,CAAM,EAC7B,gBAAAI,EACA,mBAAoBC,EACpB,QAAAC,EACA,WAAAC,EACA,SAAAC,CACF,EAEAZ,EAAK,QAAQ,KAAKa,CAAM,EAGpBb,EAAK,QAAQ,OAASe,KACxBf,EAAK,QAAUA,EAAK,QAAQ,MAAM,CAACe,EAAW,GAIhDC,GAAkBhB,EAAMa,CAAM,EAG9BI,GAAYjB,CAAI,EAEhBD,GAAoBC,CAAI,EAExBF,EACE,qBACA,qBAAqBS,CAAK,OAAOG,CAAO,WAAWD,CAAU,GAC/D,CACF,CASA,SAASO,GAAkBhB,EAAuBa,EAAiC,CACjF,IAAMK,EAAaL,EAAO,UAAY,UAChCM,EAAaN,EAAO,UAAY,WAAaA,EAAO,UAAY,WAEtE,GAAI,CAACK,GAAc,CAACC,EAElB,OAGF,IAAMC,EAAkBF,EAAaG,GAAkB,CAACA,GAExD,QAAWC,KAAWT,EAAO,gBAAiB,CAC5C,IAAMU,EAAWvB,EAAK,YAAY,KAChCwB,GAAKA,EAAE,UAAYF,GAAWE,EAAE,QAAUX,EAAO,KACnD,EAEIU,GAEFA,EAAS,WAAa,KAAK,IACzB,CAACE,GACD,KAAK,IAAIA,GAAgBF,EAAS,WAAaH,CAAe,CAChE,EACAG,EAAS,cACTA,EAAS,YAAc,IAAI,KAAK,EAAE,YAAY,GAG9CvB,EAAK,YAAY,KAAK,CACpB,QAAAsB,EACA,MAAOT,EAAO,MACd,WAAYO,EACZ,YAAa,EACb,YAAa,IAAI,KAAK,EAAE,YAAY,CACtC,CAAC,CAEL,CACF,CAmCA,SAASM,GAAYC,EAA6B,CAChD,IAAMC,EAAUD,EAAK,QACrB,GAAIC,EAAQ,SAAW,EAAG,OAG1BD,EAAK,MAAM,gBAAkBC,EAAQ,OAGrC,IAAMC,EAAaD,EAAQ,OAAO,GAAK,EAAE,UAAY,SAAS,EAAE,OAChED,EAAK,MAAM,YAAcE,EAAaD,EAAQ,OAG9C,IAAME,EAAUF,EAAQ,OAAO,CAACG,EAAKC,IAAMD,EAAMC,EAAE,mBAAoB,CAAC,EAAIJ,EAAQ,OACpFD,EAAK,MAAM,cAAgB,KAAK,MAAMG,CAAO,EAG7C,IAAMG,EAAa,IAAI,IACvB,QAAWC,KAAUN,EAAS,CAC5B,IAAMO,EAAOF,EAAW,IAAIC,EAAO,KAAK,GAAK,CAAE,MAAO,EAAG,QAAS,CAAE,EACpEC,EAAK,QACDD,EAAO,UAAY,WAAWC,EAAK,UACvCF,EAAW,IAAIC,EAAO,MAAOC,CAAI,CACnC,CAEAR,EAAK,MAAM,UAAY,MAAM,KAAKM,EAAW,QAAQ,CAAC,EACnD,IAAI,CAAC,CAACG,EAAOD,CAAI,KAAO,CACvB,MAAAC,EACA,MAAOD,EAAK,MACZ,YAAaA,EAAK,QAAUA,EAAK,KACnC,EAAE,EACD,KAAK,CAACE,EAAGC,IAAMA,EAAE,MAAQD,EAAE,KAAK,EAChC,MAAM,EAAG,EAAE,CAChB,CClQA,OAAS,cAAAE,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAqCnE,SAASC,IAA0B,CACjC,IAAMC,EAAYC,EAAa,EAC/B,MAAO,GAAGC,EAAc,CAAC,wCAAwCF,CAAS,OAC5E,CAaA,SAASG,IAA6B,CACpC,IAAMC,EAAOC,GAAgB,EAE7B,GAAIC,GAAWF,CAAI,EACjB,GAAI,CACF,OAAO,KAAK,MAAMG,GAAaH,EAAM,MAAM,CAAC,CAC9C,MAAQ,CAER,CAGF,MAAO,CACL,cAAe,QACf,UAAWI,EAAa,EACxB,MAAO,CAAC,EACR,UAAW,CAAC,EACZ,UAAW,IAAI,KAAK,EAAE,YAAY,CACpC,CACF,CAuLO,SAASC,GAAYC,EAAuC,CAEjE,OADiBC,GAAa,EACd,MAAM,KAAKC,GAAKA,EAAE,SAAWF,CAAM,CACrD,CCnQA,OAAS,cAAAG,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAanE,SAASC,IAAsB,CAC7B,MAAO,GAAGC,EAAc,CAAC,wBAC3B,CAEA,SAASC,IAAuB,CAC9B,IAAMC,EAAYC,EAAa,EAC/B,MAAO,GAAGJ,GAAY,CAAC,YAAYG,CAAS,OAC9C,CAEA,SAASE,IAAwB,CAC/B,MAAO,GAAGJ,EAAc,CAAC,oCAC3B,CAuBO,SAASK,IAAgC,CAC9C,IAAMC,EAAYC,GAAa,EAE/B,GAAIC,GAAWF,CAAS,EACtB,GAAI,CACF,IAAMG,EAAOC,GAAaJ,EAAW,MAAM,EAC3C,OAAO,KAAK,MAAMG,CAAI,CACxB,OAASE,EAAK,CACZC,EAAQ,sBAAuB,yBAAyBD,CAAG,EAAE,CAC/D,CAIF,MAAO,CACL,UAAWE,EAAa,EACxB,aAAc,CAAC,EACf,eAAgB,CAAC,EACjB,cAAe,CAAC,EAChB,eAAgB,GAChB,UAAW,IAAI,KAAK,EAAE,YAAY,CACpC,CACF,CAmLO,SAASC,IAA0D,CACxE,OAAOC,GAAU,EAAE,kBACrB,CAMA,IAAMC,GAA6C,CACjD,mBAAoB,GACpB,qBAAsB,GACtB,wBAAyB,IACzB,kBAAmB,GACnB,gBAAiB,GACjB,WAAY,EACZ,iBAAkB,GACpB,EAKO,SAASC,IAAkC,CAChD,IAAMC,EAAaC,GAAc,EAEjC,GAAIC,GAAWF,CAAU,EACvB,GAAI,CACF,IAAMG,EAAOC,GAAaJ,EAAY,MAAM,EAC5C,MAAO,CAAE,GAAGF,GAAuB,GAAG,KAAK,MAAMK,CAAI,CAAE,CACzD,MAAQ,CAER,CAGF,OAAOL,EACT,CC1QA,SAASO,GAAcC,EAAiC,CACtD,IAAMC,EAAYD,EAAM,YAAc,CAAC,EAGvC,OAAI,OAAOC,EAAU,QAAW,SACvBA,EAAU,OAGZ,IACT,CAKA,SAASC,GAAmBF,EAA2B,CACrD,OAAIA,EAAM,YAAc,aACf,GAIF,OADWA,EAAM,YAAc,CAAC,GACf,QAAW,QACrC,CAKA,SAASG,GAAgBC,EAAqC,CAC5D,OAAQA,EAAQ,CACd,IAAK,YACH,MAAO,UACT,IAAK,UAEH,OAAO,KACT,QACE,OAAO,IACX,CACF,CAcO,SAASC,GAAmBL,EAA8B,CAE/D,GAAI,CAACE,GAAmBF,CAAK,EAC3B,OAAOM,EAAoB,EAK7B,GAAI,CADWC,GAAW,EACd,kBACV,OAAOD,EAAoB,EAG7B,IAAML,EAAYD,EAAM,YAAc,CAAC,EACjCQ,EAAST,GAAcC,CAAK,EAC5BI,EAASH,EAAU,OAEzB,GAAI,CAACO,EACH,OAAOF,EAAoB,EAI7B,IAAMG,EAAUN,GAAgBC,CAAM,EACtC,GAAI,CAACK,EACH,OAAOH,EAAoB,EAG7BI,EAAQ,sBAAuB,iBAAiBF,CAAM,qBAAqBJ,CAAM,EAAE,EAGnF,IAAMO,EAAOC,GAAYJ,CAAM,EAC/B,GAAI,CAACG,EACH,OAAAD,EAAQ,sBAAuB,QAAQF,CAAM,wBAAwB,EAC9DF,EAAoB,EAI7B,IAAMO,EAAQF,EAAK,MACnB,GAAI,CAACE,EACH,OAAAH,EAAQ,sBAAuB,iCAAiCF,CAAM,EAAE,EACjEF,EAAoB,EAK7B,IAAMQ,EADqBC,GAAsB,GACV,OAAO,KAAKC,GAAKA,EAAE,QAAUH,CAAK,EAEnEI,EAAkBH,GAAY,iBAAmB,CAAC,EAClDI,EAAaP,EAAK,YAAcG,GAAY,YAAc,EAG1DK,EAAaR,EAAK,UACpB,KAAK,IAAI,EAAI,IAAI,KAAKA,EAAK,SAAS,EAAE,QAAQ,EAC9C,OAGJ,OAAAS,GACE,GACAP,EACAI,EACAC,EACAT,EACAU,CACF,EAEAT,EACE,sBACA,yBAAyBG,CAAK,OAAOJ,CAAO,WAAWS,CAAU,GACnE,EAEOZ,EAAoB,CAC7B,CCnIA,OAAS,cAAAe,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAyBnE,IAAMC,GAAkB,CAAC,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,KAAM,MAAM,EAK3E,SAASC,GAAYC,EAAiC,CAEpD,OADYA,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,EACtC,CACX,IAAK,KAAM,MAAO,SAClB,IAAK,KACL,IAAK,MAAO,MAAO,aACnB,IAAK,KACL,IAAK,MAAO,MAAO,aACnB,IAAK,KAAM,MAAO,KAClB,IAAK,KAAM,MAAO,OAClB,IAAK,OAAQ,MAAO,OACpB,QAAS,OAAO,IAClB,CACF,CAKA,SAASC,GAAkBC,EAAkD,CAC3E,IAAIC,EAAW,EACXC,EAAc,EACdC,EAAc,EAElB,QAAWC,KAAQJ,EAAQ,MAAM;AAAA,CAAI,EAC/BI,EAAK,WAAW,GAAI,EACtBH,IACSG,EAAK,WAAW,MAAM,EAC/BD,IACSC,EAAK,MAAM,SAAS,GAC7BF,IAIJ,OAAID,EAAWC,EAAcC,EACpB,CAAE,MAAO,OAAQ,KAAM,CAAE,EAE9BD,EAAcC,EACT,CAAE,MAAO,SAAU,KAAM,CAAE,EAEhCA,EAAc,EACT,CAAE,MAAO,SAAU,KAAM,CAAE,EAG7B,CAAE,MAAO,UAAW,KAAM,CAAE,CACrC,CAKA,SAASE,GAAiBL,EAAyB,CACjD,IAAMM,GAAeN,EAAQ,MAAM,IAAI,GAAK,CAAC,GAAG,OAC1CO,GAAeP,EAAQ,MAAM,IAAI,GAAK,CAAC,GAAG,OAEhD,OAAOM,EAAcC,EAAc,SAAW,QAChD,CAKA,SAASC,GAAqBR,EAAyB,CACrD,IAAIS,EAAW,EACXC,EAAc,EAElB,QAAWN,KAAQJ,EAAQ,MAAM;AAAA,CAAI,EAAG,CAEtC,IAAMW,EAAUP,EAAK,KAAK,EACtB,CAACO,GAAWA,EAAQ,WAAW,IAAI,GAAKA,EAAQ,WAAW,GAAG,IAE9D,QAAQ,KAAKP,CAAI,EACnBK,IACS,2BAA2B,KAAKL,CAAI,GAC7CM,IAEJ,CAEA,OAAOD,EAAWC,EAAc,SAAW,MAC7C,CAKA,SAASE,GAAoBZ,EAAyB,CAEpD,OADuBA,EAAQ,MAAM,SAAS,GAAK,CAAC,GAAG,OAChC,EAAI,SAAW,SACxC,CAKA,SAASa,GAAqBb,EAAiE,CAC7F,IAAMc,EAAe,mCAAmC,KAAKd,CAAO,EAEhEe,EAAiB,UACrB,MAAI,cAAc,KAAKf,CAAO,IACxB,6BAA6B,KAAKA,CAAO,EAC3Ce,EAAiB,SACR,yBAAyB,KAAKf,CAAO,EAC9Ce,EAAiB,SACR,yBAAyB,KAAKf,CAAO,EAC9Ce,EAAiB,QAEjBA,EAAiB,UAId,CAAE,UAAWD,EAAc,eAAAC,CAAe,CACnD,CAKA,SAASC,GAAYC,EAAmC,CACtD,GAAIC,GAAWD,CAAW,EACxB,GAAI,CACF,OAAO,KAAK,MAAME,GAAaF,EAAa,MAAM,CAAC,CACrD,MAAQ,CAER,CAGF,MAAO,CACL,QAAS,QACT,aAAc,KACd,cAAe,EACf,UAAW,CAAC,EACZ,mBAAoB,CAClB,YAAa,CAAE,MAAO,UAAW,KAAM,EAAG,WAAY,CAAE,EACxD,OAAQ,CAAE,MAAO,UAAW,WAAY,CAAE,CAC5C,CACF,CACF,CAKA,SAASG,GACPC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAZ,EACM,CACNM,EAAQ,aAAe,IAAI,KAAK,EAAE,YAAY,EAC9CA,EAAQ,gBAGHA,EAAQ,UAAUC,CAAQ,IAC7BD,EAAQ,UAAUC,CAAQ,EAAI,CAC5B,QAAS,EACT,YAAa,CAAE,KAAM,EAAG,SAAU,EAAG,SAAU,CAAE,EACjD,OAAQ,CAAE,OAAQ,EAAG,OAAQ,CAAE,EAC/B,WAAY,CAAE,OAAQ,EAAG,KAAM,CAAE,EACjC,eAAgB,CAAE,OAAQ,EAAG,QAAS,CAAE,EACxC,WAAY,CAAE,KAAM,EAAG,SAAU,CAAE,EACnC,gBAAiB,CAAC,CACpB,GAGF,IAAMM,EAAOP,EAAQ,UAAUC,CAAQ,EACvCM,EAAK,UAGDL,EAAY,QAAU,OACxBK,EAAK,YAAY,OACRL,EAAY,OAAS,EAC9BK,EAAK,YAAY,WAEjBA,EAAK,YAAY,WAIfJ,IAAe,SACjBI,EAAK,OAAO,SAEZA,EAAK,OAAO,SAIVH,IAAc,YACZA,IAAc,SAChBG,EAAK,WAAW,SAEhBA,EAAK,WAAW,QAKhBF,IAAkB,YAChBA,IAAkB,SACpBE,EAAK,eAAe,SAEpBA,EAAK,eAAe,WAKpBD,IAAc,OACZA,EACFC,EAAK,WAAW,OAEhBA,EAAK,WAAW,YAKhBb,IAAmB,YACrBa,EAAK,gBAAgBb,CAAc,GAAKa,EAAK,gBAAgBb,CAAc,GAAK,GAAK,EAEzF,CAKO,SAASc,GAAiBC,EAA8B,CAC7D,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,SAAWA,IAAa,OACvC,OAAOC,EAAoB,EAG7B,IAAMlC,EAAWmC,EAAiBH,EAAO,sBAAsB,GAAK,GAGpE,GAAI,CAAChC,GAAYA,EAAS,SAAS,WAAW,GAC1CA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,OAAO,EAC3B,OAAOkC,EAAoB,EAI7B,IAAME,EAAMpC,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,GAAK,GACxD,GAAI,CAACF,GAAgB,SAASsC,CAAG,EAC/B,OAAOF,EAAoB,EAG7B,IAAMV,EAAWzB,GAAYC,CAAQ,EACrC,GAAI,CAACwB,EACH,OAAOU,EAAoB,EAI7B,IAAIhC,EAAUiC,EAAiBH,EAAO,oBAAoB,GAAK,GAE/D,GAAI,CAAC9B,EAAS,CACZ,IAAMmC,EAAaC,EAAc,EAC3BC,EAAWvC,EAAS,WAAW,GAAG,EAAIA,EAAW,GAAGqC,CAAU,IAAIrC,CAAQ,GAEhF,GAAIoB,GAAWmB,CAAQ,EACrB,GAAI,CAEFrC,EAAUmB,GAAakB,EAAU,MAAM,EAAE,MAAM;AAAA,CAAI,EAAE,MAAM,EAAG,GAAG,EAAE,KAAK;AAAA,CAAI,CAC9E,MAAQ,CACN,OAAOL,EAAoB,CAC7B,CAEJ,CAEA,GAAI,CAAChC,EACH,OAAOgC,EAAoB,EAI7B,IAAMT,EAAcxB,GAAkBC,CAAO,EACvCwB,EAAanB,GAAiBL,CAAO,EAEvCyB,EAAY,UACZC,EAAgB,UAChBC,EAA4B,KAC5BZ,EAAiB,UAGrB,OAAQO,EAAU,CAChB,IAAK,aACL,IAAK,aACHG,EAAYjB,GAAqBR,CAAO,EACxC0B,EAAgBd,GAAoBZ,CAAO,EAC3C,MACF,IAAK,SAAU,CACb,IAAMsC,EAAazB,GAAqBb,CAAO,EAC/C2B,EAAYW,EAAW,UACvBvB,EAAiBuB,EAAW,eAC5BZ,EAAgBd,GAAoBZ,CAAO,EAC3C,KACF,CACF,CAGA,IAAMmC,EAAaC,EAAc,EAC3BnB,EAAc,GAAGkB,CAAU,4CAEjC,GAAI,CACFI,GAAU,GAAGJ,CAAU,oBAAqB,CAAE,UAAW,EAAK,CAAC,EAC/D,IAAMd,EAAUL,GAAYC,CAAW,EACvCG,GAAcC,EAASC,EAAUC,EAAaC,EAAYC,EAAWC,EAAeC,EAAWZ,CAAc,EAC7GyB,GAAcvB,EAAa,KAAK,UAAUI,EAAS,KAAM,CAAC,CAAC,CAC7D,OAASoB,EAAO,CACdC,EAAQ,qBAAsB,2BAA2BD,CAAK,EAAE,CAClE,CAEA,OAAAC,EAAQ,qBACN,YAAYpB,CAAQ,iBAAiBC,EAAY,KAAK,IAAIA,EAAY,IAAI,YAAYC,CAAU,EAAE,EAE7FQ,EAAoB,CAC7B,CC5VA,OAAqB,kBAAAW,GAAgB,aAAAC,OAAiB,UACtD,OAAS,YAAAC,OAAgB,qBAOlB,SAASC,GAAkBC,EAA8B,CAI9D,IAHiBA,EAAM,WAAa,MAGnB,QACf,OAAOC,EAAoB,EAG7B,IAAMC,EAAWC,EAAiBH,EAAO,sBAAsB,GAC9C,QAAQ,IAAI,uBAAyB,GAEtD,GAAI,CAACE,EACH,OAAOD,EAAoB,EAI7B,GAAIC,EAAS,SAAS,MAAM,GAAKA,EAAS,SAAS,MAAM,GAAKA,EAAS,SAAS,WAAW,EACzF,OAAOD,EAAoB,EAI7B,GAAI,CAAC,wBAAwB,KAAKC,CAAQ,EACxC,OAAOD,EAAoB,EAG7B,IAAMG,EAAaC,EAAc,EAG7BC,EAAc,GACZC,EAAWL,EAAS,MAAM,GAAG,EAAE,IAAI,GAAK,GAE9C,GAAIA,EAAS,SAAS,KAAK,EAGzBI,EAAc,QADSC,EAAS,QAAQ,MAAO,EAAE,CACb,cAC3B,qBAAqB,KAAKL,CAAQ,EAG3CI,EAAc,GADSC,EAAS,QAAQ,WAAY,EAAE,CACvB,cAE/B,QAAON,EAAoB,EAI7B,IAAIO,EAAa,GACjB,GAAI,CAKFA,EAJmBC,GACjB,SAASL,CAAU,oBAAoBE,CAAW,0BAClD,CAAE,SAAU,OAAQ,QAAS,GAAK,CACpC,EAAE,KAAK,CAET,MAAQ,CAER,CAGA,IAAMI,EAAS,GAAGN,CAAU,sBAC5B,GAAI,CACFO,GAAUD,EAAQ,CAAE,UAAW,EAAK,CAAC,EACrC,IAAME,EAAY,IAAI,KAAK,EAAE,YAAY,EAEzC,GAAIJ,EACFK,GACE,GAAGH,CAAM,0BACT,IAAIE,CAAS,kBAAkBV,CAAQ,iBAAiBM,CAAU;AAAA,CACpE,MAEA,QAAAK,GACE,GAAGH,CAAM,0BACT,IAAIE,CAAS,oBAAoBV,CAAQ,sCAAsCI,CAAW;AAAA,CAC5F,EAGO,CACL,SAAU,GACV,cAAe,8BAA8BJ,CAAQ,EACvD,CAEJ,MAAQ,CAER,CAEA,OAAOD,EAAoB,CAC7B,CCjFA,OAAS,cAAAa,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UA8BnE,IAAMC,GAAkB,CAAC,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,KAAM,MAAM,EAK3E,SAASC,GAAWC,EAA0B,CAC5C,OAAIA,EAAK,OAAS,GAAK,YAAY,KAAKA,CAAI,EACnC,UAGL,oBAAoB,KAAKA,CAAI,EACxB,uBAEL,sBAAsB,KAAKA,CAAI,EAC1B,aAEL,sBAAsB,KAAKA,CAAI,GAAK,CAACA,EAAK,SAAS,GAAG,EACjD,YAEL,oBAAoB,KAAKA,CAAI,EACxB,aAEL,qBAAqB,KAAKA,CAAI,EACzB,qBAEL,wBAAwB,KAAKA,CAAI,EAC5B,SAGF,OACT,CAKA,SAASC,GAAyBC,EAKhC,CACA,IAAMC,GAAaD,EAAQ,MAAM,+BAA+B,GAAK,CAAC,GACnE,IAAIE,GAAKA,EAAE,QAAQ,OAAQ,EAAE,CAAC,EAE3BC,GAAWH,EAAQ,MAAM,iCAAiC,GAAK,CAAC,GACnE,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,CAAC,EAE7BE,GAAaJ,EAAQ,MAAM,oCAAoC,GAAK,CAAC,GACxE,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,EAAE,KAAK,CAAC,EAEpCG,GAAaL,EAAQ,MAAM,0BAA0B,GAAK,CAAC,GAC9D,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,EAAE,KAAK,CAAC,EAE1C,MAAO,CAAE,UAAAD,EAAW,QAAAE,EAAS,UAAAC,EAAW,UAAAC,CAAU,CACpD,CAKA,SAASC,GAAqBN,EAM5B,CACA,IAAMC,EAAY,CAChB,IAAID,EAAQ,MAAM,qDAAqD,GAAK,CAAC,GAC1E,IAAIE,GAAKA,EAAE,QAAQ,qBAAsB,EAAE,CAAC,EAC/C,IAAIF,EAAQ,MAAM,0CAA0C,GAAK,CAAC,GAC/D,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,EAAE,QAAQ,SAAU,EAAE,CAAC,CAC3D,EAEMC,GAAWH,EAAQ,MAAM,iCAAiC,GAAK,CAAC,GACnE,IAAIE,GAAKA,EAAE,QAAQ,SAAU,EAAE,CAAC,EAE7BK,GAAcP,EAAQ,MAAM,qCAAqC,GAAK,CAAC,GAC1E,IAAIE,GAAKA,EAAE,QAAQ,aAAc,EAAE,CAAC,EAEjCM,GAASR,EAAQ,MAAM,gCAAgC,GAAK,CAAC,GAChE,IAAIE,GAAKA,EAAE,QAAQ,QAAS,EAAE,CAAC,EAE5BE,GAAaJ,EAAQ,MAAM,2CAA2C,GAAK,CAAC,GAC/E,IAAIE,GAAKA,EAAE,QAAQ,mBAAoB,EAAE,CAAC,EAE7C,MAAO,CAAE,UAAAD,EAAW,QAAAE,EAAS,UAAAC,EAAW,WAAAG,EAAY,MAAAC,CAAM,CAC5D,CAKA,SAASC,EAAWC,EAAmD,CACrE,IAAMC,EAAqC,CACzC,UAAW,EACX,WAAY,EACZ,WAAY,EACZ,qBAAsB,EACtB,mBAAoB,EACpB,OAAQ,EACR,MAAO,EACP,QAAS,CACX,EAEA,QAAWb,KAAQY,EAAa,CAC9B,GAAI,CAACZ,EAAM,SACX,IAAMc,EAAWf,GAAWC,CAAI,EAChCa,EAAOC,CAAQ,GACjB,CAEA,OAAOD,CACT,CAKA,SAASE,GAAiBC,EAA0B,CAElD,IAAMC,GADWD,EAAS,MAAM,GAAG,EAAE,IAAI,GAAK,IACd,QAAQ,WAAY,EAAE,EAEtD,MAAI,oBAAoB,KAAKC,CAAc,EAClC,aAEL,oBAAoB,KAAKA,CAAc,EAClC,aAEL,sBAAsB,KAAKA,CAAc,EACpC,aAEL,sBAAsB,KAAKA,CAAc,EACpC,YAGF,OACT,CAKA,SAASC,GAAYF,EAAiC,CAEpD,OADYA,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,EACtC,CACX,IAAK,KAAM,MAAO,SAClB,IAAK,KACL,IAAK,MAAO,MAAO,aACnB,IAAK,KACL,IAAK,MAAO,MAAO,aACnB,IAAK,KAAM,MAAO,KAClB,IAAK,KAAM,MAAO,OAClB,IAAK,OAAQ,MAAO,OACpB,QAAS,OAAO,IAClB,CACF,CAKA,SAASG,GAAYC,EAAoC,CACvD,GAAIC,GAAWD,CAAW,EACxB,GAAI,CACF,OAAO,KAAK,MAAME,GAAaF,EAAa,MAAM,CAAC,CACrD,MAAQ,CAER,CAGF,MAAO,CACL,QAAS,QACT,aAAc,KACd,cAAe,EACf,UAAW,CAAC,EACZ,YAAa,CAAC,EACd,kBAAmB,CACjB,UAAW,CAAC,EACZ,QAAS,CAAC,EACV,UAAW,CAAC,EACZ,UAAW,CAAC,EACZ,MAAO,CAAC,CACV,CACF,CACF,CAKA,SAASG,IAA6C,CACpD,MAAO,CACL,QAAS,EACT,UAAW,CAAE,UAAW,EAAG,WAAY,EAAG,WAAY,EAAG,qBAAsB,EAAG,mBAAoB,EAAG,OAAQ,EAAG,MAAO,EAAG,QAAS,CAAE,EACzI,QAAS,CAAE,UAAW,EAAG,WAAY,EAAG,WAAY,EAAG,qBAAsB,EAAG,mBAAoB,EAAG,OAAQ,EAAG,MAAO,EAAG,QAAS,CAAE,EACvI,UAAW,CAAE,UAAW,EAAG,WAAY,EAAG,WAAY,EAAG,qBAAsB,EAAG,mBAAoB,EAAG,OAAQ,EAAG,MAAO,EAAG,QAAS,CAAE,EACzI,UAAW,CAAE,UAAW,EAAG,WAAY,EAAG,WAAY,EAAG,qBAAsB,EAAG,mBAAoB,EAAG,OAAQ,EAAG,MAAO,EAAG,QAAS,CAAE,EACzI,MAAO,CAAE,UAAW,EAAG,WAAY,EAAG,WAAY,EAAG,qBAAsB,EAAG,mBAAoB,EAAG,OAAQ,EAAG,MAAO,EAAG,QAAS,CAAE,CACvI,CACF,CAKO,SAASC,GAAwBC,EAA8B,CACpE,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,SAAWA,IAAa,OACvC,OAAOC,EAAoB,EAG7B,IAAMX,EAAWY,EAAiBH,EAAO,sBAAsB,GAAK,GAGpE,GAAI,CAACT,GAAYA,EAAS,SAAS,WAAW,GAC1CA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,OAAO,EAC3B,OAAOW,EAAoB,EAI7B,IAAME,EAAMb,EAAS,MAAM,GAAG,EAAE,IAAI,GAAG,YAAY,GAAK,GACxD,GAAI,CAAClB,GAAgB,SAAS+B,CAAG,EAC/B,OAAOF,EAAoB,EAG7B,IAAMG,EAAWZ,GAAYF,CAAQ,EACrC,GAAI,CAACc,EACH,OAAOH,EAAoB,EAI7B,IAAIzB,EAAU0B,EAAiBH,EAAO,oBAAoB,GAAK,GAE/D,GAAI,CAACvB,EAAS,CACZ,IAAM6B,EAAaC,EAAc,EAC3BC,EAAWjB,EAAS,WAAW,GAAG,EAAIA,EAAW,GAAGe,CAAU,IAAIf,CAAQ,GAEhF,GAAIK,GAAWY,CAAQ,EACrB,GAAI,CAEF/B,EAAUoB,GAAaW,EAAU,MAAM,EAAE,MAAM;AAAA,CAAI,EAAE,MAAM,EAAG,GAAG,EAAE,KAAK;AAAA,CAAI,CAC9E,MAAQ,CACN,OAAON,EAAoB,CAC7B,CAEJ,CAEA,GAAI,CAACzB,EACH,OAAOyB,EAAoB,EAI7B,IAAMO,EAAanB,GAAiBC,CAAQ,EAGxCmB,EAAwCxB,EAAW,CAAC,CAAC,EACrDyB,EAAyCzB,EAAW,CAAC,CAAC,EACtD0B,EAAuC1B,EAAW,CAAC,CAAC,EACpD2B,EAAyC3B,EAAW,CAAC,CAAC,EACtD4B,EAAwC5B,EAAW,CAAC,CAAC,EAEzD,OAAQmB,EAAU,CAChB,IAAK,SAAU,CACb,IAAMU,EAAMvC,GAAyBC,CAAO,EAC5CiC,EAAYxB,EAAW6B,EAAI,SAAS,EACpCJ,EAAazB,EAAW6B,EAAI,OAAO,EACnCH,EAAW1B,EAAW6B,EAAI,SAAS,EACnCF,EAAa3B,EAAW6B,EAAI,SAAS,EACrC,KACF,CACA,IAAK,aACL,IAAK,aAAc,CACjB,IAAMA,EAAMhC,GAAqBN,CAAO,EACxCiC,EAAYxB,EAAW6B,EAAI,SAAS,EACpCJ,EAAazB,EAAW6B,EAAI,OAAO,EACnCH,EAAW1B,EAAW6B,EAAI,SAAS,EACnCD,EAAY5B,EAAW,CAAC,GAAG6B,EAAI,WAAY,GAAGA,EAAI,KAAK,CAAC,EACxD,KACF,CACF,CAGA,IAAMT,EAAaC,EAAc,EAC3BZ,EAAc,GAAGW,CAAU,4CAEjC,GAAI,CACFU,GAAU,GAAGV,CAAU,oBAAqB,CAAE,UAAW,EAAK,CAAC,EAC/D,IAAMW,EAAUvB,GAAYC,CAAW,EAGvCsB,EAAQ,aAAe,IAAI,KAAK,EAAE,YAAY,EAC9CA,EAAQ,gBAGRA,EAAQ,YAAYR,CAAU,GAAKQ,EAAQ,YAAYR,CAAU,GAAK,GAAK,EAGtEQ,EAAQ,UAAUZ,CAAQ,IAC7BY,EAAQ,UAAUZ,CAAQ,EAAIP,GAAoB,GAGpD,IAAMoB,EAAOD,EAAQ,UAAUZ,CAAQ,EACvCa,EAAK,UAGL,QAAW7B,KAAY,OAAO,KAAKqB,CAAS,EAC1CQ,EAAK,UAAU7B,CAAQ,GAAK6B,EAAK,UAAU7B,CAAQ,GAAK,GAAKqB,EAAUrB,CAAQ,EAC/E6B,EAAK,QAAQ7B,CAAQ,GAAK6B,EAAK,QAAQ7B,CAAQ,GAAK,GAAKsB,EAAWtB,CAAQ,EAC5E6B,EAAK,UAAU7B,CAAQ,GAAK6B,EAAK,UAAU7B,CAAQ,GAAK,GAAKuB,EAASvB,CAAQ,EAC9E6B,EAAK,UAAU7B,CAAQ,GAAK6B,EAAK,UAAU7B,CAAQ,GAAK,GAAKwB,EAAWxB,CAAQ,EAChF6B,EAAK,MAAM7B,CAAQ,GAAK6B,EAAK,MAAM7B,CAAQ,GAAK,GAAKyB,EAAUzB,CAAQ,EAGzE8B,GAAcxB,EAAa,KAAK,UAAUsB,EAAS,KAAM,CAAC,CAAC,CAC7D,OAASG,EAAO,CACdC,EAAQ,4BAA6B,2BAA2BD,CAAK,EAAE,CACzE,CAEA,OAAAC,EAAQ,4BAA6B,YAAYhB,CAAQ,UAAUd,CAAQ,WAAWkB,CAAU,EAAE,EAE3FP,EAAoB,CAC7B,CCrWA,OAAS,cAAAoB,EAAY,YAAAC,GAAU,kBAAAC,GAAgB,aAAAC,OAAiB,UAahE,SAASC,GAAkBC,EAAkBC,EAA2C,CACtF,IAAMC,EAAWF,EAAS,MAAM,GAAG,EAAE,IAAI,GAAK,GACxCG,EAAUH,EAAS,MAAM,GAAG,EAAE,MAAM,EAAG,EAAE,EAAE,KAAK,GAAG,EACnDI,GAAYJ,EAAS,MAAM,GAAG,EAAE,IAAI,GAAK,IAAI,YAAY,EAG/D,OAAQE,EAAU,CAChB,IAAK,eACH,GAAIG,EAAW,GAAGJ,CAAU,IAAID,CAAQ,EAAE,EACxC,GAAI,CACF,IAAMM,EAAMC,EAAQ,GAAGN,CAAU,IAAID,CAAQ,EAAE,EAE/C,GADoB,OAAO,KAAKM,EAAI,SAAW,CAAC,CAAC,EAAE,OACjC,EAChB,MAAO,CACL,WAAY,UACZ,cAAe,oBACf,WAAY,oCACd,CAEJ,MAAQ,CAER,CAEF,MAEF,IAAK,iBACL,IAAK,WACL,IAAK,YACH,MAAO,CACL,WAAY,gBACZ,cAAe,eACf,WAAY,8DACd,EAEF,IAAK,aACL,IAAK,qBACL,IAAK,sBACH,MAAO,CACL,WAAY,SACZ,cAAe,sBACf,WAAY,mCACd,EAEF,IAAK,eACL,IAAK,gBACH,MAAO,CACL,WAAY,MACZ,cAAe,wBACf,WAAY,kDACd,CACJ,CAGA,GAAIN,EAAS,SAAS,OAAO,GAAKA,EAAS,SAAS,UAAU,GAAKA,EAAS,SAAS,aAAa,EAChG,MAAO,CACL,WAAY,MACZ,cAAe,gBACf,WAAY,iDACd,EAIF,GAAIG,EAAQ,SAAS,SAAS,GAAKA,EAAQ,SAAS,WAAW,EAC7D,MAAO,CACL,WAAY,SACZ,cAAe,gBACf,WAAY,8CACd,EAIF,GAAI,CAAC,WAAY,WAAY,UAAW,SAAU,aAAa,EAAE,SAASD,CAAQ,GAClEF,EAAS,MAAM,GAAG,EAAE,QACrB,EACX,MAAO,CACL,WAAY,cACZ,cAAe,kBACf,WAAY,oDACd,EAKJ,IAAIA,EAAS,SAAS,OAAO,GAAKA,EAAS,SAAS,OAAO,GAAKA,EAAS,SAAS,WAAW,IACvF,CAAC,KAAM,KAAM,IAAI,EAAE,SAASI,CAAQ,EACtC,MAAO,CACL,WAAY,MACZ,cAAe,iBACf,WAAY,uCACd,EAKJ,GAAIF,IAAa,YAAcA,IAAa,WAAY,CACtD,IAAMM,EAAW,GAAGP,CAAU,IAAID,CAAQ,GAC1C,GAAIK,EAAWG,CAAQ,EACrB,GAAI,CACF,GAAM,CAAE,aAAAC,CAAa,EAAI,EAAQ,IAAI,EAGrC,IAFgBA,EAAaD,EAAU,MAAM,EAChB,MAAM,WAAW,GAAK,CAAC,GAAG,OACrC,EAChB,MAAO,CACL,WAAY,UACZ,cAAe,gBACf,WAAY,kDACd,CAEJ,MAAQ,CAER,CAEJ,CAEA,OAAO,IACT,CAKA,SAASE,GAAWT,EAAmC,CACrD,QAAWU,IAAQ,CAAC,YAAa,YAAa,YAAa,aAAc,QAAQ,EAC/E,GAAIN,EAAW,GAAGJ,CAAU,IAAIU,CAAI,EAAE,EACpC,MAAO,GAAGV,CAAU,IAAIU,CAAI,GAGhC,OAAO,IACT,CAKO,SAASC,GAAWC,EAA8B,CAIvD,IAHiBA,EAAM,WAAa,MAGnB,QACf,OAAOC,EAAoB,EAG7B,IAAMd,EAAWe,EAAiBF,EAAO,sBAAsB,GAAK,GAEpE,GAAI,CAACb,EACH,OAAOc,EAAoB,EAI7B,GAAId,EAAS,SAAS,WAAW,GAC7BA,EAAS,SAAS,gBAAgB,GAClCA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,QAAQ,GAC1BA,EAAS,SAAS,OAAO,GACzBA,EAAS,SAAS,MAAM,EAC1B,OAAOc,EAAoB,EAI7B,GAAId,EAAS,SAAS,MAAM,GAAKA,EAAS,SAAS,MAAM,GAAKA,EAAS,SAAS,WAAW,EACzF,OAAOc,EAAoB,EAG7B,IAAMb,EAAae,EAAc,EAG3BC,EAAWlB,GAAkBC,EAAUC,CAAU,EAEvD,GAAI,CAACgB,EACH,OAAOH,EAAoB,EAI7B,IAAMI,EAAaR,GAAWT,CAAU,EAEpCkB,EAEJ,GAAID,EAAY,CAEd,IAAIE,EAAU,EACd,GAAI,CAEF,IAAMC,EADQC,GAASJ,CAAU,EACb,MAAM,QAAQ,EAC5BK,EAAM,KAAK,IAAI,EACrBH,EAAU,KAAK,OAAOG,EAAMF,IAAU,MAAQ,IAAK,CACrD,MAAQ,CAER,CAEA,IAAIG,EAAaP,EAAS,WACtBG,EAAU,KACZI,EAAa,GAAGA,CAAU,yBAAyBJ,CAAO,eAG5DD,EAAa,gBAAgBF,EAAS,UAAU,cAAcjB,EAAS,MAAM,GAAG,EAAE,IAAI,CAAC,eAAeiB,EAAS,aAAa,MAAMO,CAAU,EAC9I,MACEL,EAAa,gBAAgBF,EAAS,UAAU,kEAI9CE,EAAW,OAAS,MACtBA,EAAa,gBAAgBF,EAAS,UAAU,wCAAwCA,EAAS,aAAa,cAIhH,IAAMQ,EAAS,GAAGxB,CAAU,sBAC5B,GAAI,CACFyB,GAAUD,EAAQ,CAAE,UAAW,EAAK,CAAC,EACrC,IAAME,EAAY,IAAI,KAAK,EAAE,YAAY,EACzCC,GACE,GAAGH,CAAM,mBACT,IAAIE,CAAS,kBAAkBV,EAAS,UAAU,cAAcjB,CAAQ,OAAOiB,EAAS,aAAa;AAAA,CACvG,CACF,MAAQ,CAER,CAEA,OAAAY,EAAQ,cAAe,gBAAgBZ,EAAS,UAAU,gCAAgC,EAGnF,CACL,SAAU,GACV,mBAAoB,CAClB,kBAAmBE,CACrB,CACF,CACF,CCzOA,OAAS,cAAAW,OAAkB,UAQpB,SAASC,GAAoBC,EAA+B,CAEjE,IAAMC,EAAW,GADEC,EAAc,CACH,4CAG9B,OAAKC,GAAWF,CAAQ,EAQjBG,EAAoB,EAPlBA,EAAoB,CAQ/B,CCvBA,OAAS,cAAAC,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UACnE,OAAS,YAAAC,MAAgB,qBAyBzB,SAASC,GAAuBC,EAA+B,CAE7D,IAAIC,EAAQD,EAAO,MAAM,sCAAsC,EAC/D,OAAIC,EACKA,EAAM,CAAC,GAIhBA,EAAQD,EAAO,MAAM,SAAS,EAC1BC,EACKA,EAAM,CAAC,EAGT,KACT,CAKA,SAASC,GAAuBC,EAAgC,CAE9D,IAAIF,EAAQE,EAAQ,MAAM,QAAQ,EAClC,OAAIF,EACKA,EAAM,CAAC,GAIhBA,EAAQE,EAAQ,MAAM,sDAAsD,EACxEF,EACKA,EAAM,CAAC,EAGT,KACT,CAKA,SAASG,IAA2B,CAClC,GAAI,CACF,OAAOC,EAAS,uFAAwF,CACtG,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,CACV,MAAQ,CACN,MAAO,EACT,CACF,CAKA,SAASC,IAAqC,CAC5C,GAAI,CACF,IAAMC,EAAMF,EAAS,yCAA0C,CAC7D,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,EAEFF,EAAUE,EAAS,qCAAsC,CAC7D,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,EAEFG,EAAYH,EAAS,sCAAuC,CAChE,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,GAAK,IAAI,KAAK,EAAE,YAAY,EAEpC,MAAO,CAAE,IAAAE,EAAK,QAAAJ,EAAS,UAAAK,CAAU,CACnC,MAAQ,CACN,OAAO,IACT,CACF,CAKA,SAASC,GAAiBC,EAAsBC,EAAyB,CACvE,GAAI,CAACC,GAAWF,CAAY,EAC1B,GAAI,CACFG,GAAU,EAAQ,MAAM,EAAE,QAAQH,CAAY,EAAG,CAAE,UAAW,EAAK,CAAC,EACpEI,GAAcJ,EAAc,KAAK,UAAU,CACzC,WAAYC,EACZ,OAAQ,CAAC,CACX,CAAC,CAAC,CACJ,MAAQ,CAER,CAEJ,CAKA,SAASI,GACPC,EACAC,EACAjB,EACAU,EACAC,EACS,CACTF,GAAiBC,EAAcC,CAAS,EAExC,GAAI,CACF,IAAMO,EAAqB,KAAK,MAAMC,GAAaT,EAAc,MAAM,CAAC,EAExE,OAAKQ,EAAK,OAAOF,CAAQ,IACvBE,EAAK,OAAOF,CAAQ,EAAI,CACtB,QAAS,CAAC,EACV,gBAAiB,CAAC,EAClB,OAAQ,KACR,OAAAhB,CACF,GAGFkB,EAAK,OAAOF,CAAQ,EAAE,QAAQ,KAAKC,CAAM,EACzCC,EAAK,OAAOF,CAAQ,EAAE,OAAShB,EAE/Bc,GAAcJ,EAAc,KAAK,UAAUQ,EAAM,KAAM,CAAC,CAAC,EACzDE,EAAQ,2BAA4B,4BAA4BJ,CAAQ,EAAE,EACnE,EACT,MAAQ,CACN,OAAAI,EAAQ,2BAA4B,mCAAmCJ,CAAQ,EAAE,EAC1E,EACT,CACF,CAKO,SAASK,GAAuBC,EAA8B,CAInE,IAHiBA,EAAM,WAAa,MAGnB,OACf,OAAOC,EAAoB,EAG7B,IAAMC,EAAUC,EAAiBH,EAAO,oBAAoB,GAAK,GAC3DI,EAAWJ,EAAM,WAAa,EAGpC,GAAI,CAAC,gBAAgB,KAAKE,CAAO,GAAKE,IAAa,EACjD,OAAOH,EAAoB,EAG7BH,EAAQ,2BAA4B,kCAAkC,EAGtE,GAAI,CACFf,EAAS,WAAY,CAAE,MAAO,SAAU,QAAS,GAAK,CAAC,CACzD,MAAQ,CACN,OAAAe,EAAQ,2BAA4B,wDAAwD,EACrFG,EAAoB,CAC7B,CAGA,GAAI,CAKF,GAAI,CAJWlB,EAAS,wCAAyC,CAC/D,SAAU,OACV,QAAS,GACX,CAAC,EACW,SAAS,QAAQ,EAC3B,OAAAe,EAAQ,2BAA4B,mCAAmC,EAChEG,EAAoB,CAE/B,MAAQ,CACN,OAAOA,EAAoB,CAC7B,CAGA,IAAMvB,EAASI,GAAiB,EAChC,GAAI,CAACJ,EACH,OAAAoB,EAAQ,2BAA4B,oCAAoC,EACjEG,EAAoB,EAI7B,IAAIP,EAAWjB,GAAuBC,CAAM,EAG5C,GAAI,CAACgB,EACH,GAAI,CACF,IAAMW,EAAYtB,EAAS,qCAAsC,CAC/D,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,EACRW,EAAWd,GAAuByB,CAAS,CAC7C,MAAQ,CAER,CAIF,GAAI,CAACX,EACH,OAAAI,EAAQ,2BAA4B,oCAAoCpB,CAAM,qBAAqB,EAC5FuB,EAAoB,EAG7BH,EAAQ,2BAA4B,gBAAgBJ,CAAQ,EAAE,EAG9D,GAAI,CACFX,EAAS,iBAAiBW,CAAQ,iBAAkB,CAAE,MAAO,SAAU,QAAS,GAAK,CAAC,CACxF,MAAQ,CACN,OAAAI,EAAQ,2BAA4B,UAAUJ,CAAQ,8BAA8B,EAC7EO,EAAoB,CAC7B,CAGA,IAAMN,EAASX,GAAgB,EAC/B,GAAI,CAACW,EACH,OAAAG,EAAQ,2BAA4B,2BAA2B,EACxDG,EAAoB,EAI7B,IAAMZ,GAAaW,EAAM,YAAcM,EAAa,GAAG,QAAQ,kBAAmB,EAAE,EAC9ElB,EAAe,uBAAuBC,CAAS,uBAErD,OAAAI,GAAoBC,EAAUC,EAAQjB,EAAQU,EAAcC,CAAS,EAE9DY,EAAoB,CAC7B,CC1PA,OAAS,cAAAM,GAAY,gBAAAC,GAAc,iBAAAC,OAAqB,UACxD,OAAS,YAAAC,MAAgB,qBAmBzB,SAASC,GAAsBC,EAAyB,CAEtD,IAAIC,EAAOD,EAAQ,QAAQ,2BAA4B,EAAE,EAGzD,OAAAC,EAAOA,EAAK,QAAQ,YAAa,EAAE,EAE5BA,EAAK,KAAK,CACnB,CAKA,SAASC,GAAcC,EAAsB,CAC3C,OAAOA,EAAK,YAAY,EAAE,QAAQ,OAAQ,GAAG,EAAE,KAAK,CACtD,CAKA,SAASC,GAAgBC,EAAoBC,EAA+B,CAC1E,IAAMC,EAAaL,GAAcG,CAAU,EACrCG,EAAeN,GAAcI,CAAY,EAa/C,GAVIC,IAAeC,GAKfD,EAAW,SAASC,CAAY,GAKhCA,EAAa,SAASD,CAAU,EAClC,MAAO,GAIT,IAAME,EAAc,IAAI,IAAIF,EAAW,MAAM,GAAG,EAAE,OAAOG,GAAKA,EAAE,QAAU,CAAC,CAAC,EACtEC,EAAgBH,EAAa,MAAM,GAAG,EAAE,OAAOE,GAAKA,EAAE,QAAU,CAAC,EACnEE,EAAgB,EAEpB,QAAWC,KAAQF,EACbF,EAAY,IAAII,CAAI,GACtBD,IAIJ,OAAOA,GAAiB,CAC1B,CAKA,SAASE,GAAuBC,EAA+B,CAC7D,IAAIC,EAAQD,EAAO,MAAM,sCAAsC,EAC/D,OAAIC,EACKA,EAAM,CAAC,GAGhBA,EAAQD,EAAO,MAAM,SAAS,EAC1BC,EACKA,EAAM,CAAC,EAGT,KACT,CAKA,SAASC,GAAuBjB,EAAgC,CAC9D,IAAMgB,EAAQhB,EAAQ,MAAM,QAAQ,EACpC,OAAOgB,EAAQA,EAAM,CAAC,EAAI,IAC5B,CAKA,SAASE,GAAkBC,EAA4B,CACrD,GAAI,CAOF,IAAMC,EANOC,EAAS,iBAAiBF,CAAQ,sCAAuC,CACpF,SAAU,OACV,QAAS,GACX,CAAC,EAGkB,MAAM;AAAA,CAAI,EACvBG,EAAsB,CAAC,EAE7B,QAAWC,KAAQH,EAAO,CACxB,IAAMJ,EAAQO,EAAK,MAAM,wBAAwB,EAC7CP,GACFM,EAAU,KAAKN,EAAM,CAAC,EAAE,KAAK,CAAC,CAElC,CAEA,OAAOM,CACT,MAAQ,CACN,MAAO,CAAC,CACV,CACF,CAKA,SAASE,GAAeL,EAAkBb,EAA+B,CACvEmB,EAAQ,wBAAyB,mCAAmCnB,CAAY,eAAea,CAAQ,EAAE,EAEzG,GAAI,CAEF,IAAMO,EAAOL,EAAS,iBAAiBF,CAAQ,sCAAuC,CACpF,SAAU,OACV,QAAS,GACX,CAAC,EAGKQ,EAAcrB,EAAa,QAAQ,sBAAuB,MAAM,EAGhEsB,EAAcF,EAAK,QACvB,IAAI,OAAO,8BAA8BC,CAAW,IAAK,GAAG,EAC5D,SACF,EAGA,GAAID,IAASE,EACX,OAAAH,EAAQ,wBAAyB,mCAAmCnB,CAAY,GAAG,EAC5E,GAIT,IAAMuB,EAAOR,EAAS,oEAAqE,CACzF,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,EAGFS,EAAW,KAAK,UAAUF,CAAW,EAC3C,OAAAP,EAAS,0BAA0BQ,CAAI,WAAWV,CAAQ,aAAaW,CAAQ,GAAI,CACjF,MAAO,SACP,QAAS,GACX,CAAC,EAEDL,EAAQ,wBAAyB,mCAAmCnB,CAAY,GAAG,EAC5E,EACT,OAASyB,EAAO,CACd,OAAAN,EAAQ,wBAAyB,gCAAgCM,CAAK,EAAE,EACjE,EACT,CACF,CAKA,SAASC,GAAqBb,EAAkBc,EAAkBC,EAA4B,CAC5F,GAAKC,GAAWD,CAAY,EAI5B,GAAI,CACF,IAAME,EAAqB,KAAK,MAAMC,GAAaH,EAAc,MAAM,CAAC,EAEnEE,EAAK,OAAOjB,CAAQ,IACvBiB,EAAK,OAAOjB,CAAQ,EAAI,CACtB,QAAS,CAAC,EACV,gBAAiB,CAAC,EAClB,OAAQ,IACV,GAGGiB,EAAK,OAAOjB,CAAQ,EAAE,gBAAgB,SAASc,CAAQ,IAC1DG,EAAK,OAAOjB,CAAQ,EAAE,gBAAgB,KAAKc,CAAQ,EACnDK,GAAcJ,EAAc,KAAK,UAAUE,EAAM,KAAM,CAAC,CAAC,EAE7D,MAAQ,CAER,CACF,CAKO,SAASG,GAAoBC,EAA8B,CAIhE,IAHiBA,EAAM,WAAa,MAGnB,OACf,OAAOC,EAAoB,EAG7B,IAAMC,EAAUC,EAAiBH,EAAO,oBAAoB,GAAK,GAC3DI,EAAWJ,EAAM,WAAa,EAGpC,GAAI,CAAC,gBAAgB,KAAKE,CAAO,GAAKE,IAAa,EACjD,OAAOH,EAAoB,EAG7BhB,EAAQ,wBAAyB,8CAA8C,EAG/E,GAAI,CACFJ,EAAS,WAAY,CAAE,MAAO,SAAU,QAAS,GAAK,CAAC,CACzD,MAAQ,CACN,OAAAI,EAAQ,wBAAyB,gDAAgD,EAC1EgB,EAAoB,CAC7B,CAGA,GAAI,CAKF,GAAI,CAJWpB,EAAS,wCAAyC,CAC/D,SAAU,OACV,QAAS,GACX,CAAC,EACW,SAAS,QAAQ,EAC3B,OAAAI,EAAQ,wBAAyB,mCAAmC,EAC7DgB,EAAoB,CAE/B,MAAQ,CACN,OAAOA,EAAoB,CAC7B,CAGA,IAAI1B,EAAS,GACT8B,EAAY,GAEhB,GAAI,CACF9B,EAASM,EAAS,wCAAyC,CACzD,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,EAERwB,EAAYxB,EAAS,qCAAsC,CACzD,SAAU,OACV,QAAS,GACX,CAAC,EAAE,KAAK,CACV,MAAQ,CACN,OAAOoB,EAAoB,CAC7B,CAGA,IAAItB,EAAWL,GAAuBC,CAAM,EAK5C,GAJKI,IACHA,EAAWF,GAAuB4B,CAAS,GAGzC,CAAC1B,EACH,OAAAM,EAAQ,wBAAyB,uBAAuB,EACjDgB,EAAoB,EAG7BhB,EAAQ,wBAAyB,gBAAgBN,CAAQ,qCAAqC,EAG9F,IAAMd,EAAaN,GAAsB8C,CAAS,EAClD,GAAI,CAACxC,EACH,OAAAoB,EAAQ,wBAAyB,4CAA4C,EACtEgB,EAAoB,EAG7BhB,EAAQ,wBAAyB,iBAAiBpB,CAAU,GAAG,EAG/D,IAAMyC,EAAiB5B,GAAkBC,CAAQ,EACjD,GAAI2B,EAAe,SAAW,EAC5B,OAAArB,EAAQ,wBAAyB,gCAAgCN,CAAQ,EAAE,EACpEsB,EAAoB,EAI7B,IAAIM,EAAU,GAERb,EAAe,wBADFM,EAAM,YAAcQ,EAAa,GAAG,QAAQ,kBAAmB,EAAE,CAC/B,uBAErD,QAAW1C,KAAgBwC,EACrB1C,GAAgBC,EAAYC,CAAY,IAC1CmB,EAAQ,wBAAyB,6BAA6BnB,CAAY,GAAG,EAEzEkB,GAAeL,EAAUb,CAAY,IACvC0B,GAAqBb,EAAUb,EAAc4B,CAAY,EACzDa,EAAU,KAKhB,OAAKA,EAME,CACL,SAAU,GACV,eAAgB,GAChB,mBAAoB,CAClB,cAAe,cACf,kBAAmB,UAAU5B,CAAQ,8DACvC,CACF,GAZEM,EAAQ,wBAAyB,2CAA2CpB,CAAU,GAAG,EAClFoC,EAAoB,EAY/B,CChUA,OAAS,cAAAQ,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAkBnE,IAAMC,GAAwC,CAC5C,IAAK,oBACL,OAAQ,gBACR,WAAY,4BACZ,MAAO,SACP,MAAO,SACP,QAAS,WACT,WAAY,cACZ,QAAS,WACT,oBAAqB,uBACrB,oBAAqB,qBACrB,UAAW,aACX,IAAK,mBACL,QAAS,WACT,KAAM,mBACR,EAGMC,GAA4C,CAChD,QAAS,oBACT,OAAQ,kBACR,SAAU,cACV,aAAc,wBACd,SAAU,oBACV,QAAS,iBACX,EAGMC,GAAmD,CACvD,WAAY,uCACZ,QAAS,4BACT,eAAgB,8BAChB,WAAY,2CACZ,QAAS,2BACT,SAAU,2CACV,YAAa,oCACb,eAAgB,iCAClB,EAKA,SAASC,IAAuB,CAE9B,OADmBC,EAAc,EACf,MAAM,GAAG,EAAE,IAAI,GAAK,SACxC,CAKA,SAASC,GAAmBC,EAAiD,CAC3E,IAAMC,EAAYD,EAAK,YAAY,EAC/BE,EAAO,UACPC,EAAU,UAGd,OAAW,CAACC,EAAMC,CAAK,IAAK,OAAO,QAAQX,EAAa,EACtD,GAAIW,EAAM,KAAKJ,CAAS,EAAG,CACzBC,EAAOE,EACP,KACF,CAIF,OAAW,CAACA,EAAMC,CAAK,IAAK,OAAO,QAAQV,EAAiB,EAC1D,GAAIU,EAAM,KAAKL,CAAI,EAAG,CACpBG,EAAUC,EACV,KACF,CAGF,MAAO,CAAE,KAAAF,EAAM,QAAAC,CAAQ,CACzB,CAKA,SAASG,GAA2BN,EAAsB,CACxD,OAAW,CAACO,EAAUF,CAAK,IAAK,OAAO,QAAQT,EAAwB,EACrE,GAAIS,EAAM,KAAKL,CAAI,EACjB,OAAOO,EAGX,MAAO,SACT,CAKA,SAASC,EACPR,EACAO,EACAE,EACAC,EACAC,EACM,CACN,IAAMC,EAAY,IAAI,KAAK,EAAE,YAAY,EACnCC,EAAYhB,GAAa,EAG/B,GAAI,CAACiB,GAAWH,CAAa,EAC3B,GAAI,CACFI,GAAU,EAAQ,MAAM,EAAE,QAAQJ,CAAa,EAAG,CAAE,UAAW,EAAK,CAAC,EACrEK,GAAcL,EAAe,KAAK,UAAU,CAAE,SAAU,CAAC,CAAE,CAAC,CAAC,CAC/D,MAAQ,CACN,MACF,CAGF,GAAI,CACF,IAAMM,EAAqB,KAAK,MAAMC,GAAaP,EAAe,MAAM,CAAC,EACzEM,EAAK,SAAS,KAAK,CACjB,KAAAjB,EACA,SAAAO,EACA,QAAAE,EACA,OAAAC,EACA,UAAAE,EACA,QAASC,CACX,CAAC,EACDG,GAAcL,EAAe,KAAK,UAAUM,EAAM,KAAM,CAAC,CAAC,EAC1DE,EAAQ,oBAAqB,4BAA4BZ,CAAQ,YAAYE,CAAO,WAAWC,CAAM,EAAE,CACzG,MAAQ,CAER,CACF,CAKA,SAASU,GAAgBC,EAAiBC,EAAkBX,EAA6B,CAEvF,IAAIY,EAAY,GACVC,EAAWH,EAAQ,MAAM,uBAAuB,GACrCA,EAAQ,MAAM,eAAe,EAK9C,GAJIG,IACFD,EAAYC,EAAS,CAAC,GAGpB,CAACD,EACH,OAGF,GAAM,CAAE,KAAArB,EAAM,QAAAC,CAAQ,EAAIJ,GAAmBwB,CAAS,EAChDhB,EAAWD,GAA2BiB,CAAS,EAC/Cd,EAAUa,IAAa,EAAI,UAAY,SAGzCG,EAAcF,EACdrB,IAAS,YACXuB,EAAc,IAAIvB,CAAI,KAAKqB,CAAS,IAGtCf,EAAaiB,EAAalB,EAAUE,EAAS,SAAUE,CAAa,CACtE,CAKA,SAASe,GAAcL,EAAiBC,EAAkBX,EAA6B,CACrF,GAAIW,IAAa,EACf,OAIF,IAAIK,EAAS,yBACPC,EAAUP,EAAQ,MAAM,yBAAyB,EACnDO,IACFD,EAAS,OAAOC,EAAQ,CAAC,CAAC,WAG5BpB,EAAamB,EAAQ,WAAY,UAAW,WAAYhB,CAAa,CACvE,CAKA,SAASkB,GAAiBR,EAAiBC,EAAkBX,EAA6B,CACxF,IAAImB,EAAgB,UAEhB,kBAAkB,KAAKT,CAAO,EAAGS,EAAgB,SAC5C,OAAO,KAAKT,CAAO,EAAGS,EAAgB,OACtC,SAAS,KAAKT,CAAO,EAAGS,EAAgB,SACxC,oCAAoC,KAAKT,CAAO,EAAGS,EAAgB,WACnE,YAAY,KAAKT,CAAO,IAAGS,EAAgB,WAEpD,IAAMrB,EAAUa,IAAa,EAAI,UAAY,SACvCG,EAAc,SAAShB,IAAY,UAAY,SAAW,QAAQ,KAAKqB,CAAa,IAE1FtB,EAAaiB,EAAa,UAAWhB,EAAS,WAAYE,CAAa,CACzE,CAKA,SAASoB,GAAkBV,EAAiBC,EAAkBX,EAA6B,CACzF,IAAIqB,EAAY,UAEZ,oBAAoB,KAAKX,CAAO,EAAGW,EAAY,MAC1C,eAAe,KAAKX,CAAO,EAAGW,EAAY,OAC1C,gBAAgB,KAAKX,CAAO,EAAGW,EAAY,QAC3C,OAAO,KAAKX,CAAO,EAAGW,EAAY,OAClC,iBAAiB,KAAKX,CAAO,IAAGW,EAAY,UAErD,IAAMvB,EAAUa,IAAa,EAAI,UAAY,SACvCG,EAAc,SAAShB,IAAY,UAAY,YAAc,QAAQ,KAAKuB,CAAS,IAEzFxB,EAAaiB,EAAa,QAAShB,EAAS,QAASE,CAAa,CACpE,CAKO,SAASsB,GAAiBC,EAA8B,CAI7D,IAHiBA,EAAM,WAAa,MAGnB,OACf,OAAOC,EAAoB,EAG7B,IAAMd,EAAUe,EAAiBF,EAAO,oBAAoB,GAAK,GAC3DZ,EAAWY,EAAM,WAAa,EAEpC,GAAI,CAACb,EACH,OAAOc,EAAoB,EAG7B,IAAME,EAAehB,EAAQ,YAAY,EAEnCV,EAAgB,GADHb,EAAc,CACE,wCAGnC,MAAI,eAAe,KAAKuC,CAAY,EAClCjB,GAAgBC,EAASC,EAAUX,CAAa,EACvC,kBAAkB,KAAK0B,CAAY,EAC5CX,GAAcL,EAASC,EAAUX,CAAa,EACrC,iEAAiE,KAAK0B,CAAY,EAC3FR,GAAiBR,EAASC,EAAUX,CAAa,EACxC,mEAAmE,KAAK0B,CAAY,GAC7FN,GAAkBV,EAASC,EAAUX,CAAa,EAG7CwB,EAAoB,CAC7B,CCrQA,OAAS,cAAAG,GAAY,gBAAAC,GAAc,iBAAAC,GAAe,aAAAC,OAAiB,UAYnE,IAAMC,GAAyC,CAC7C,wCAAyC,oHACzC,8CAA+C,kHAC/C,8CAA+C,qEAC/C,6BAA8B,0FAC9B,sCAAuC,oGACzC,EAKA,SAASC,GAAcC,EAAyB,CAC9C,GAAI,CAACC,GAAWD,CAAS,EACvB,GAAI,CACFE,GAAU,EAAQ,MAAM,EAAE,QAAQF,CAAS,EAAG,CAAE,UAAW,EAAK,CAAC,EACjEG,GAAcH,EAAW,KAAK,UAAU,CACtC,QAAS,MACT,OAAQ,CAAC,EACT,SAAU,CAAC,EACX,aAAc,EAChB,CAAC,CAAC,CACJ,MAAQ,CAER,CAEJ,CAKA,SAASI,EAAcJ,EAAmC,CACxDD,GAAcC,CAAS,EAEvB,GAAI,CACF,OAAO,KAAK,MAAMK,GAAaL,EAAW,MAAM,CAAC,CACnD,MAAQ,CACN,MAAO,CACL,QAAS,MACT,OAAQ,CAAC,EACT,SAAU,CAAC,EACX,aAAc,EAChB,CACF,CACF,CAKA,SAASM,GAAYC,EAAeC,EAAmBR,EAAyB,CAC9E,IAAMS,EAAOL,EAAcJ,CAAS,EAC9BU,EAAY,IAAI,KAAK,EAAE,YAAY,EAGzCD,EAAK,OAAOF,CAAK,GAAKE,EAAK,OAAOF,CAAK,GAAK,GAAK,EAG5CE,EAAK,SAASD,CAAS,IAC1BC,EAAK,SAASD,CAAS,EAAI,CAAC,GAEzBC,EAAK,SAASD,CAAS,EAAE,SAASD,CAAK,GAC1CE,EAAK,SAASD,CAAS,EAAE,KAAKD,CAAK,EAIrCE,EAAK,aAAeC,EAEpB,GAAI,CACFP,GAAcH,EAAW,KAAK,UAAUS,EAAM,KAAM,CAAC,CAAC,EACtDE,EAAQ,wBAAyB,4BAA4BJ,CAAK,cAAcC,CAAS,GAAG,CAC9F,MAAQ,CAER,CACF,CAKA,SAASI,GAAiBJ,EAAmBR,EAA6B,CAExE,OADaI,EAAcJ,CAAS,EACxB,SAASQ,CAAS,GAAK,CAAC,CACtC,CAKA,SAASK,GAAcC,EAAsBC,EAAwC,CACnF,OAAW,CAACC,EAAYC,CAAU,IAAK,OAAO,QAAQnB,EAAc,EAAG,CACrE,GAAM,CAACoB,EAAQC,CAAM,EAAIH,EAAW,MAAM,GAAG,EAG7C,GAAIF,IAAiBI,GAAUJ,IAAiBK,EAAQ,CACtD,IAAMC,EAAaN,IAAiBI,EAASC,EAASD,EAEtD,GAAIH,EAAc,SAASK,CAAU,EACnC,OAAAT,EAAQ,wBAAyB,qBAAqBO,CAAM,MAAMC,CAAM,EAAE,EACnEF,CAEX,CACF,CAEA,OAAO,IACT,CAKA,SAASI,GAAcrB,EAA2B,CAChD,IAAMS,EAAOL,EAAcJ,CAAS,EAG9BsB,EAAU,OAAO,QAAQb,EAAK,MAAM,EAC1C,OAAIa,EAAQ,SAAW,EAAU,GAE1BA,EACJ,KAAK,CAACC,EAAGC,IAAMA,EAAE,CAAC,EAAID,EAAE,CAAC,CAAC,EAC1B,MAAM,EAAG,CAAC,EACV,IAAI,CAAC,CAAChB,EAAOkB,CAAK,IAAM,GAAGlB,CAAK,IAAIkB,CAAK,EAAE,EAC3C,KAAK,IAAI,CACd,CAKO,SAASC,GAAoBC,EAA8B,CAChE,IAAMC,EAAWD,EAAM,WAAa,GAC9BE,EAAYC,EAAiBH,EAAO,kBAAkB,GAC3CG,EAAiBH,EAAO,WAAW,GAAK,GAGzD,GAAIC,IAAa,SAAW,CAACC,GAAW,WAAW,SAAS,GACtD,CAACA,EACH,OAAOE,EAAoB,EAI/B,GAAI,CAACF,EACH,OAAOE,EAAoB,EAI7B,IAAM/B,EAAY,GADCgC,EAAc,CACF,qCACzBxB,EAAYyB,EAAa,EAG/B3B,GAAYuB,EAAWrB,EAAWR,CAAS,EAG3C,IAAMe,EAAgBH,GAAiBJ,EAAWR,CAAS,EACrDkC,EAAoBrB,GAAcgB,EAAWd,CAAa,EAG1DoB,EAAad,GAAcrB,CAAS,EAGtCoC,EAAa,GAEbF,IACFE,EAAa,kBAAkBF,CAAiB,GAChDvB,EAAQ,wBAAyB,iCAAiCkB,CAAS,EAAE,GAK/E,IAAMQ,EADOjC,EAAcJ,CAAS,EACL,OAAO6B,CAAS,GAAK,EAWpD,OATIQ,EAAoB,GAAKA,EAAoB,IAAM,GAAKF,IACtDC,EACFA,EAAa,GAAGA,CAAU,kBAAkBD,CAAU,GAEtDC,EAAa,4BAA4BD,CAAU,IAKnDC,GAEEA,EAAW,OAAS,MACtBA,EAAaA,EAAW,UAAU,EAAG,GAAG,EAAI,OAGvC,CACL,SAAU,GACV,mBAAoB,CAClB,kBAAmBA,CACrB,CACF,GAGKL,EAAoB,CAC7B,CChNA,OAAS,cAAAO,EAAY,gBAAAC,OAAoB,UACzC,OAAS,YAAAC,OAAgB,qBAOzB,SAASC,IAAkC,CACzC,GAAI,CACFC,GAAS,gBAAiB,CAAE,MAAO,SAAU,QAAS,GAAK,CAAC,EAE5D,IAAMC,EAAS,GADIC,EAAc,CACL,mCAC5B,OAAOC,EAAWF,CAAM,CAC1B,MAAQ,CACN,MAAO,EACT,CACF,CAKA,SAASG,GAAgBC,EAAkBC,EAA6B,CAEtE,IAAML,EAAS,GADIC,EAAc,CACL,mCAE5B,GAAI,CAACC,EAAWF,CAAM,EACpB,MAAO,GAGT,GAAI,CAEF,IAAMM,EAAcF,EAAS,QAAQ,KAAM,IAAI,EACzCG,EAAkBF,EAAW,QAAQ,KAAM,IAAI,EAErD,OAAAN,GACE,YAAYC,CAAM,gDAAgDM,CAAW,wBAAwBC,CAAe,MACpH,CAAE,MAAO,SAAU,QAAS,GAAK,CACnC,EAEAC,EAAQ,oBAAqB,qBAAqBJ,CAAQ,EAAE,EACrD,EACT,OAASK,EAAO,CACd,OAAAD,EAAQ,oBAAqB,8BAA8BJ,CAAQ,KAAKK,CAAK,EAAE,EACxE,EACT,CACF,CAKA,SAASC,IAAwB,CAE/B,GAAI,QAAQ,IAAI,YACd,OAAO,QAAQ,IAAI,YAKrB,IAAMC,EAAc,GADDV,EAAc,CACA,yBAEjC,GAAIC,EAAWS,CAAW,EACxB,GAAI,CAEF,IAAMC,EADUC,GAAaF,EAAa,MAAM,EAC1B,MAAM,oCAAoC,EAChE,GAAIC,EACF,OAAOA,EAAM,CAAC,CAElB,MAAQ,CAER,CAIF,OAAOE,EAAa,CACtB,CAKO,SAASC,GAAgBC,EAA8B,CAC5D,IAAMC,EAAWD,EAAM,WAAa,GAGpC,GAAIC,IAAa,SAAWA,IAAa,OACvC,OAAOC,EAAoB,EAI7B,GAAI,CAACpB,GAAuB,EAC1B,OAAOoB,EAAoB,EAI7B,IAAMd,EAAWe,EAAiBH,EAAO,sBAAsB,GAAK,GAEpE,GAAI,CAACZ,EACH,OAAOc,EAAoB,EAI7B,GAAId,EAAS,SAAS,wBAAwB,EAC5C,OAAOc,EAAoB,EAI7B,IAAME,EAAa,OAAOD,EAAkBH,EAAO,aAAa,GAAK,EAAE,EACvE,GAAII,EAAW,SAAS,OAAO,GAAKA,EAAW,SAAS,OAAO,EAE7D,OAAOF,EAAoB,EAI7B,IAAMb,EAAaK,GAAc,EACjC,OAAAP,GAAgBC,EAAUC,CAAU,EAE7Ba,EAAoB,CAC7B,CCzEO,IAAMG,GAAgC,CAE3C,wBAAyBC,EACzB,qBAAsBC,EACtB,kCAAmCC,GACnC,kCAAmCC,GACnC,2BAA4BC,GAC5B,oCAAqCC,GACrC,yBAA0BC,GAC1B,gCAAiCC,GACjC,yBAA0BC,GAC1B,yBAA0BC,GAC1B,2BAA4BC,GAC5B,8BAA+BC,GAC/B,+BAAgCC,GAGhC,oCAAqCC,GACrC,oCAAqCC,GACrC,2CAA4CC,GAC5C,6BAA8BC,GAC9B,wCAAyCC,GAGzC,yCAA0CC,GAC1C,sCAAuCC,GACvC,kCAAmCC,GAGnC,uCAAwCC,GAGxC,wCAAyCC,EAC3C,EAEO,SAASC,GAAQC,EAAkC,CACxD,OAAOzB,GAAMyB,CAAI,CACnB,CAEO,SAASC,IAAsB,CACpC,OAAO,OAAO,KAAK1B,EAAK,CAC1B",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "getCachedBranch", "projectDir", "execSync", "branch", "getLogLevel", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "execSync", "getCurrentBranch", "projectDir", "dir", "getProjectDir", "execSync", "isProtectedBranch", "branch", "currentBranch", "getRepoRoot", "isGitRepo", "getGitStatus", "hasUncommittedChanges", "getDefaultBranch", "extractIssueNumber", "patterns", "pattern", "match", "validateBranchName", "validPrefixes", "prefix", "appendFileSync", "existsSync", "mkdirSync", "statSync", "renameSync", "readCountFile", "auditLogger", "input", "toolName", "readFileSync", "writeFileSync", "readCount", "outputSilentSuccess", "projectDir", "auditLog", "logDir", "existsSync", "mkdirSync", "rotateLogFile", "timestamp", "details", "getField", "logEntry", "appendFileSync", "logFile", "maxBytes", "statSync", "rotated", "renameSync", "existsSync", "execSync", "getLanguage", "filePath", "commandExists", "cmd", "execSync", "autoLint", "input", "toolName", "outputSilentSuccess", "getField", "projectDir", "fullPath", "existsSync", "language", "lintIssues", "fixesApplied", "ruffCheck", "biomeOut", "error", "logHook", "basename", "existsSync", "readFileSync", "writeFileSync", "statSync", "mkdirSync", "BUDGET_TOTAL", "COMPRESS_TRIGGER", "COMPRESS_TARGET", "MCP_DEFER_TRIGGER", "estimateTokens", "filePath", "existsSync", "stats", "statSync", "calculateUsage", "contextDir", "getProjectDir", "alwaysLoadedFiles", "total", "file", "getEffectiveContextWindow", "baseWindow", "shouldDeferMcp", "currentTokens", "effectiveWindow", "updateMcpDeferState", "shouldDefer", "stateFile", "getSessionId", "state", "writeFileSync", "logHook", "compressSession", "sessionFile", "content", "readFileSync", "compressed", "archiveOldDecisions", "projectDir", "decisionsFile", "decisions", "archiveDir", "mkdirSync", "date", "archiveFile", "contextBudgetMonitor", "_input", "usageRatio", "usagePercent", "deferMcp", "newTokens", "newRatio", "newPercent", "error", "outputSilentSuccess", "existsSync", "readFileSync", "execSync", "coordinationHeartbeat", "_input", "projectDir", "getProjectDir", "coordLib", "existsSync", "outputSilentSuccess", "instanceEnv", "instanceId", "match", "readFileSync", "execSync", "error", "logHook", "existsSync", "appendFileSync", "readFileSync", "writeFileSync", "mkdirSync", "statSync", "renameSync", "createHash", "ERROR_PATTERNS", "rotateLogFile", "logFile", "maxBytes", "existsSync", "statSync", "rotated", "renameSync", "errorCollector", "input", "toolName", "sessionId", "getSessionId", "timestamp", "toolOutput", "getField", "exitCode", "toolError", "isError", "errorType", "errorMessage", "errorLines", "line", "projectDir", "getProjectDir", "errorLog", "mkdirSync", "toolInput", "inputHash", "createHash", "errorMessageTruncated", "toolOutputTruncated", "appendFileSync", "metricsFile", "metrics", "readFileSync", "writeFileSync", "logHook", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_CONTEXT_CHARS", "DEDUP_PROMPT_THRESHOLD", "MAX_SKILLS", "isErrorOutput", "input", "exitCode", "toolError", "getField", "toolOutput", "matchErrorPattern", "errorText", "solutionsFile", "existsSync", "logHook", "content", "readFileSync", "errorLower", "pattern", "shouldSuggest", "patternId", "errorContext", "dedupFile", "mkdirSync", "writeFileSync", "dedup", "suggestionHash", "currentCount", "lastSuggestedAt", "getSkillDescription", "skillName", "skillsDir", "skillFile", "frontmatterMatch", "descMatch", "buildSkillsSection", "category", "patternSkills", "categorySkills", "allSkills", "section", "skill", "desc", "buildSuggestionMessage", "brief", "steps", "msg", "step", "i", "skillsSection", "errorSolutionSuggester", "outputSilentSuccess", "pluginRoot", "getPluginRoot", "getSessionId", "matchedPattern", "suggestionMessage", "existsSync", "readFileSync", "writeFileSync", "appendFileSync", "mkdirSync", "TRIVIAL_COMMANDS", "errorTracker", "input", "toolName", "command", "getField", "outputSilentSuccess", "toolError", "exitCode", "logHook", "metricsFile", "metrics", "existsSync", "content", "readFileSync", "writeFileSync", "projectDir", "getProjectDir", "errorLog", "mkdirSync", "timestamp", "errorPreview", "appendFileSync", "mem0WebhookHandler", "input", "logHook", "toolName", "command", "getField", "outputSilentSuccess", "eventDataStr", "eventData", "eventType", "memoryId", "error", "existsSync", "ENTITY_PATTERNS", "extractEntitiesFromText", "text", "textLower", "entities", "entityType", "pattern", "matches", "match", "entityName", "word", "observation", "extractRelationsFromText", "relations", "entityNames", "e", "entity1", "entity1Lower", "entity2", "entity2Lower", "memoryBridge", "input", "logHook", "memoryText", "getField", "outputSilentSuccess", "memoryAgent", "getPluginRoot", "existsSync", "entityCount", "relationCount", "entityList", "msg", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "IMMEDIATE_KEYWORDS", "BATCHED_KEYWORDS", "MIN_CONTENT_LENGTH", "CONTEXT_EMERGENCY_THRESHOLD", "CONTEXT_CRITICAL_THRESHOLD", "getContextPressure", "pressure", "tokensUsed", "maxTokens", "classifyPriority", "content", "extractDecision", "patterns", "pattern", "match", "sentences", "detectCategory", "contentLower", "initPendingQueue", "pendingFile", "existsSync", "mkdirSync", "writeFileSync", "addToPendingQueue", "category", "data", "readFileSync", "logHook", "getPendingCount", "realtimeSync", "input", "toolName", "outputSilentSuccess", "toolOutput", "getField", "command", "filePath", "priority", "contextPressure", "projectDir", "getProjectDir", "sessionId", "getSessionId", "pendingCount", "decision", "existsSync", "readFileSync", "writeFileSync", "METRICS_FILE", "LOCKFILE", "sessionMetrics", "input", "toolName", "outputSilentSuccess", "metrics", "existsSync", "content", "readFileSync", "currentCount", "writeFileSync", "error", "logHook", "existsSync", "readFileSync", "appendFileSync", "mkdirSync", "PATTERN_DEFINITIONS", "getRecentSkill", "sessionStateFile", "existsSync", "content", "readFileSync", "cutoff", "s", "a", "b", "detectPatterns", "diffContent", "detected", "name", "regex", "logEditPattern", "skillId", "filePath", "patterns", "editPatternsFile", "sessionId", "getSessionId", "entry", "mkdirSync", "appendFileSync", "skillEditTracker", "input", "toolName", "outputSilentSuccess", "getField", "projectDir", "getProjectDir", "editContent", "oldString", "newString", "oldLines", "newLines", "l", "logHook", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "MAX_RECORDS", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "ADJUSTMENT_STEP", "keyword", "existing", "a", "MAX_ADJUSTMENT", "updateStats", "data", "records", "successful", "avgConf", "sum", "r", "agentStats", "record", "stat", "agent", "a", "b", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "loadRegistry", "file", "getRegistryFile", "existsSync", "readFileSync", "getSessionId", "getTaskById", "taskId", "loadRegistry", "t", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "loadState", "stateFile", "getStateFile", "existsSync", "data", "readFileSync", "err", "logHook", "getSessionId", "getLastClassification", "loadState", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "getConfigFile", "existsSync", "data", "readFileSync", "extractTaskId", "input", "toolInput", "isTaskStatusUpdate", "statusToOutcome", "status", "calibrationTracker", "outputSilentSuccess", "loadConfig", "taskId", "outcome", "logHook", "task", "getTaskById", "agent", "agentMatch", "getLastClassification", "a", "matchedKeywords", "confidence", "durationMs", "recordOutcome", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "CODE_EXTENSIONS", "getLanguage", "filePath", "detectIndentation", "content", "tabCount", "space2Count", "space4Count", "line", "detectQuoteStyle", "singleCount", "doubleCount", "detectSemicolonStyle", "withSemi", "withoutSemi", "trimmed", "detectTrailingComma", "detectPythonPatterns", "hasTypeHints", "docstringStyle", "loadProfile", "profilePath", "existsSync", "readFileSync", "updateProfile", "profile", "language", "indentation", "quoteStyle", "semiStyle", "trailingComma", "typeHints", "lang", "codeStyleLearner", "input", "toolName", "outputSilentSuccess", "getField", "ext", "projectDir", "getProjectDir", "fullPath", "pyPatterns", "mkdirSync", "writeFileSync", "error", "logHook", "appendFileSync", "mkdirSync", "execSync", "coveragePredictor", "input", "outputSilentSuccess", "filePath", "getField", "projectDir", "getProjectDir", "testPattern", "basename", "testExists", "execSync", "logDir", "mkdirSync", "timestamp", "appendFileSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "CODE_EXTENSIONS", "detectCase", "name", "extractPythonIdentifiers", "content", "functions", "m", "classes", "variables", "constants", "extractJsIdentifiers", "interfaces", "types", "countCases", "identifiers", "counts", "caseType", "detectFileNaming", "filePath", "nameWithoutExt", "getLanguage", "loadProfile", "profilePath", "existsSync", "readFileSync", "initLanguageProfile", "namingConventionLearner", "input", "toolName", "outputSilentSuccess", "getField", "ext", "language", "projectDir", "getProjectDir", "fullPath", "fileNaming", "funcCases", "classCases", "varCases", "constCases", "typeCases", "ids", "mkdirSync", "profile", "lang", "writeFileSync", "error", "logHook", "existsSync", "statSync", "appendFileSync", "mkdirSync", "analyzeFileChange", "filePath", "projectDir", "filename", "dirname", "extLower", "existsSync", "pkg", "__require", "fullPath", "readFileSync", "findReadme", "name", "readmeSync", "input", "outputSilentSuccess", "getField", "getProjectDir", "analysis", "readmePath", "contextMsg", "daysOld", "mtime", "statSync", "now", "suggestion", "logDir", "mkdirSync", "timestamp", "appendFileSync", "logHook", "existsSync", "releaseLockOnCommit", "_input", "coordLib", "getProjectDir", "existsSync", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "extractIssueFromBranch", "branch", "match", "extractIssueFromCommit", "message", "getCurrentBranch", "execSync", "getLatestCommit", "sha", "timestamp", "initProgressFile", "progressFile", "sessionId", "existsSync", "mkdirSync", "writeFileSync", "queueCommitProgress", "issueNum", "commit", "data", "readFileSync", "logHook", "issueProgressCommenter", "input", "outputSilentSuccess", "command", "getField", "exitCode", "commitMsg", "getSessionId", "existsSync", "readFileSync", "writeFileSync", "execSync", "extractTaskFromCommit", "message", "task", "normalizeText", "text", "matchesCheckbox", "commitTask", "checkboxText", "normCommit", "normCheckbox", "commitWords", "w", "checkboxWords", "matchingWords", "word", "extractIssueFromBranch", "branch", "match", "extractIssueFromCommit", "getUncheckedTasks", "issueNum", "lines", "execSync", "unchecked", "line", "updateCheckbox", "logHook", "body", "escapedText", "updatedBody", "repo", "bodyJson", "error", "recordTaskCompletion", "taskText", "progressFile", "existsSync", "data", "readFileSync", "writeFileSync", "issueSubtaskUpdater", "input", "outputSilentSuccess", "command", "getField", "exitCode", "commitMsg", "uncheckedTasks", "matched", "getSessionId", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "TECH_PATTERNS", "CATEGORY_PATTERNS", "BEST_PRACTICE_CATEGORIES", "getProjectId", "getProjectDir", "extractPatternInfo", "text", "textLower", "tech", "pattern", "name", "regex", "detectBestPracticeCategory", "category", "queuePattern", "outcome", "source", "patternsQueue", "timestamp", "projectId", "existsSync", "mkdirSync", "writeFileSync", "data", "readFileSync", "logHook", "handleGitCommit", "command", "exitCode", "commitMsg", "msgMatch", "patternText", "handlePrMerge", "prInfo", "prMatch", "handleTestResult", "testFramework", "handleBuildResult", "buildTool", "patternExtractor", "input", "outputSilentSuccess", "getField", "commandLower", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "SKILL_OVERLAPS", "initUsageFile", "usageFile", "existsSync", "mkdirSync", "writeFileSync", "loadUsageData", "readFileSync", "updateUsage", "skill", "sessionId", "data", "timestamp", "logHook", "getSessionSkills", "checkOverlaps", "currentSkill", "sessionSkills", "overlapKey", "suggestion", "skill1", "skill2", "otherSkill", "getUsageStats", "entries", "a", "b", "count", "skillUsageOptimizer", "input", "toolName", "skillName", "getField", "outputSilentSuccess", "getProjectDir", "getSessionId", "overlapSuggestion", "usageStats", "contextMsg", "currentSkillCount", "existsSync", "readFileSync", "execSync", "isMultiInstanceEnabled", "execSync", "dbPath", "getProjectDir", "existsSync", "releaseFileLock", "filePath", "instanceId", "escapedPath", "escapedInstance", "logHook", "error", "getInstanceId", "instanceEnv", "match", "readFileSync", "getSessionId", "fileLockRelease", "input", "toolName", "outputSilentSuccess", "getField", "toolResult", "hooks", "auditLogger", "autoLint", "contextBudgetMonitor", "coordinationHeartbeat", "errorCollector", "errorSolutionSuggester", "errorTracker", "mem0WebhookHandler", "memoryBridge", "realtimeSync", "sessionMetrics", "skillEditTracker", "calibrationTracker", "codeStyleLearner", "coveragePredictor", "namingConventionLearner", "readmeSync", "releaseLockOnCommit", "issueProgressCommenter", "issueSubtaskUpdater", "patternExtractor", "skillUsageOptimizer", "fileLockRelease", "getHook", "name", "listHooks"]
}
