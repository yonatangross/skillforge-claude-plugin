{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/orchestration-types.ts", "../src/lib/orchestration-state.ts", "../src/lib/retry-manager.ts", "../src/lib/calibration-engine.ts", "../src/subagent-start/agent-memory-inject.ts", "../src/subagent-start/context-gate.ts", "../src/subagent-start/subagent-context-stager.ts", "../src/subagent-start/subagent-validator.ts", "../src/lib/task-integration.ts", "../src/subagent-start/task-linker.ts", "../src/subagent-stop/agent-memory-store.ts", "../src/subagent-stop/auto-spawn-quality.ts", "../src/subagent-stop/context-publisher.ts", "../src/subagent-stop/feedback-loop.ts", "../src/lib/multi-agent-coordinator.ts", "../src/subagent-stop/handoff-preparer.ts", "../src/subagent-stop/multi-claude-verifier.ts", "../src/subagent-stop/output-validator.ts", "../src/subagent-stop/subagent-completion-tracker.ts", "../src/subagent-stop/subagent-quality-gate.ts", "../src/subagent-stop/task-completer.ts", "../src/subagent-stop/retry-handler.ts", "../src/entries/subagent.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result (SubagentStop) */\n  tool_result?: string;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { appendFileSync, existsSync, statSync, renameSync, mkdirSync } from 'node:fs';\nimport type { HookResult, HookInput } from '../types.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return `${process.env.HOME}/.claude/logs/ork`;\n  }\n  return `${getProjectDir()}/.claude/logs`;\n}\n\n/**\n * Get the project directory\n * Read dynamically to support testing\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory\n * Read dynamically to support testing\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the session ID\n * CC 2.1.9+ should guarantee CLAUDE_SESSION_ID availability, but we add\n * a defensive fallback to prevent hook crashes during edge cases.\n * Read dynamically to support testing.\n */\nexport function getSessionId(): string {\n  return process.env.CLAUDE_SESSION_ID || `fallback-${process.pid}-${Date.now()}`;\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message - CC 2.1.7 compliant (no ANSI in JSON)\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n */\nexport function logHook(hookName: string, message: string): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    appendFileSync(logFile, `[${timestamp}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = input?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = input?.session_id || getSessionId();\n\n    appendFileSync(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    // Use fs.readSync for synchronous stdin reading\n    const { readSync } = require('node:fs');\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * Orchestration Types - Shared type definitions for Agent Orchestration Layer\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * These types support:\n * - Intent classification with hybrid scoring\n * - Agent and skill matching\n * - CC 2.1.16 Task system integration\n * - Outcome-based calibration\n * - Multi-agent coordination\n */\n\n// -----------------------------------------------------------------------------\n// Confidence Thresholds\n// -----------------------------------------------------------------------------\n\nexport const THRESHOLDS = {\n  /** Auto-dispatch agent without confirmation */\n  AUTO_DISPATCH: 85,\n  /** Auto-inject skill content */\n  SKILL_INJECT: 80,\n  /** Strong recommendation shown to user */\n  STRONG_RECOMMEND: 70,\n  /** Suggestion shown to user */\n  SUGGEST: 50,\n  /** Minimum confidence to consider */\n  MINIMUM: 40,\n} as const;\n\n// -----------------------------------------------------------------------------\n// Intent Classification Types\n// -----------------------------------------------------------------------------\n\n/** Signal types used in intent classification */\nexport type SignalType =\n  | 'keyword'         // Direct keyword match\n  | 'phrase'          // Multi-word phrase match\n  | 'context'         // Context continuity from history\n  | 'cooccurrence'    // Learned keyword co-occurrence\n  | 'negation'        // Detected negation reducing confidence\n  | 'boost'           // Calibration boost from successful outcomes\n  | 'penalty';        // Calibration penalty from failures\n\n/** Individual signal contributing to classification */\nexport interface IntentSignal {\n  type: SignalType;\n  source: string;       // What triggered this signal\n  weight: number;       // Weight contribution (0-100)\n  matched: string;      // What was matched in the prompt\n}\n\n/** Match result for an agent */\nexport interface AgentMatch {\n  agent: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Match result for a skill */\nexport interface SkillMatch {\n  skill: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Result from intent classification */\nexport interface ClassificationResult {\n  /** Matching agents sorted by confidence */\n  agents: AgentMatch[];\n  /** Matching skills sorted by confidence */\n  skills: SkillMatch[];\n  /** Primary detected intent category */\n  intent: string;\n  /** Highest confidence score across all matches */\n  confidence: number;\n  /** All signals used in classification */\n  signals: IntentSignal[];\n  /** Whether this should trigger auto-dispatch */\n  shouldAutoDispatch: boolean;\n  /** Whether skills should be auto-injected */\n  shouldInjectSkills: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Orchestration State Types\n// -----------------------------------------------------------------------------\n\n/** Action to take based on classification */\nexport type OrchestrationAction =\n  | 'auto-dispatch'    // Immediately spawn agent\n  | 'inject-skill'     // Auto-load skill content\n  | 'strong-recommend' // Show strong recommendation\n  | 'suggest'          // Show suggestion\n  | 'none';            // No action needed\n\n/** State for a dispatched agent */\nexport interface DispatchedAgent {\n  agent: string;\n  taskId?: string;     // CC 2.1.16 task ID if created\n  confidence: number;\n  dispatchedAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'retrying';\n  retryCount: number;\n  maxRetries: number;\n}\n\n/** Current orchestration session state */\nexport interface OrchestrationState {\n  sessionId: string;\n  /** Active dispatched agents */\n  activeAgents: DispatchedAgent[];\n  /** Skills currently injected */\n  injectedSkills: string[];\n  /** Recent prompts for context continuity */\n  promptHistory: string[];\n  /** Max prompts to keep in history */\n  maxHistorySize: number;\n  /** Last classification result */\n  lastClassification?: ClassificationResult;\n  /** Timestamp of last update */\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// CC 2.1.16 Task Integration Types\n// -----------------------------------------------------------------------------\n\n/** Metadata attached to tasks for orchestration */\nexport interface TaskMetadata {\n  /** Source of task creation */\n  source: 'orchestration' | 'user' | 'pipeline';\n  /** Agent that was dispatched */\n  dispatchedAgent?: string;\n  /** Classification confidence at dispatch time */\n  dispatchConfidence?: number;\n  /** Pipeline this task belongs to */\n  pipelineId?: string;\n  /** Step in pipeline sequence */\n  pipelineStep?: number;\n  /** Related skill names */\n  relatedSkills?: string[];\n  /** Signals that triggered dispatch */\n  dispatchSignals?: IntentSignal[];\n}\n\n/** Instruction to create a CC 2.1.16 task */\nexport interface TaskCreateInstruction {\n  subject: string;\n  description: string;\n  activeForm: string;\n  metadata: TaskMetadata;\n  /** Tasks this one is blocked by */\n  blockedBy?: string[];\n}\n\n/** Instruction to update a CC 2.1.16 task */\nexport interface TaskUpdateInstruction {\n  taskId: string;\n  status?: 'pending' | 'in_progress' | 'completed';\n  addBlockedBy?: string[];\n  addBlocks?: string[];\n}\n\n// -----------------------------------------------------------------------------\n// Retry and Error Handling Types\n// -----------------------------------------------------------------------------\n\n/** Outcome of an agent execution */\nexport type AgentOutcome = 'success' | 'partial' | 'failure' | 'rejected';\n\n/** Decision on what to do after failure */\nexport interface RetryDecision {\n  shouldRetry: boolean;\n  retryCount: number;\n  maxRetries: number;\n  /** Alternative agent to suggest if giving up */\n  alternativeAgent?: string;\n  /** Reason for decision */\n  reason: string;\n  /** Delay before retry in ms */\n  delayMs?: number;\n}\n\n/** Record of an agent execution attempt */\nexport interface ExecutionAttempt {\n  agent: string;\n  taskId?: string;\n  attemptNumber: number;\n  startedAt: string;\n  completedAt?: string;\n  outcome?: AgentOutcome;\n  error?: string;\n  durationMs?: number;\n}\n\n// -----------------------------------------------------------------------------\n// Calibration Types\n// -----------------------------------------------------------------------------\n\n/** Record of a dispatched agent outcome for calibration */\nexport interface CalibrationRecord {\n  timestamp: string;\n  sessionId: string;\n  agent: string;\n  promptHash: string;        // Hash of triggering prompt\n  matchedKeywords: string[];\n  dispatchConfidence: number;\n  outcome: AgentOutcome;\n  durationMs?: number;\n  /** User feedback if any */\n  feedback?: 'positive' | 'negative' | 'neutral';\n}\n\n/** Learned adjustment for keyword/agent pairs */\nexport interface CalibrationAdjustment {\n  keyword: string;\n  agent: string;\n  /** Positive = boost, negative = penalty */\n  adjustment: number;\n  sampleCount: number;\n  lastUpdated: string;\n}\n\n/** Calibration data store */\nexport interface CalibrationData {\n  schemaVersion: string;\n  createdAt: string;\n  updatedAt: string;\n  records: CalibrationRecord[];\n  adjustments: CalibrationAdjustment[];\n  /** Summary stats for monitoring */\n  stats: {\n    totalDispatches: number;\n    successRate: number;\n    avgConfidence: number;\n    topAgents: Array<{ agent: string; count: number; successRate: number }>;\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Multi-Agent Pipeline Types\n// -----------------------------------------------------------------------------\n\n/** Known pipeline definitions */\nexport type PipelineType =\n  | 'product-thinking'\n  | 'full-stack-feature'\n  | 'ai-integration'\n  | 'security-audit'\n  | 'frontend-compliance'\n  | 'custom';\n\n/** Step in a multi-agent pipeline */\nexport interface PipelineStep {\n  agent: string;\n  description: string;\n  /** Task dependencies (step indices) */\n  dependsOn: number[];\n  /** Skills to inject for this step */\n  skills?: string[];\n  /** Estimated context tokens for this step */\n  estimatedTokens?: number;\n}\n\n/** Definition of a multi-agent pipeline */\nexport interface PipelineDefinition {\n  type: PipelineType;\n  name: string;\n  description: string;\n  /** Trigger patterns that activate this pipeline */\n  triggers: string[];\n  steps: PipelineStep[];\n  /** Total estimated tokens for full pipeline */\n  estimatedTotalTokens: number;\n}\n\n/** Active pipeline execution state */\nexport interface PipelineExecution {\n  pipelineId: string;\n  type: PipelineType;\n  startedAt: string;\n  /** Map of step index to task ID */\n  taskIds: Record<number, string>;\n  /** Current step being executed */\n  currentStep: number;\n  /** Completed steps */\n  completedSteps: number[];\n  status: 'running' | 'completed' | 'failed' | 'paused';\n}\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/** Orchestration configuration */\nexport interface OrchestrationConfig {\n  /** Enable auto-dispatch at high confidence */\n  enableAutoDispatch: boolean;\n  /** Enable skill auto-injection */\n  enableSkillInjection: boolean;\n  /** Maximum tokens for skill injection */\n  maxSkillInjectionTokens: number;\n  /** Enable outcome calibration */\n  enableCalibration: boolean;\n  /** Enable pipeline detection */\n  enablePipelines: boolean;\n  /** Custom confidence thresholds */\n  thresholds?: Partial<typeof THRESHOLDS>;\n  /** Max retries for failed agents */\n  maxRetries: number;\n  /** Retry delay base in ms */\n  retryDelayBaseMs: number;\n}\n\n/** Default orchestration configuration */\nexport const DEFAULT_CONFIG: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 800,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Retry Manager - Intelligent retry decisions for failed agents\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Exponential backoff retry logic\n * - Alternative agent suggestions\n * - Failure pattern detection\n * - Max retry limits\n */\n\nimport { logHook } from './common.js';\nimport type {\n  RetryDecision,\n  ExecutionAttempt,\n  AgentOutcome,\n  DispatchedAgent,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_BASE_DELAY_MS = 1000;\nconst MAX_DELAY_MS = 30000;\n\n/** Alternative agent mappings for common failure scenarios */\nconst ALTERNATIVE_AGENTS: Record<string, string[]> = {\n  // If backend architect fails, try these\n  'backend-system-architect': ['database-engineer', 'api-designer'],\n  // If frontend fails, try UI designer first\n  'frontend-ui-developer': ['rapid-ui-designer', 'accessibility-specialist'],\n  // If test generator fails, try debug investigator\n  'test-generator': ['debug-investigator', 'code-quality-reviewer'],\n  // If security auditor fails, try layer auditor\n  'security-auditor': ['security-layer-auditor'],\n  // If workflow architect fails, try LLM integrator\n  'workflow-architect': ['llm-integrator', 'data-pipeline-engineer'],\n};\n\n/** Error patterns that indicate retry is unlikely to help */\nconst NON_RETRYABLE_ERRORS = [\n  /permission denied/i,\n  /access denied/i,\n  /not found.*(?:file|module|package)/i,\n  /(?:file|module|package)\\s+not\\s+found/i,\n  /missing required/i,\n  /invalid (?:api|token|key)/i,\n  /authentication failed/i,\n  /quota exceeded/i,\n  /rate limit/i,\n];\n\n/** Error patterns that suggest trying an alternative agent */\nconst ALTERNATIVE_SUGGESTING_ERRORS = [\n  /not my specialization/i,\n  /outside my scope/i,\n  /better suited for/i,\n  /consider using/i,\n  /specialized agent/i,\n];\n\n// -----------------------------------------------------------------------------\n// Retry Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate exponential backoff delay\n */\nexport function calculateBackoffDelay(\n  attemptNumber: number,\n  baseDelayMs: number = DEFAULT_BASE_DELAY_MS\n): number {\n  // Exponential backoff with jitter\n  const exponentialDelay = baseDelayMs * Math.pow(2, attemptNumber - 1);\n  const jitter = Math.random() * 0.1 * exponentialDelay; // 10% jitter\n  return Math.min(exponentialDelay + jitter, MAX_DELAY_MS);\n}\n\n/**\n * Check if error is retryable\n */\nexport function isRetryableError(error: string): boolean {\n  for (const pattern of NON_RETRYABLE_ERRORS) {\n    if (pattern.test(error)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if error suggests alternative agent\n */\nexport function suggestsAlternative(error: string): boolean {\n  for (const pattern of ALTERNATIVE_SUGGESTING_ERRORS) {\n    if (pattern.test(error)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get alternative agent for a given agent\n */\nexport function getAlternativeAgent(agent: string, triedAgents: string[] = []): string | undefined {\n  const alternatives = ALTERNATIVE_AGENTS[agent];\n  if (!alternatives) return undefined;\n\n  // Return first alternative not yet tried\n  for (const alt of alternatives) {\n    if (!triedAgents.includes(alt)) {\n      return alt;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Make retry decision based on execution history and error\n */\nexport function makeRetryDecision(\n  agent: string,\n  attemptNumber: number,\n  error: string,\n  triedAgents: string[] = [],\n  maxRetries: number = DEFAULT_MAX_RETRIES\n): RetryDecision {\n  logHook('retry-manager', `Evaluating retry for ${agent}, attempt ${attemptNumber}`);\n\n  // Check if max retries exceeded\n  if (attemptNumber >= maxRetries) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Max retries (${maxRetries}) exceeded` +\n        (alternative ? `. Consider trying ${alternative} instead.` : ''),\n    };\n  }\n\n  // Check if error is retryable\n  if (!isRetryableError(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Non-retryable error detected: ${error.slice(0, 100)}`,\n    };\n  }\n\n  // Check if error suggests alternative agent\n  if (suggestsAlternative(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    if (alternative) {\n      return {\n        shouldRetry: false,\n        retryCount: attemptNumber,\n        maxRetries,\n        alternativeAgent: alternative,\n        reason: `Error suggests using alternative agent: ${alternative}`,\n      };\n    }\n  }\n\n  // Retry with backoff\n  const delayMs = calculateBackoffDelay(attemptNumber);\n  return {\n    shouldRetry: true,\n    retryCount: attemptNumber,\n    maxRetries,\n    delayMs,\n    reason: `Retrying (attempt ${attemptNumber + 1}/${maxRetries}) after ${Math.round(delayMs / 1000)}s`,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Execution Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Create execution attempt record\n */\nexport function createAttempt(\n  agent: string,\n  attemptNumber: number,\n  taskId?: string\n): ExecutionAttempt {\n  return {\n    agent,\n    taskId,\n    attemptNumber,\n    startedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Complete execution attempt with outcome\n */\nexport function completeAttempt(\n  attempt: ExecutionAttempt,\n  outcome: AgentOutcome,\n  error?: string\n): ExecutionAttempt {\n  const completedAt = new Date().toISOString();\n  const durationMs = new Date(completedAt).getTime() - new Date(attempt.startedAt).getTime();\n\n  return {\n    ...attempt,\n    completedAt,\n    outcome,\n    error,\n    durationMs,\n  };\n}\n\n/**\n * Analyze execution history for patterns\n */\nexport function analyzeAttemptHistory(attempts: ExecutionAttempt[]): {\n  successRate: number;\n  avgDuration: number;\n  commonErrors: string[];\n} {\n  if (attempts.length === 0) {\n    return { successRate: 0, avgDuration: 0, commonErrors: [] };\n  }\n\n  const successful = attempts.filter(a => a.outcome === 'success').length;\n  const successRate = successful / attempts.length;\n\n  const durations = attempts\n    .filter(a => a.durationMs !== undefined)\n    .map(a => a.durationMs!);\n  const avgDuration = durations.length > 0\n    ? durations.reduce((a, b) => a + b, 0) / durations.length\n    : 0;\n\n  // Count error patterns\n  const errorCounts = new Map<string, number>();\n  for (const attempt of attempts) {\n    if (attempt.error) {\n      // Normalize error to first 50 chars\n      const normalized = attempt.error.slice(0, 50).toLowerCase();\n      errorCounts.set(normalized, (errorCounts.get(normalized) || 0) + 1);\n    }\n  }\n\n  // Get most common errors\n  const commonErrors = Array.from(errorCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([error]) => error);\n\n  return { successRate, avgDuration, commonErrors };\n}\n\n// -----------------------------------------------------------------------------\n// Dispatched Agent Updates\n// -----------------------------------------------------------------------------\n\n/**\n * Update dispatched agent for retry\n */\nexport function prepareForRetry(\n  agent: DispatchedAgent,\n  decision: RetryDecision\n): DispatchedAgent {\n  return {\n    ...agent,\n    status: 'retrying',\n    retryCount: decision.retryCount,\n  };\n}\n\n/**\n * Format retry decision as user-facing message\n */\nexport function formatRetryDecision(decision: RetryDecision, agent: string): string {\n  if (decision.shouldRetry) {\n    return `## Retry Scheduled\n\nAgent \\`${agent}\\` will retry after ${Math.round((decision.delayMs || 0) / 1000)} seconds.\n\n**Attempt:** ${decision.retryCount + 1} of ${decision.maxRetries}\n**Reason:** ${decision.reason}`;\n  }\n\n  let message = `## Retry Not Recommended\n\nAgent \\`${agent}\\` has ${decision.retryCount >= decision.maxRetries ? 'exhausted retries' : 'encountered a non-retryable error'}.\n\n**Reason:** ${decision.reason}`;\n\n  if (decision.alternativeAgent) {\n    message += `\n\n### Alternative Suggestion\n\nConsider using \\`${decision.alternativeAgent}\\` instead:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${decision.alternativeAgent}\"\n\\`\\`\\``;\n  }\n\n  return message;\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Agent Memory Inject - SubagentStart Hook\n * CC 2.1.7 Compliant: outputs JSON with continue field\n *\n * Injects actionable memory load instructions before agent spawn with cross-agent federation.\n *\n * Strategy:\n * - Query mem0 for agent-specific memories using agent_id scope\n * - Query for project decisions relevant to agent's domain\n * - Query related agents for cross-agent knowledge sharing\n * - Query graph memory for entity relationships\n * - Output actionable MCP call instructions for memory loading\n *\n * Version: 1.3.0 (TypeScript port)\n * Part of Mem0 Pro Integration - Memory Fabric\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst MAX_MEMORIES = 5;\n\nconst MEM0_SCOPE_AGENTS = 'agents';\nconst MEM0_SCOPE_DECISIONS = 'decisions';\n\n// Agent type to domain mapping\nconst AGENT_DOMAINS: Record<string, string> = {\n  'database-engineer': 'database schema SQL PostgreSQL migration pgvector',\n  'backend-system-architect': 'API REST architecture backend FastAPI microservice',\n  'frontend-ui-developer': 'React frontend UI component TypeScript Tailwind',\n  'security-auditor': 'security OWASP vulnerability audit authentication',\n  'test-generator': 'testing unit integration coverage pytest MSW',\n  'workflow-architect': 'LangGraph workflow agent orchestration state',\n  'llm-integrator': 'LLM API OpenAI Anthropic embeddings RAG function-calling',\n  'data-pipeline-engineer': 'data pipeline embeddings vector ETL chunking',\n  'metrics-architect': 'metrics OKR KPI analytics instrumentation',\n  'ux-researcher': 'UX user research persona journey accessibility',\n  'code-quality-reviewer': 'code quality review linting type-check patterns',\n  'infrastructure-architect': 'infrastructure cloud Docker Kubernetes deployment',\n  'ci-cd-engineer': 'CI CD pipeline GitHub Actions deployment automation',\n  'accessibility-specialist': 'accessibility WCAG ARIA screen-reader a11y',\n  'product-strategist': 'product strategy roadmap features prioritization',\n};\n\n// Related agents for cross-agent knowledge sharing\nconst RELATED_AGENTS: Record<string, string[]> = {\n  'database-engineer': ['backend-system-architect', 'security-auditor', 'data-pipeline-engineer'],\n  'backend-system-architect': ['database-engineer', 'frontend-ui-developer', 'security-auditor', 'llm-integrator'],\n  'frontend-ui-developer': ['backend-system-architect', 'ux-researcher', 'accessibility-specialist', 'rapid-ui-designer'],\n  'security-auditor': ['backend-system-architect', 'database-engineer', 'infrastructure-architect'],\n  'test-generator': ['backend-system-architect', 'frontend-ui-developer', 'code-quality-reviewer'],\n  'workflow-architect': ['llm-integrator', 'backend-system-architect', 'data-pipeline-engineer'],\n  'llm-integrator': ['workflow-architect', 'data-pipeline-engineer', 'backend-system-architect'],\n  'data-pipeline-engineer': ['database-engineer', 'llm-integrator', 'workflow-architect'],\n};\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction getAgentDomain(agentType: string): string {\n  return AGENT_DOMAINS[agentType] || agentType;\n}\n\nfunction getRelatedAgents(agentType: string): string[] {\n  return RELATED_AGENTS[agentType] || [];\n}\n\nfunction getProjectId(): string {\n  const projectDir = getProjectDir();\n  const projectName = projectDir.split('/').pop() || 'default-project';\n  return projectName\n    .toLowerCase()\n    .replace(/ /g, '-')\n    .replace(/[^a-z0-9-]/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-+/g, '-');\n}\n\nfunction mem0UserId(scope: string): string {\n  return `${getProjectId()}-${scope}`;\n}\n\nfunction mem0GlobalUserId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n\nfunction isMem0Available(): boolean {\n  const { existsSync } = require('node:fs');\n  const homeDir = process.env.HOME || '';\n\n  const configPaths = [\n    `${homeDir}/.config/claude/claude_desktop_config.json`,\n    `${homeDir}/Library/Application Support/Claude/claude_desktop_config.json`,\n  ];\n\n  for (const configPath of configPaths) {\n    try {\n      if (existsSync(configPath)) {\n        const { readFileSync } = require('node:fs');\n        const content = readFileSync(configPath, 'utf8');\n        if (content.includes('mem0')) {\n          return true;\n        }\n      }\n    } catch {\n      // Ignore\n    }\n  }\n  return false;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function agentMemoryInject(input: HookInput): HookResult {\n  logHook('agent-memory-inject', 'Agent memory inject hook starting (v1.3.0 - Memory Fabric)');\n\n  // Extract agent type from hook input\n  const toolInput = input.tool_input || {};\n  let agentType =\n    (toolInput.subagent_type as string) || (toolInput.type as string) || '';\n\n  // Fallback: try to extract from prompt\n  if (!agentType && toolInput.prompt) {\n    const prompt = (toolInput.prompt as string).toLowerCase();\n    const knownAgents = Object.keys(AGENT_DOMAINS);\n    for (const agent of knownAgents) {\n      if (prompt.includes(agent)) {\n        agentType = agent;\n        break;\n      }\n    }\n  }\n\n  if (!agentType) {\n    logHook('agent-memory-inject', 'No agent type detected, passing through');\n    return outputSilentSuccess();\n  }\n\n  const agentId = `ork:${agentType}`;\n  logHook('agent-memory-inject', `Detected agent type: ${agentType} (agent_id: ${agentId})`);\n\n  // Check if mem0 is available\n  if (!isMem0Available()) {\n    logHook('agent-memory-inject', 'Mem0 not available, skipping memory injection');\n    return outputSilentSuccess();\n  }\n\n  // Build memory query parameters\n  const projectId = getProjectId();\n  const agentUserId = mem0UserId(MEM0_SCOPE_AGENTS);\n  const decisionsUserId = mem0UserId(MEM0_SCOPE_DECISIONS);\n  const globalUserId = mem0GlobalUserId('best-practices');\n  const domainKeywords = getAgentDomain(agentType);\n  const searchQuery = `${agentType} patterns decisions ${domainKeywords}`;\n\n  logHook('agent-memory-inject', `Memory search: agent_id=${agentId}, project=${projectId}`);\n\n  // Get related agents\n  const relatedAgents = getRelatedAgents(agentType);\n\n  // Build mem0 search JSONs\n  const mem0AgentQuery = JSON.stringify({\n    query: searchQuery,\n    filters: {\n      AND: [{ user_id: agentUserId }, { agent_id: agentId }],\n    },\n    limit: MAX_MEMORIES,\n    enable_graph: true,\n  });\n\n  const mem0DecisionsQuery = JSON.stringify({\n    query: `${domainKeywords} decisions`,\n    filters: {\n      AND: [{ user_id: decisionsUserId }],\n    },\n    limit: MAX_MEMORIES,\n    enable_graph: true,\n  });\n\n  const mem0GlobalQuery = JSON.stringify({\n    query: `${domainKeywords} best practices`,\n    filters: {\n      AND: [{ user_id: globalUserId }],\n    },\n    limit: MAX_MEMORIES,\n    enable_graph: true,\n  });\n\n  // Build memory load instructions\n  let memoryLoadMsg = `[Memory Fabric - Agent Context Load]\n\nExecute these MCP calls to load context for ${agentType} agent:\n\n## 1. Agent-Specific Patterns (mem0)\n\\`\\`\\`\nmcp__mem0__search_memories\n${mem0AgentQuery}\n\\`\\`\\`\n\n## 2. Project Decisions (mem0)\n\\`\\`\\`\nmcp__mem0__search_memories\n${mem0DecisionsQuery}\n\\`\\`\\`\n\n## 3. Graph Memory Entities\n\\`\\`\\`\nmcp__memory__search_nodes\n{\"query\": \"${agentType} ${domainKeywords}\"}\n\\`\\`\\`\n\n## 4. Cross-Project Best Practices (mem0)\n\\`\\`\\`\nmcp__mem0__search_memories\n${mem0GlobalQuery}\n\\`\\`\\``;\n\n  // Add cross-agent section if related agents exist\n  if (relatedAgents.length > 0) {\n    const relatedAgentsStr = relatedAgents.join(', ');\n    const agentFilters = [\n      { agent_id: agentId },\n      ...relatedAgents.map((a) => ({ agent_id: `ork:${a}` })),\n    ];\n    const crossAgentQuery = JSON.stringify({\n      query: domainKeywords,\n      filters: {\n        AND: [{ user_id: agentUserId }, { OR: agentFilters }],\n      },\n      limit: MAX_MEMORIES,\n      enable_graph: true,\n    });\n\n    memoryLoadMsg += `\n\n## 5. Cross-Agent Knowledge (from: ${relatedAgentsStr})\n\\`\\`\\`\nmcp__mem0__search_memories\n${crossAgentQuery}\n\\`\\`\\``;\n  }\n\n  // Add integration instructions\n  const relatedStr = relatedAgents.length > 0 ? relatedAgents.join(', ') : 'none';\n  memoryLoadMsg += `\n\n## Integration Instructions\n1. Execute the above MCP calls to retrieve relevant context\n2. Review memories for patterns, decisions, and constraints\n3. Check graph entities for relationships between concepts\n4. Apply learned patterns to current task\n5. Avoid known anti-patterns (outcome: failed)\n\nAgent ID: ${agentId} | Domain: ${domainKeywords} | Related: ${relatedStr}`;\n\n  const systemMsg = `[Memory Fabric] Agent: ${agentType} | ID: ${agentId} | Load context via MCP calls above | Related: ${relatedStr}`;\n\n  logHook('agent-memory-inject', `Outputting memory load instructions for ${agentType} (Memory Fabric v1.3.0)`);\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n    hookSpecificOutput: {\n      additionalContext: memoryLoadMsg,\n    },\n  };\n}\n", "/**\n * Context Gate - SubagentStart Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Prevents context overflow by limiting concurrent background agents.\n *\n * Strategy:\n * - Track active background agents in session\n * - Block new background spawns when limit exceeded\n * - Force sequential execution for expensive operations\n * - Suggest context compression when approaching limits\n *\n * Version: 1.0.0 (TypeScript port)\n * Part of Context Engineering 2.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync, appendFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputDeny, outputWarning, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst MAX_CONCURRENT_BACKGROUND = 4;\nconst MAX_AGENTS_PER_RESPONSE = 6;\nconst WARNING_THRESHOLD = 3;\nconst EXPENSIVE_TYPES = /^(test-generator|backend-system-architect|workflow-architect|security-auditor|llm-integrator)$/;\n\n// State file paths\nfunction getStateFile(): string {\n  return `${getProjectDir()}/.claude/logs/agent-state.json`;\n}\n\nfunction getSpawnLog(): string {\n  return `${getProjectDir()}/.claude/logs/subagent-spawns.jsonl`;\n}\n\n// -----------------------------------------------------------------------------\n// State Tracking\n// -----------------------------------------------------------------------------\n\ninterface StateData {\n  active_background: string[];\n  session_total: number;\n  last_cleanup: string | null;\n  blocked_count: number;\n}\n\nfunction initState(): void {\n  const stateFile = getStateFile();\n  const dir = stateFile.substring(0, stateFile.lastIndexOf('/'));\n\n  try {\n    mkdirSync(dir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  if (!existsSync(stateFile)) {\n    const initialState: StateData = {\n      active_background: [],\n      session_total: 0,\n      last_cleanup: null,\n      blocked_count: 0,\n    };\n    try {\n      writeFileSync(stateFile, JSON.stringify(initialState, null, 2));\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction countActiveBackground(): number {\n  const spawnLog = getSpawnLog();\n  if (!existsSync(spawnLog)) {\n    return 0;\n  }\n\n  try {\n    const content = readFileSync(spawnLog, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const recentLines = lines.slice(-20);\n\n    // Count agents spawned in last 5 minutes\n    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();\n    let count = 0;\n\n    for (const line of recentLines) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.timestamp && entry.timestamp > fiveMinutesAgo) {\n          count++;\n        }\n      } catch {\n        // Skip invalid JSON\n      }\n    }\n\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\nfunction countCurrentResponseAgents(): number {\n  const spawnLog = getSpawnLog();\n  if (!existsSync(spawnLog)) {\n    return 0;\n  }\n\n  try {\n    const content = readFileSync(spawnLog, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const recentLines = lines.slice(-20);\n\n    // Count agents spawned in last 2 seconds (same response)\n    const twoSecondsAgo = new Date(Date.now() - 2 * 1000).toISOString();\n    let count = 0;\n\n    for (const line of recentLines) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.timestamp && entry.timestamp > twoSecondsAgo) {\n          count++;\n        }\n      } catch {\n        // Skip invalid JSON\n      }\n    }\n\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\nfunction incrementBlockedCount(): void {\n  const stateFile = getStateFile();\n  try {\n    if (existsSync(stateFile)) {\n      const state: StateData = JSON.parse(readFileSync(stateFile, 'utf8'));\n      state.blocked_count = (state.blocked_count || 0) + 1;\n      writeFileSync(stateFile, JSON.stringify(state, null, 2));\n    }\n  } catch {\n    // Ignore\n  }\n}\n\nfunction incrementSessionTotal(): void {\n  const stateFile = getStateFile();\n  try {\n    if (existsSync(stateFile)) {\n      const state: StateData = JSON.parse(readFileSync(stateFile, 'utf8'));\n      state.session_total = (state.session_total || 0) + 1;\n      writeFileSync(stateFile, JSON.stringify(state, null, 2));\n    }\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function contextGate(input: HookInput): HookResult {\n  initState();\n\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const description = (toolInput.description as string) || '';\n  const runInBackground = toolInput.run_in_background === true || toolInput.run_in_background === 'true';\n\n  logHook('context-gate', `Context gate check: ${subagentType} (background=${runInBackground})`);\n\n  // Count current state\n  const activeCount = countActiveBackground();\n  const responseCount = countCurrentResponseAgents();\n\n  logHook('context-gate', `Active background: ${activeCount}, Current response: ${responseCount}`);\n\n  // Check 1: Too many agents in single response\n  if (responseCount >= MAX_AGENTS_PER_RESPONSE) {\n    logHook('context-gate', `BLOCKED: Too many agents in single response (${responseCount} >= ${MAX_AGENTS_PER_RESPONSE})`);\n\n    return outputDeny(`Context Overflow Protection\n\nToo many agents spawned in a single response (${responseCount} agents).\n\nMaximum allowed: ${MAX_AGENTS_PER_RESPONSE} per response\n\nSOLUTION: Split into multiple responses or use sequential execution.\nConsider using the /context-compression skill first.\n\nAttempted: ${subagentType} - ${description}`);\n  }\n\n  // Check 2: Too many concurrent background agents\n  if (runInBackground && activeCount >= MAX_CONCURRENT_BACKGROUND) {\n    logHook('context-gate', `BLOCKED: Too many concurrent background agents (${activeCount} >= ${MAX_CONCURRENT_BACKGROUND})`);\n\n    incrementBlockedCount();\n\n    return outputDeny(`Background Agent Limit\n\nToo many background agents running concurrently (${activeCount} active).\n\nMaximum allowed: ${MAX_CONCURRENT_BACKGROUND} concurrent background agents\n\nSOLUTION:\n1. Wait for existing agents to complete\n2. Run this agent in foreground (remove run_in_background)\n3. Use /context-compression to free up context\n\nAttempted: ${subagentType} - ${description}`);\n  }\n\n  // Warning: Approaching limits\n  if (activeCount >= WARNING_THRESHOLD) {\n    logHook('context-gate', `WARNING: Approaching context budget limit`);\n\n    // Update session total\n    incrementSessionTotal();\n\n    return outputWarning(`Context Budget Warning\n\n${activeCount} background agents active (limit: ${MAX_CONCURRENT_BACKGROUND}).\n\nConsider:\n- Running remaining agents sequentially\n- Using /context-compression skill\n- Waiting for current agents to complete\n\nProceeding with: ${subagentType} - ${description}`);\n  }\n\n  // Warning: Expensive agent type\n  if (EXPENSIVE_TYPES.test(subagentType) && activeCount >= 2) {\n    logHook('context-gate', `WARNING: Expensive agent type with multiple active: ${subagentType}`);\n    return outputWarning(`Spawning expensive agent (${subagentType}) with ${activeCount} others active`);\n  }\n\n  // Update session total\n  incrementSessionTotal();\n\n  // Allow the agent to proceed\n  logHook('context-gate', `Context gate passed: ${subagentType}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Subagent Context Stager - SubagentStart Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * This hook:\n * 1. Checks if there are active todos from session state\n * 2. Stages relevant context files based on the task description\n * 3. Returns systemMessage with staged context\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getSessionState(): string {\n  return `${getProjectDir()}/.claude/context/session/state.json`;\n}\n\nfunction getDecisionsFile(): string {\n  return `${getProjectDir()}/.claude/context/knowledge/decisions/active.json`;\n}\n\nfunction getIssueDir(): string {\n  return `${getProjectDir()}/docs/issues`;\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction Functions\n// -----------------------------------------------------------------------------\n\ninterface SessionState {\n  tasks_pending?: string[];\n  [key: string]: unknown;\n}\n\ninterface DecisionsFile {\n  decisions?: Array<{\n    category?: string;\n    title?: string;\n    status?: string;\n  }>;\n}\n\nfunction extractPendingTasks(): { count: number; summary: string } {\n  const sessionState = getSessionState();\n  if (!existsSync(sessionState)) {\n    return { count: 0, summary: '' };\n  }\n\n  try {\n    const state: SessionState = JSON.parse(readFileSync(sessionState, 'utf8'));\n    const tasksPending = state.tasks_pending || [];\n    const count = tasksPending.length;\n\n    if (count === 0) {\n      return { count: 0, summary: '' };\n    }\n\n    const summary = tasksPending.slice(0, 3).map((t) => `- ${t}`).join('\\n');\n    return { count, summary };\n  } catch {\n    return { count: 0, summary: '' };\n  }\n}\n\nfunction extractRelevantDecisions(taskDescription: string, category: string): string {\n  const decisionsFile = getDecisionsFile();\n  if (!existsSync(decisionsFile)) {\n    return '';\n  }\n\n  try {\n    const data: DecisionsFile = JSON.parse(readFileSync(decisionsFile, 'utf8'));\n    const decisions = data.decisions || [];\n\n    const relevantDecisions = decisions\n      .filter((d) => d.category === category || d.category === 'api' || d.category === 'database')\n      .slice(0, 5)\n      .map((d) => `- ${d.title} (${d.status || 'unknown'})`);\n\n    return relevantDecisions.join('\\n');\n  } catch {\n    return '';\n  }\n}\n\nfunction findIssueDoc(issueNum: string): string {\n  const issueDir = getIssueDir();\n  if (!existsSync(issueDir)) {\n    return '';\n  }\n\n  try {\n    const entries = readdirSync(issueDir);\n    const match = entries.find((entry) => entry.includes(issueNum));\n    if (match) {\n      return `docs/issues/${match}`;\n    }\n  } catch {\n    // Ignore\n  }\n  return '';\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentContextStager(input: HookInput): HookResult {\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const taskDescription = (toolInput.task_description as string) || (toolInput.description as string) || '';\n\n  logHook('subagent-context-stager', `Staging context for ${subagentType}`);\n\n  let stagedContext = '';\n\n  // === CHECK FOR ACTIVE TODOS (Context Protocol 2.0) ===\n  const { count: pendingCount, summary: taskSummary } = extractPendingTasks();\n  if (pendingCount > 0) {\n    logHook('subagent-context-stager', `Found ${pendingCount} pending tasks`);\n    stagedContext += `ACTIVE TODOS:\\n${taskSummary}\\n\\n`;\n  }\n\n  // === STAGE RELEVANT ARCHITECTURE DECISIONS ===\n  const taskLower = taskDescription.toLowerCase();\n\n  if (/backend|api|endpoint|database|migration/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Backend task detected - staging backend decisions');\n    const backendDecisions = extractRelevantDecisions(taskDescription, 'backend');\n    if (backendDecisions) {\n      stagedContext += `RELEVANT DECISIONS:\\n${backendDecisions}\\n\\n`;\n    }\n  }\n\n  if (/frontend|react|ui|component/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Frontend task detected - staging frontend decisions');\n    const frontendDecisions = extractRelevantDecisions(taskDescription, 'frontend');\n    if (frontendDecisions) {\n      stagedContext += `RELEVANT DECISIONS:\\n${frontendDecisions}\\n\\n`;\n    }\n  }\n\n  // === STAGE TESTING REMINDERS ===\n  if (/test|testing|pytest|jest/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Testing task detected - staging test context');\n    stagedContext += `TESTING REMINDERS:\n- Use 'tee' for visible test output\n- Check test patterns in backend/tests/ or frontend/src/**/__tests__/\n- Ensure coverage meets threshold requirements\n\n`;\n  }\n\n  // === STAGE ISSUE DOCUMENTATION ===\n  if (/issue|#\\d+|bug|fix/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Issue-related task detected');\n\n    const issueMatch = taskDescription.match(/#(\\d+)/);\n    if (issueMatch) {\n      const issueNum = issueMatch[1];\n      const issueDoc = findIssueDoc(issueNum);\n      if (issueDoc) {\n        stagedContext += `ISSUE DOCS: ${issueDoc}\\n\\n`;\n        logHook('subagent-context-stager', `Staged issue documentation for #${issueNum}`);\n      }\n    }\n  }\n\n  // === RETURN SYSTEM MESSAGE (CC 2.1.7 Compliant) ===\n  if (stagedContext) {\n    const systemMessage = `${stagedContext}\\nTask: ${taskDescription}\\nSubagent: ${subagentType}`;\n    const lineCount = stagedContext.split('\\n').filter(Boolean).length;\n    logHook('subagent-context-stager', `Staged context with ${lineCount} lines`);\n\n    return {\n      continue: true,\n      systemMessage,\n    };\n  }\n\n  logHook('subagent-context-stager', 'No context staged for this task');\n  return outputSilentSuccess();\n}\n", "/**\n * Subagent Validator - SubagentStart Hook (PreToolUse for Task)\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * This is the ONLY place we track subagent usage because:\n * - SubagentStop hook doesn't receive subagent_type (Claude Code limitation)\n * - PreToolUse receives full task details including type, description, prompt\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, readFileSync, mkdirSync, appendFileSync, readdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst BUILTIN_TYPES = new Set([\n  'general-purpose',\n  'Explore',\n  'Plan',\n  'claude-code-guide',\n  'statusline-setup',\n  'Bash',\n]);\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getTrackingLog(): string {\n  return `${getProjectDir()}/.claude/logs/subagent-spawns.jsonl`;\n}\n\nfunction getPluginJson(): string {\n  return `${getProjectDir()}/plugin.json`;\n}\n\nfunction getAgentsDir(): string {\n  return `${getProjectDir()}/agents`;\n}\n\nfunction getClaudeAgentsDir(): string {\n  return `${getProjectDir()}/.claude/agents`;\n}\n\nfunction getSkillsDir(): string {\n  return `${getProjectDir()}/skills`;\n}\n\n// -----------------------------------------------------------------------------\n// Validation Functions\n// -----------------------------------------------------------------------------\n\nfunction getValidAgentTypes(): Set<string> {\n  const validTypes = new Set(BUILTIN_TYPES);\n\n  // Source 1: Load from plugin.json agents array\n  const pluginJson = getPluginJson();\n  if (existsSync(pluginJson)) {\n    try {\n      const plugin = JSON.parse(readFileSync(pluginJson, 'utf8'));\n      const agents = plugin.agents || [];\n      for (const agent of agents) {\n        if (agent.id) {\n          validTypes.add(agent.id);\n        }\n      }\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Source 2: Scan agents/ directory\n  const agentsDirs = [getAgentsDir(), getClaudeAgentsDir()];\n  for (const agentsDir of agentsDirs) {\n    if (existsSync(agentsDir)) {\n      try {\n        const files = readdirSync(agentsDir);\n        for (const file of files) {\n          if (file.endsWith('.md')) {\n            validTypes.add(file.replace('.md', ''));\n          }\n        }\n      } catch {\n        // Ignore\n      }\n    }\n  }\n\n  return validTypes;\n}\n\nfunction extractAgentSkills(agentType: string): string[] {\n  const skills: string[] = [];\n  const agentFiles = [\n    `${getAgentsDir()}/${agentType}.md`,\n    `${getClaudeAgentsDir()}/${agentType}.md`,\n  ];\n\n  let agentFile: string | null = null;\n  for (const file of agentFiles) {\n    if (existsSync(file)) {\n      agentFile = file;\n      break;\n    }\n  }\n\n  if (!agentFile) {\n    return skills;\n  }\n\n  try {\n    const content = readFileSync(agentFile, 'utf8');\n    const lines = content.split('\\n');\n\n    let inFrontmatter = false;\n    let inSkills = false;\n\n    for (const line of lines) {\n      if (line === '---') {\n        if (!inFrontmatter) {\n          inFrontmatter = true;\n          continue;\n        } else {\n          break; // End of frontmatter\n        }\n      }\n\n      if (!inFrontmatter) continue;\n\n      if (/^skills:/.test(line)) {\n        inSkills = true;\n        continue;\n      }\n\n      if (inSkills && /^[a-zA-Z]/.test(line) && !/^\\s/.test(line)) {\n        inSkills = false;\n        continue;\n      }\n\n      if (inSkills) {\n        const match = line.match(/^\\s*-\\s*(.+)$/);\n        if (match) {\n          const skillName = match[1].trim();\n          skills.push(skillName);\n        }\n      }\n    }\n  } catch {\n    // Ignore\n  }\n\n  return skills;\n}\n\nfunction validateAgentSkills(agentType: string): string[] {\n  const skills = extractAgentSkills(agentType);\n  const missingSkills: string[] = [];\n  const skillsDir = getSkillsDir();\n\n  for (const skill of skills) {\n    const skillPath = `${skillsDir}/${skill}/SKILL.md`;\n    if (!existsSync(skillPath)) {\n      missingSkills.push(skill);\n    }\n  }\n\n  return missingSkills;\n}\n\nfunction logSpawn(subagentType: string, description: string, sessionId: string): void {\n  const trackingLog = getTrackingLog();\n  const dir = trackingLog.substring(0, trackingLog.lastIndexOf('/'));\n\n  try {\n    mkdirSync(dir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    subagent_type: subagentType,\n    description: description,\n    session_id: sessionId,\n  };\n\n  try {\n    appendFileSync(trackingLog, JSON.stringify(entry) + '\\n');\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentValidator(input: HookInput): HookResult {\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const description = (toolInput.description as string) || '';\n  const sessionId = input.session_id || getSessionId();\n\n  logHook('subagent-validator', `Task invocation: ${subagentType} - ${description}`);\n\n  // Log spawn to tracking file\n  logSpawn(subagentType, description, sessionId);\n\n  // Extract agent type (strip namespace prefix like \"ork:\")\n  const agentTypeOnly = subagentType.replace(/^[^:]+:/, '');\n\n  // Get valid types from multiple sources\n  const validTypes = getValidAgentTypes();\n\n  // Validate\n  if (!validTypes.has(subagentType) && !validTypes.has(agentTypeOnly)) {\n    logHook('subagent-validator', `WARNING: Unknown subagent type: ${subagentType}`);\n  }\n\n  // Log spawn\n  logHook('subagent-validator', `Spawning ${subagentType} agent: ${description}`);\n\n  // Validate agent skills\n  const missingSkills = validateAgentSkills(agentTypeOnly);\n  if (missingSkills.length > 0) {\n    const missingList = missingSkills.join(', ');\n    logHook('subagent-validator', `WARNING: Agent '${agentTypeOnly}' references missing skills: ${missingList}`);\n    // Output warning to stderr (visible to user but non-blocking)\n    console.error(`Warning: Agent '${agentTypeOnly}' references ${missingSkills.length} missing skill(s): ${missingList}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: `Working with ${agentTitle}`,\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Task Linker - SubagentStart Hook for CC 2.1.16 Task Integration\n * Issue #197: Agent Orchestration Layer\n *\n * Links spawned agents to their orchestration tasks:\n * 1. Looks up task by agent name in registry\n * 2. Updates task status to in_progress\n * 3. Updates agent tracking state\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport { getTaskByAgent, updateTaskStatus, formatTaskUpdateForClaude } from '../lib/task-integration.js';\nimport { updateAgentStatus } from '../lib/orchestration-state.js';\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Task linker hook - links spawned agents to orchestration tasks\n *\n * When an agent is spawned that was dispatched by the orchestration layer,\n * this hook:\n * 1. Finds the associated task in the registry\n * 2. Generates a TaskUpdate instruction to mark it in_progress\n * 3. Updates local tracking state\n */\nexport function taskLinker(input: HookInput): HookResult {\n  // Get agent type from input\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    '';\n\n  if (!agentType) {\n    logHook('task-linker', 'No agent type found, skipping');\n    return outputSilentSuccess();\n  }\n\n  logHook('task-linker', `Processing SubagentStart for: ${agentType}`);\n\n  // Look up task for this agent\n  const task = getTaskByAgent(agentType);\n\n  if (!task) {\n    logHook('task-linker', `No orchestration task found for agent: ${agentType}`);\n    return outputSilentSuccess();\n  }\n\n  logHook('task-linker', `Found task ${task.taskId} for agent ${agentType}`);\n\n  // Update local registry\n  updateTaskStatus(task.taskId, 'in_progress');\n\n  // Update orchestration state\n  updateAgentStatus(agentType, 'in_progress', task.taskId);\n\n  // Generate TaskUpdate instruction for Claude\n  const updateInstruction = formatTaskUpdateForClaude({\n    taskId: task.taskId,\n    status: 'in_progress',\n  });\n\n  const contextMessage = `## Orchestration: Task Linked\n\nAgent \\`${agentType}\\` has been linked to task **${task.taskId}**.\n\n${updateInstruction}\n\nThe task status should be updated to \\`in_progress\\`.`;\n\n  logHook('task-linker', `Linked agent ${agentType} to task ${task.taskId}`);\n\n  return outputWithContext(contextMessage);\n}\n", "/**\n * Agent Memory Store - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Extracts and stores successful patterns after agent completion.\n *\n * Strategy:\n * - Parse agent output for decision patterns\n * - Extract key architectural choices\n * - Store in mem0 with agent_id scope for future retrieval\n * - Track agent performance metrics\n * - Detect categories for proper organization\n *\n * Version: 1.2.0 (TypeScript port)\n * Part of mem0 Semantic Memory Integration\n */\n\nimport { existsSync, mkdirSync, appendFileSync, unlinkSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DECISION_PATTERNS = [\n  'decided to',\n  'chose',\n  'implemented using',\n  'selected',\n  'opted for',\n  'will use',\n  'pattern:',\n  'approach:',\n  'architecture:',\n  'recommends',\n  'best practice',\n  'anti-pattern',\n  'learned that',\n];\n\nconst MEM0_SCOPE_DECISIONS = 'decisions';\nconst MEM0_SCOPE_AGENTS = 'agents';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getPatternsLog(): string {\n  return `${getProjectDir()}/.claude/logs/agent-patterns.jsonl`;\n}\n\nfunction getAgentTrackingDir(): string {\n  return `${getProjectDir()}/.claude/session`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction getProjectId(): string {\n  const projectDir = getProjectDir();\n  const projectName = projectDir.split('/').pop() || 'default-project';\n  return projectName\n    .toLowerCase()\n    .replace(/ /g, '-')\n    .replace(/[^a-z0-9-]/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-+/g, '-');\n}\n\nfunction mem0UserId(scope: string): string {\n  return `${getProjectId()}-${scope}`;\n}\n\n/**\n * Detect pattern category from text content\n */\nfunction detectPatternCategory(text: string): string {\n  // Security: Limit input length to prevent performance issues\n  const maxLength = 10240;\n  const truncatedText = text.length > maxLength ? text.substring(0, maxLength) : text;\n  const textLower = truncatedText.toLowerCase();\n\n  if (/pagination|cursor|offset/.test(textLower)) {\n    return 'pagination';\n  }\n  if (/security|vulnerability|exploit|injection|xss|csrf|owasp|safety|guardrail/.test(textLower)) {\n    return 'security';\n  }\n  if (/database|sql|postgres|schema/.test(textLower)) {\n    return 'database';\n  }\n  if (/api|endpoint|rest|graphql/.test(textLower)) {\n    return 'api';\n  }\n  if (/auth|login|jwt|oauth/.test(textLower)) {\n    return 'authentication';\n  }\n  if (/test|testing|pytest|jest|vitest|coverage|mock|fixture|spec/.test(textLower)) {\n    return 'testing';\n  }\n  if (/deploy|ci|cd|pipeline|docker|kubernetes|helm|terraform/.test(textLower)) {\n    return 'deployment';\n  }\n  if (/observability|monitoring|logging|tracing|metrics|prometheus|grafana|langfuse/.test(textLower)) {\n    return 'observability';\n  }\n  if (/react|component|frontend|ui/.test(textLower)) {\n    return 'frontend';\n  }\n  if (/performance|optimization|cache|index/.test(textLower)) {\n    return 'performance';\n  }\n  if (/llm|rag|embedding|vector|semantic|ai|ml|langchain|langgraph|mem0|openai|anthropic/.test(textLower)) {\n    return 'ai-ml';\n  }\n  if (/etl|data.*pipeline|streaming|batch.*processing|dataflow|spark/.test(textLower)) {\n    return 'data-pipeline';\n  }\n  if (/architecture|design|structure/.test(textLower)) {\n    return 'architecture';\n  }\n  if (/decided|chose|selected/.test(textLower)) {\n    return 'decision';\n  }\n  return 'pattern';\n}\n\n/**\n * Extract patterns from agent output\n */\nfunction extractPatterns(output: string): string[] {\n  const patterns: string[] = [];\n\n  if (output.length < 50) {\n    return patterns;\n  }\n\n  for (const pattern of DECISION_PATTERNS) {\n    const regex = new RegExp(`^.*${pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}.*$`, 'gim');\n    const matches = output.match(regex) || [];\n\n    for (const match of matches) {\n      const cleaned = match.trim().substring(0, 200);\n      if (cleaned.length > 20) {\n        patterns.push(cleaned);\n      }\n    }\n  }\n\n  // Deduplicate and limit\n  const unique = [...new Set(patterns)];\n  return unique.slice(0, 5);\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function agentMemoryStore(input: HookInput): HookResult {\n  logHook('agent-memory-store', 'Agent memory store hook starting');\n\n  const toolInput = input.tool_input || {};\n  let agentType = input.subagent_type || (toolInput.subagent_type as string) || (toolInput.type as string) || '';\n  const agentOutput = input.tool_result || input.agent_output || input.output || '';\n  let success = true;\n\n  // Check for error in output\n  if (input.error) {\n    success = false;\n  }\n\n  // If no agent type, silent success\n  if (!agentType) {\n    logHook('agent-memory-store', 'No agent type in input, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Build agent_id from AGENT_TYPE\n  const agentId = `ork:${agentType}`;\n\n  // Clean up tracking file to prevent stale data\n  const trackingFile = `${getAgentTrackingDir()}/current-agent-id`;\n  try {\n    if (existsSync(trackingFile)) {\n      unlinkSync(trackingFile);\n    }\n  } catch {\n    // Ignore\n  }\n\n  logHook('agent-memory-store', `Processing completion for agent: ${agentType} (agent_id: ${agentId}, success: ${success})`);\n\n  // Extract patterns (only if successful)\n  const extractedPatterns = success && agentOutput ? extractPatterns(agentOutput) : [];\n\n  if (extractedPatterns.length === 0) {\n    logHook('agent-memory-store', `No patterns extracted from ${agentType} output`);\n    return outputSilentSuccess();\n  }\n\n  // Log patterns for storage\n  const patternsLog = getPatternsLog();\n  const logDir = patternsLog.substring(0, patternsLog.lastIndexOf('/'));\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const projectId = getProjectId();\n  const timestamp = new Date().toISOString();\n  const decisionsUserId = mem0UserId(MEM0_SCOPE_DECISIONS);\n\n  for (const pattern of extractedPatterns) {\n    const category = detectPatternCategory(pattern);\n\n    const entry = {\n      agent: agentType,\n      agent_id: agentId,\n      pattern: pattern,\n      project: projectId,\n      timestamp: timestamp,\n      suggested_user_id: decisionsUserId,\n      category: category,\n      enable_graph: true,\n      pending_sync: true,\n    };\n\n    try {\n      appendFileSync(patternsLog, JSON.stringify(entry) + '\\n');\n    } catch {\n      // Ignore\n    }\n\n    logHook('agent-memory-store', `Extracted pattern (${category}): ${pattern.substring(0, 50)}...`);\n  }\n\n  logHook('agent-memory-store', `Extracted ${extractedPatterns.length} patterns from ${agentType} output`);\n\n  // Build suggestion message\n  const systemMsg = `[Pattern Extraction] ${extractedPatterns.length} patterns extracted from ${agentType}. Use mcp__mem0__add_memory with user_id='${decisionsUserId}', agent_id='${agentId}' to persist (graph memory auto-enabled).`;\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n  };\n}\n", "/**\n * Auto Spawn Quality - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Purpose:\n * - Auto-spawns code-quality-reviewer after test-generator completes\n * - Auto-spawns security-auditor on sensitive file changes\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, appendFileSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getSessionId } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst SENSITIVE_PATTERNS = [\n  '.env',\n  'credentials',\n  'secret',\n  'auth',\n  'password',\n  'token',\n  'api.key',\n  'private.key',\n  '.pem',\n  'oauth',\n  'jwt',\n  'session',\n  'cookie',\n  'encryption',\n  'crypto',\n];\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getSpawnLog(): string {\n  const logDir = `${getProjectDir()}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return `${logDir}/auto-spawn-quality.log`;\n}\n\nfunction getSpawnQueue(): string {\n  return `${getProjectDir()}/.claude/context/spawn-queue.json`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logSpawn(message: string): void {\n  const logFile = getSpawnLog();\n  const timestamp = new Date().toISOString();\n  try {\n    appendFileSync(logFile, `[${timestamp}] [auto-spawn-quality] ${message}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\nfunction containsSensitiveFiles(output: string): boolean {\n  const lowerOutput = output.toLowerCase();\n  for (const pattern of SENSITIVE_PATTERNS) {\n    if (lowerOutput.includes(pattern)) {\n      logSpawn(`Detected sensitive pattern: ${pattern}`);\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface SpawnRequest {\n  spawn_id: string;\n  target_agent: string;\n  trigger_agent: string;\n  trigger_reason: string;\n  priority: string;\n  timestamp: string;\n  session_id: string;\n  status: string;\n}\n\ninterface SpawnQueue {\n  schema_version: string;\n  created_at: string;\n  queue: SpawnRequest[];\n}\n\nfunction queueSpawn(\n  agentType: string,\n  targetAgent: string,\n  triggerReason: string,\n  priority: string,\n  sessionId: string,\n  timestamp: string\n): string {\n  const spawnId = `SPAWN-${new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 14)}-${Math.floor(Math.random() * 10000)\n    .toString()\n    .padStart(4, '0')}`;\n\n  const spawnQueue = getSpawnQueue();\n  const queueDir = spawnQueue.substring(0, spawnQueue.lastIndexOf('/'));\n\n  try {\n    mkdirSync(queueDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  let queue: SpawnQueue;\n  if (existsSync(spawnQueue)) {\n    try {\n      queue = JSON.parse(readFileSync(spawnQueue, 'utf8'));\n    } catch {\n      queue = {\n        schema_version: '1.0.0',\n        created_at: timestamp,\n        queue: [],\n      };\n    }\n  } else {\n    queue = {\n      schema_version: '1.0.0',\n      created_at: timestamp,\n      queue: [],\n    };\n  }\n\n  const request: SpawnRequest = {\n    spawn_id: spawnId,\n    target_agent: targetAgent,\n    trigger_agent: agentType,\n    trigger_reason: triggerReason,\n    priority: priority,\n    timestamp: timestamp,\n    session_id: sessionId,\n    status: 'queued',\n  };\n\n  queue.queue.push(request);\n\n  try {\n    writeFileSync(spawnQueue, JSON.stringify(queue, null, 2));\n    logSpawn(`Queued spawn request: ${spawnId} for ${targetAgent} (reason: ${triggerReason})`);\n  } catch {\n    logSpawn(`ERROR: Failed to queue spawn request for ${targetAgent}`);\n    return '';\n  }\n\n  return spawnId;\n}\n\nfunction writeSpawnSuggestion(\n  agentType: string,\n  targetAgent: string,\n  triggerReason: string,\n  priority: string,\n  sessionId: string,\n  timestamp: string\n): void {\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const suggestionFile = `${handoffDir}/auto_spawn_${targetAgent}_${new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 15)}.json`;\n\n  const suggestion = {\n    type: 'auto_spawn_suggestion',\n    from_agent: agentType,\n    to_agent: targetAgent,\n    timestamp: timestamp,\n    trigger_reason: triggerReason,\n    priority: priority,\n    session_id: sessionId,\n    auto_triggered: true,\n    status: 'suggested',\n  };\n\n  try {\n    writeFileSync(suggestionFile, JSON.stringify(suggestion, null, 2));\n    logSpawn(`Created spawn suggestion: ${targetAgent} (reason: ${triggerReason})`);\n  } catch {\n    // Ignore\n  }\n}\n\ninterface SpawnInfo {\n  target: string;\n  reason: string;\n  priority: string;\n}\n\nfunction checkAutoSpawnConditions(agentType: string, agentOutput: string, error: string): SpawnInfo | null {\n  // Skip if agent had errors\n  if (error && error !== 'null') {\n    logSpawn(`Skipping auto-spawn - agent ${agentType} had errors: ${error}`);\n    return null;\n  }\n\n  // Rule 1: test-generator completion -> code-quality-reviewer\n  if (agentType === 'test-generator') {\n    logSpawn('Rule matched: test-generator -> code-quality-reviewer');\n    return {\n      target: 'code-quality-reviewer',\n      reason: 'test-generator completed - validating test quality and coverage',\n      priority: 'high',\n    };\n  }\n\n  // Rule 2: Any agent with sensitive file changes -> security-auditor\n  if (containsSensitiveFiles(agentOutput)) {\n    if (agentType !== 'security-auditor' && agentType !== 'security-layer-auditor') {\n      logSpawn('Rule matched: sensitive files detected -> security-auditor');\n      return {\n        target: 'security-auditor',\n        reason: 'sensitive file changes detected - security audit required',\n        priority: 'critical',\n      };\n    }\n  }\n\n  // Rule 3: code-quality-reviewer completion -> security-auditor\n  if (agentType === 'code-quality-reviewer') {\n    logSpawn('Rule matched: code-quality-reviewer -> security-auditor');\n    return {\n      target: 'security-auditor',\n      reason: 'code-quality-reviewer completed - proceeding with security scan',\n      priority: 'high',\n    };\n  }\n\n  // Rule 4: backend-system-architect with auth/security mentions -> security-layer-auditor\n  if (agentType === 'backend-system-architect') {\n    const lowerOutput = agentOutput.toLowerCase();\n    if (/authentication|authorization|security|access.control|rbac|acl/.test(lowerOutput)) {\n      logSpawn('Rule matched: backend-system-architect with auth -> security-layer-auditor');\n      return {\n        target: 'security-layer-auditor',\n        reason: 'backend-system-architect designed auth/security layer - validation required',\n        priority: 'high',\n      };\n    }\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function autoSpawnQuality(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const sessionId = input.session_id || getSessionId();\n  const agentOutput = input.agent_output || input.output || '';\n  const error = input.error || '';\n\n  logSpawn(`Checking auto-spawn conditions for agent: ${agentType} (session: ${sessionId})`);\n\n  // Skip if unknown agent type\n  if (agentType === 'unknown' || !agentType) {\n    logSpawn('Skipping unknown agent type');\n    return outputSilentSuccess();\n  }\n\n  // Check auto-spawn conditions\n  const spawnInfo = checkAutoSpawnConditions(agentType, agentOutput, error);\n\n  if (spawnInfo) {\n    // Queue the spawn request\n    const spawnId = queueSpawn(\n      agentType,\n      spawnInfo.target,\n      spawnInfo.reason,\n      spawnInfo.priority,\n      sessionId,\n      timestamp\n    );\n\n    // Write spawn suggestion for orchestrator\n    writeSpawnSuggestion(\n      agentType,\n      spawnInfo.target,\n      spawnInfo.reason,\n      spawnInfo.priority,\n      sessionId,\n      timestamp\n    );\n\n    // Log the action\n    logSpawn(`=== AUTO-SPAWN QUALITY HOOK ===\nTrigger Agent: ${agentType}\nTarget Agent: ${spawnInfo.target}\nReason: ${spawnInfo.reason}\nPriority: ${spawnInfo.priority}\nSpawn ID: ${spawnId}\nTimestamp: ${timestamp}\nSession: ${sessionId}`);\n\n    return {\n      continue: true,\n      systemMessage: `Auto-spawn queued: ${spawnInfo.target} (${spawnInfo.priority} priority)`,\n    };\n  }\n\n  logSpawn(`No auto-spawn conditions matched for ${agentType}`);\n  return outputSilentSuccess();\n}\n", "/**\n * Context Publisher - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Publishes agent decisions to context (Context Protocol 2.0).\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getDecisionsFile(): string {\n  return `${getProjectDir()}/.claude/context/knowledge/decisions/active.json`;\n}\n\nfunction getSessionState(): string {\n  return `${getProjectDir()}/.claude/context/session/state.json`;\n}\n\nfunction getLogDir(): string {\n  return `${getProjectDir()}/.claude/logs/agent-context`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\ninterface DecisionEntry {\n  timestamp: string;\n  agent: string;\n  summary: string;\n  status: string;\n}\n\ninterface DecisionsFile {\n  schema_version: string;\n  decisions: Record<string, DecisionEntry>;\n}\n\ninterface TaskEntry {\n  agent: string;\n  timestamp: string;\n  summary: string;\n}\n\ninterface SessionState {\n  schema_version: string;\n  session_id: string;\n  started_at: string;\n  last_activity: string;\n  active_agent: string | null;\n  tasks_pending: string[];\n  tasks_completed: TaskEntry[];\n}\n\nfunction ensureDir(dirPath: string): void {\n  try {\n    mkdirSync(dirPath, { recursive: true });\n  } catch {\n    // Ignore\n  }\n}\n\nfunction readJsonFile<T>(filePath: string, defaultValue: T): T {\n  if (!existsSync(filePath)) {\n    return defaultValue;\n  }\n  try {\n    return JSON.parse(readFileSync(filePath, 'utf8')) as T;\n  } catch {\n    return defaultValue;\n  }\n}\n\nfunction writeJsonFile(filePath: string, data: unknown): void {\n  const dir = filePath.substring(0, filePath.lastIndexOf('/'));\n  ensureDir(dir);\n  try {\n    writeFileSync(filePath, JSON.stringify(data, null, 2));\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function contextPublisher(input: HookInput): HookResult {\n  const agentName = process.env.CLAUDE_AGENT_NAME || 'unknown';\n  const timestamp = new Date().toISOString();\n\n  // Read agent output from input\n  const output = input.agent_output || input.output || '';\n\n  // Extract summary from output (first 200 chars)\n  let summary = output.substring(0, 200);\n  if (output.length > 200) {\n    summary += '...';\n  }\n\n  // Create agent key (replace hyphens with underscores for JSON)\n  const agentKey = agentName.replace(/-/g, '_');\n\n  // === Update Decisions File (Context Protocol 2.0) ===\n  const decisionsFile = getDecisionsFile();\n  const decisionsDir = decisionsFile.substring(0, decisionsFile.lastIndexOf('/'));\n  ensureDir(decisionsDir);\n\n  const defaultDecisions: DecisionsFile = {\n    schema_version: '2.0.0',\n    decisions: {},\n  };\n\n  const decisions = readJsonFile(decisionsFile, defaultDecisions);\n\n  const decisionEntry: DecisionEntry = {\n    timestamp,\n    agent: agentName,\n    summary,\n    status: 'completed',\n  };\n\n  decisions.decisions[agentKey] = decisionEntry;\n  writeJsonFile(decisionsFile, decisions);\n\n  // === Update Session State (Context Protocol 2.0) ===\n  const sessionStateFile = getSessionState();\n  const sessionDir = sessionStateFile.substring(0, sessionStateFile.lastIndexOf('/'));\n  ensureDir(sessionDir);\n\n  const defaultState: SessionState = {\n    schema_version: '2.0.0',\n    session_id: '',\n    started_at: timestamp,\n    last_activity: timestamp,\n    active_agent: null,\n    tasks_pending: [],\n    tasks_completed: [],\n  };\n\n  const sessionState = readJsonFile(sessionStateFile, defaultState);\n\n  const taskEntry: TaskEntry = {\n    agent: agentName,\n    timestamp,\n    summary,\n  };\n\n  sessionState.tasks_completed.push(taskEntry);\n  sessionState.last_activity = timestamp;\n  sessionState.active_agent = null;\n\n  writeJsonFile(sessionStateFile, sessionState);\n\n  // === Logging ===\n  const logDir = getLogDir();\n  ensureDir(logDir);\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== CONTEXT PUBLICATION (Protocol 2.0) ===\nAgent: ${agentName}\nTimestamp: ${timestamp}\nDecisions file: ${decisionsFile}\nSession state: ${sessionStateFile}\n\n=== AGENT OUTPUT ===\n${output}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Feedback Loop - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n * CC 2.1.16 Compliant: Integrates with Task Management System\n *\n * Purpose:\n * - Captures agent completion context\n * - Routes findings to relevant downstream agents\n * - Logs to decision-log.json\n * - Updates CC 2.1.16 Task status (Issue #197)\n *\n * Version: 2.0.0 (Task Integration)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, readFileSync, appendFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir, getSessionId } from '../lib/common.js';\nimport { getTaskByAgent, updateTaskStatus, getActivePipeline } from '../lib/task-integration.js';\nimport { PIPELINES } from '../lib/multi-agent-coordinator.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getDecisionLog(): string {\n  return `${getProjectDir()}/.claude/coordination/decision-log.json`;\n}\n\nfunction getFeedbackLog(): string {\n  const logDir = `${getProjectDir()}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return `${logDir}/agent-feedback.log`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logFeedback(message: string): void {\n  const logFile = getFeedbackLog();\n  const timestamp = new Date().toISOString();\n  try {\n    appendFileSync(logFile, `[${timestamp}] [feedback-loop] ${message}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\n/**\n * Get downstream agents from PIPELINES definitions or fallback mapping\n */\nfunction getDownstreamAgents(agent: string): string {\n  // First, check if agent is part of an active pipeline\n  const activePipeline = getActivePipeline();\n  if (activePipeline) {\n    const pipelineDef = PIPELINES.find(p => p.type === activePipeline.type);\n    if (pipelineDef) {\n      // Find current step\n      const currentStepIdx = pipelineDef.steps.findIndex(s => s.agent === agent);\n      if (currentStepIdx >= 0) {\n        // Get next steps that depend on this one\n        const nextAgents = pipelineDef.steps\n          .filter((s, idx) => s.dependsOn.includes(currentStepIdx) && idx > currentStepIdx)\n          .map(s => s.agent);\n        if (nextAgents.length > 0) {\n          return nextAgents.join(' ');\n        }\n      }\n    }\n  }\n\n  // Fallback: static mapping for non-pipeline scenarios\n  const mapping: Record<string, string> = {\n    // Product thinking pipeline\n    'market-intelligence': 'product-strategist',\n    'product-strategist': 'prioritization-analyst',\n    'prioritization-analyst': 'business-case-builder',\n    'business-case-builder': 'requirements-translator',\n    'requirements-translator': 'metrics-architect',\n    'metrics-architect': 'backend-system-architect',\n    // Full-stack pipeline\n    'backend-system-architect': 'frontend-ui-developer',\n    'frontend-ui-developer': 'test-generator',\n    'test-generator': 'security-auditor',\n    // AI integration pipeline\n    'workflow-architect': 'llm-integrator',\n    'llm-integrator': 'data-pipeline-engineer',\n    'data-pipeline-engineer': 'test-generator',\n    // UI pipeline\n    'rapid-ui-designer': 'frontend-ui-developer',\n    'ux-researcher': 'rapid-ui-designer',\n  };\n\n  return mapping[agent] || '';\n}\n\n/**\n * Categorize feedback based on agent type\n */\nfunction getFeedbackCategory(agent: string): string {\n  const categories: Record<string, string> = {\n    'market-intelligence': 'product-thinking',\n    'product-strategist': 'product-thinking',\n    'prioritization-analyst': 'product-thinking',\n    'business-case-builder': 'product-thinking',\n    'requirements-translator': 'specification',\n    'metrics-architect': 'specification',\n    'backend-system-architect': 'architecture',\n    'database-engineer': 'architecture',\n    'data-pipeline-engineer': 'architecture',\n    'frontend-ui-developer': 'frontend',\n    'rapid-ui-designer': 'frontend',\n    'ux-researcher': 'frontend',\n    'test-generator': 'quality',\n    'code-quality-reviewer': 'quality',\n    'security-auditor': 'security',\n    'security-layer-auditor': 'security',\n    'workflow-architect': 'ai-integration',\n    'llm-integrator': 'ai-integration',\n    'debug-investigator': 'debugging',\n  };\n\n  return categories[agent] || 'general';\n}\n\n/**\n * Get instance ID consistently\n */\nfunction getInstanceId(): string {\n  return process.env.CLAUDE_INSTANCE_ID || `${require('os').hostname()}-${process.pid}`;\n}\n\nfunction extractFindingsSummary(output: string): string {\n  let summary = output.substring(0, 500);\n  if (output.length > 500) {\n    summary += '...';\n  }\n  return summary;\n}\n\ninterface DecisionEntry {\n  decision_id: string;\n  timestamp: string;\n  made_by: {\n    instance_id: string;\n    agent_type: string;\n  };\n  category: string;\n  title: string;\n  description: string;\n  impact: {\n    scope: string;\n    downstream_agents: string[];\n  };\n  status: string;\n  task_id?: string;  // CC 2.1.16 integration\n}\n\ninterface DecisionLog {\n  schema_version: string;\n  log_created_at: string;\n  decisions: DecisionEntry[];\n}\n\nfunction writeDecision(\n  decisionId: string,\n  agentType: string,\n  category: string,\n  summary: string,\n  downstreamAgents: string,\n  status: string,\n  timestamp: string,\n  taskId?: string\n): void {\n  const decisionLog = getDecisionLog();\n  const logDir = decisionLog.substring(0, decisionLog.lastIndexOf('/'));\n\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  let log: DecisionLog;\n  if (existsSync(decisionLog)) {\n    try {\n      log = JSON.parse(readFileSync(decisionLog, 'utf8'));\n    } catch {\n      log = {\n        schema_version: '2.0.0',\n        log_created_at: timestamp,\n        decisions: [],\n      };\n    }\n  } else {\n    log = {\n      schema_version: '2.0.0',\n      log_created_at: timestamp,\n      decisions: [],\n    };\n  }\n\n  const decisionEntry: DecisionEntry = {\n    decision_id: decisionId,\n    timestamp,\n    made_by: {\n      instance_id: getInstanceId(),\n      agent_type: agentType,\n    },\n    category,\n    title: `Agent ${agentType} completed`,\n    description: summary,\n    impact: {\n      scope: 'agent-pipeline',\n      downstream_agents: downstreamAgents.split(' ').filter(Boolean),\n    },\n    status,\n    task_id: taskId,\n  };\n\n  log.decisions.push(decisionEntry);\n\n  try {\n    writeFileSync(decisionLog, JSON.stringify(log, null, 2));\n    logFeedback(`Decision ${decisionId} logged for agent ${agentType}`);\n  } catch {\n    logFeedback('ERROR: Failed to write decision to log');\n  }\n}\n\ninterface HandoffContext {\n  from_agent: string;\n  to_agent: string;\n  timestamp: string;\n  decision_id: string;\n  summary: string;\n  session_id: string;\n  status: string;\n  feedback_loop: boolean;\n  task_id?: string;  // CC 2.1.16 integration\n}\n\nfunction createHandoffContext(\n  agentType: string,\n  downstreamAgents: string,\n  summary: string,\n  decisionId: string,\n  sessionId: string,\n  timestamp: string,\n  taskId?: string\n): void {\n  if (!downstreamAgents) {\n    return;\n  }\n\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const agents = downstreamAgents.split(' ').filter(Boolean);\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n\n  for (const downstream of agents) {\n    const handoffFile = `${handoffDir}/${agentType}_to_${downstream}_${dateStr}.json`;\n\n    const handoff: HandoffContext = {\n      from_agent: agentType,\n      to_agent: downstream,\n      timestamp,\n      decision_id: decisionId,\n      summary,\n      session_id: sessionId,\n      status: 'pending',\n      feedback_loop: true,\n      task_id: taskId,\n    };\n\n    try {\n      writeFileSync(handoffFile, JSON.stringify(handoff, null, 2));\n      logFeedback(`Created handoff context: ${agentType} -> ${downstream}`);\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function feedbackLoop(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const sessionId = input.session_id || getSessionId();\n  const agentOutput = input.agent_output || input.output || '';\n  const error = input.error || '';\n\n  logFeedback(`Processing feedback for agent: ${agentType} (session: ${sessionId})`);\n\n  // Skip if unknown agent type\n  if (agentType === 'unknown' || !agentType) {\n    logFeedback('Skipping unknown agent type');\n    return outputSilentSuccess();\n  }\n\n  // Generate decision ID\n  const dateStr = new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 8);\n  const randomNum = Math.floor(Math.random() * 10000)\n    .toString()\n    .padStart(4, '0');\n  const decisionId = `DEC-${dateStr}-${randomNum}`;\n\n  // CC 2.1.16: Look up associated task\n  const task = getTaskByAgent(agentType);\n  const taskId = task?.taskId;\n\n  // Determine downstream agents (use pipeline-aware routing)\n  const downstreamAgents = getDownstreamAgents(agentType);\n\n  // Get feedback category\n  const category = getFeedbackCategory(agentType);\n\n  // Extract findings summary\n  let summary: string;\n  let status: string;\n  if (error && error !== 'null') {\n    summary = `Agent failed: ${error}`;\n    status = 'failed';\n  } else {\n    summary = extractFindingsSummary(agentOutput);\n    status = 'completed';\n  }\n\n  // CC 2.1.16: Update task status in registry\n  if (taskId) {\n    updateTaskStatus(taskId, status === 'completed' ? 'completed' : 'failed');\n    logFeedback(`Updated task ${taskId} status to ${status}`);\n  }\n\n  // Write to decision log (now includes task_id)\n  writeDecision(decisionId, agentType, category, summary, downstreamAgents, status, timestamp, taskId);\n\n  // Create handoff context for downstream agents (now includes task_id)\n  if (downstreamAgents) {\n    createHandoffContext(agentType, downstreamAgents, summary, decisionId, sessionId, timestamp, taskId);\n    logFeedback(`Routed findings to downstream agents: ${downstreamAgents}`);\n  } else {\n    logFeedback(`No downstream agents for ${agentType} (terminal agent)`);\n  }\n\n  // Log completion\n  logFeedback(`=== AGENT FEEDBACK LOOP ===\nAgent: ${agentType}\nCategory: ${category}\nDecision ID: ${decisionId}\nTask ID: ${taskId || 'none'}\nTimestamp: ${timestamp}\nStatus: ${status}\nDownstream: ${downstreamAgents || 'none'}\n\nSummary: ${summary}`);\n\n  // Output\n  if (downstreamAgents) {\n    return {\n      continue: true,\n      systemMessage: `Feedback loop: routed to ${downstreamAgents}${taskId ? ` (task: ${taskId})` : ''}`,\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Multi-Agent Coordinator - Pipeline detection and coordination logic\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Pipeline definitions for common workflows\n * - Pipeline detection from prompts\n * - Task chain generation with dependencies\n */\n\nimport { logHook } from './common.js';\nimport type {\n  PipelineType,\n  PipelineDefinition,\n  PipelineExecution,\n  TaskCreateInstruction,\n  TaskMetadata,\n} from './orchestration-types.js';\nimport { registerPipeline, registerTask } from './task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Pipeline Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Predefined pipeline configurations\n */\nexport const PIPELINES: PipelineDefinition[] = [\n  {\n    type: 'product-thinking',\n    name: 'Product Thinking Pipeline',\n    description: 'Full product discovery and specification workflow',\n    triggers: [\n      'should we build',\n      'product decision',\n      'feature validation',\n      'market research',\n      'user research',\n    ],\n    steps: [\n      {\n        agent: 'market-intelligence',\n        description: 'Analyze competitive landscape and market trends',\n        dependsOn: [],\n        skills: ['market-research'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'ux-researcher',\n        description: 'Create personas and map user journeys',\n        dependsOn: [0],\n        skills: ['user-research'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'product-strategist',\n        description: 'Validate value proposition and alignment',\n        dependsOn: [0, 1],\n        skills: ['product-strategy'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'prioritization-analyst',\n        description: 'Score and prioritize using frameworks',\n        dependsOn: [2],\n        skills: ['prioritization'],\n        estimatedTokens: 1500,\n      },\n      {\n        agent: 'business-case-builder',\n        description: 'Build ROI and cost-benefit analysis',\n        dependsOn: [2, 3],\n        skills: ['business-case'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'requirements-translator',\n        description: 'Transform to PRD and user stories',\n        dependsOn: [4],\n        skills: ['requirements'],\n        estimatedTokens: 2500,\n      },\n    ],\n    estimatedTotalTokens: 13500,\n  },\n  {\n    type: 'full-stack-feature',\n    name: 'Full-Stack Feature Pipeline',\n    description: 'End-to-end feature implementation workflow',\n    triggers: [\n      'full-stack feature',\n      'build a feature',\n      'implement end-to-end',\n      'create full feature',\n      'add complete feature',\n    ],\n    steps: [\n      {\n        agent: 'backend-system-architect',\n        description: 'Design API and database schema',\n        dependsOn: [],\n        skills: ['api-design-framework', 'database-schema-designer'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Build React components and UI',\n        dependsOn: [0],\n        skills: ['react-server-components-framework', 'form-state-patterns'],\n        estimatedTokens: 3500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create unit and integration tests',\n        dependsOn: [0, 1],\n        skills: ['integration-testing', 'msw-mocking'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-auditor',\n        description: 'Audit for vulnerabilities',\n        dependsOn: [0, 1],\n        skills: ['owasp-top-10', 'auth-patterns'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 10000,\n  },\n  {\n    type: 'ai-integration',\n    name: 'AI Integration Pipeline',\n    description: 'Add AI/LLM capabilities to application',\n    triggers: [\n      'add rag',\n      'add llm',\n      'ai integration',\n      'implement rag',\n      'add ai feature',\n      'langgraph workflow',\n    ],\n    steps: [\n      {\n        agent: 'workflow-architect',\n        description: 'Design LangGraph workflow and state',\n        dependsOn: [],\n        skills: ['langgraph-state', 'langgraph-routing'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'llm-integrator',\n        description: 'Connect LLM APIs with function calling',\n        dependsOn: [0],\n        skills: ['function-calling', 'llm-streaming'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'data-pipeline-engineer',\n        description: 'Build embeddings and data pipeline',\n        dependsOn: [0],\n        skills: ['embeddings', 'rag-retrieval'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create LLM testing infrastructure',\n        dependsOn: [1, 2],\n        skills: ['llm-testing', 'property-based-testing'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 8500,\n  },\n  {\n    type: 'security-audit',\n    name: 'Security Audit Pipeline',\n    description: 'Comprehensive security review workflow',\n    triggers: [\n      'security audit',\n      'security review',\n      'vulnerability scan',\n      'security assessment',\n    ],\n    steps: [\n      {\n        agent: 'security-auditor',\n        description: 'Scan for OWASP Top 10 vulnerabilities',\n        dependsOn: [],\n        skills: ['owasp-top-10', 'input-validation'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-layer-auditor',\n        description: 'Verify defense-in-depth layers',\n        dependsOn: [0],\n        skills: ['defense-in-depth'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'ai-safety-auditor',\n        description: 'Audit AI/LLM security if applicable',\n        dependsOn: [0],\n        skills: ['mcp-security-hardening'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 5500,\n  },\n  {\n    type: 'frontend-compliance',\n    name: 'Frontend 2026 Compliance Pipeline',\n    description: 'Modernize frontend to 2026 patterns',\n    triggers: [\n      'frontend compliance',\n      'modernize frontend',\n      'update react',\n      'frontend 2026',\n    ],\n    steps: [\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Upgrade to React 19 patterns',\n        dependsOn: [],\n        skills: ['react-server-components-framework', 'zustand-patterns'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'performance-engineer',\n        description: 'Optimize Core Web Vitals',\n        dependsOn: [0],\n        skills: ['core-web-vitals', 'lazy-loading-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'accessibility-specialist',\n        description: 'Ensure WCAG 2.2 compliance',\n        dependsOn: [0],\n        skills: ['a11y-testing', 'focus-management'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 6500,\n  },\n];\n\n// -----------------------------------------------------------------------------\n// Pipeline Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect if prompt matches a pipeline trigger\n */\nexport function detectPipeline(prompt: string): PipelineDefinition | null {\n  const promptLower = prompt.toLowerCase();\n\n  for (const pipeline of PIPELINES) {\n    for (const trigger of pipeline.triggers) {\n      if (promptLower.includes(trigger)) {\n        logHook(\n          'multi-agent-coordinator',\n          `Detected pipeline: ${pipeline.type} (trigger: \"${trigger}\")`\n        );\n        return pipeline;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get pipeline by type\n */\nexport function getPipelineByType(type: PipelineType): PipelineDefinition | null {\n  return PIPELINES.find(p => p.type === type) || null;\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Execution\n// -----------------------------------------------------------------------------\n\n/**\n * Create a pipeline execution plan with task instructions\n */\nexport function createPipelineExecution(\n  pipeline: PipelineDefinition\n): {\n  execution: PipelineExecution;\n  tasks: TaskCreateInstruction[];\n} {\n  const pipelineId = `pipeline-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n\n  // Create task instructions for each step\n  const tasks: TaskCreateInstruction[] = [];\n  const taskIds: Record<number, string> = {};\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const taskId = `task-${pipelineId}-${i}`;\n    taskIds[i] = taskId;\n\n    const metadata: TaskMetadata = {\n      source: 'pipeline',\n      dispatchedAgent: step.agent,\n      pipelineId,\n      pipelineStep: i,\n      relatedSkills: step.skills,\n    };\n\n    // Build blockedBy from dependsOn\n    const blockedBy = step.dependsOn.map(dep => taskIds[dep]).filter(Boolean);\n\n    tasks.push({\n      subject: `[${pipeline.name}] Step ${i + 1}: ${step.description}`,\n      description: `Pipeline step: ${step.agent}\\n\\n${step.description}\\n\\nEstimated tokens: ${step.estimatedTokens}`,\n      activeForm: `Running ${step.agent}`,\n      metadata,\n      blockedBy: blockedBy.length > 0 ? blockedBy : undefined,\n    });\n  }\n\n  const execution: PipelineExecution = {\n    pipelineId,\n    type: pipeline.type,\n    startedAt: new Date().toISOString(),\n    taskIds,\n    currentStep: 0,\n    completedSteps: [],\n    status: 'running',\n  };\n\n  return { execution, tasks };\n}\n\n/**\n * Register pipeline and tasks with tracking systems\n */\nexport function registerPipelineExecution(\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): void {\n  // Register pipeline\n  registerPipeline(execution);\n\n  // Register each task\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    const taskId = execution.taskIds[i];\n\n    if (taskId && task.metadata.dispatchedAgent) {\n      registerTask(\n        taskId,\n        task.metadata.dispatchedAgent,\n        task.metadata.dispatchConfidence || 100,\n        execution.pipelineId,\n        i\n      );\n    }\n  }\n\n  logHook(\n    'multi-agent-coordinator',\n    `Registered pipeline ${execution.pipelineId} with ${tasks.length} tasks`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Message Formatting\n// -----------------------------------------------------------------------------\n\n/**\n * Format pipeline plan as markdown for user\n */\nexport function formatPipelinePlan(\n  pipeline: PipelineDefinition,\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): string {\n  let md = `## \uD83D\uDD04 Pipeline Detected: ${pipeline.name}\n\n${pipeline.description}\n\n**Pipeline ID:** \\`${execution.pipelineId}\\`\n**Estimated Total Tokens:** ~${pipeline.estimatedTotalTokens}\n\n### Pipeline Steps\n\n`;\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const deps = step.dependsOn.length > 0\n      ? ` (after steps: ${step.dependsOn.map(d => d + 1).join(', ')})`\n      : ' (can start immediately)';\n\n    md += `**${i + 1}. ${step.agent}**${deps}\n   ${step.description}\n   Skills: ${step.skills?.join(', ') || 'none'}\n\n`;\n  }\n\n  md += `### Task Creation Instructions\n\nCreate these tasks to track the pipeline:\n\n`;\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    md += `**Task ${i + 1}:**\n\\`\\`\\`\nTaskCreate:\n  subject: \"${task.subject}\"\n  activeForm: \"${task.activeForm}\"\n${task.blockedBy ? `  blockedBy: ${JSON.stringify(task.blockedBy)}` : ''}\n\\`\\`\\`\n\n`;\n  }\n\n  md += `### Start Pipeline\n\nAfter creating all tasks, spawn the first agent:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${pipeline.steps[0].agent}\"\n\\`\\`\\`\n\nThe orchestration layer will track progress and suggest next agents as steps complete.`;\n\n  return md;\n}\n", "/**\n * Handoff Preparer - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Prepares context for handoff to next agent in pipeline.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst VALID_AGENTS = new Set([\n  'market-intelligence',\n  'product-strategist',\n  'prioritization-analyst',\n  'business-case-builder',\n  'requirements-translator',\n  'metrics-architect',\n  'backend-system-architect',\n  'code-quality-reviewer',\n  'data-pipeline-engineer',\n  'database-engineer',\n  'debug-investigator',\n  'frontend-ui-developer',\n  'llm-integrator',\n  'rapid-ui-designer',\n  'security-auditor',\n  'security-layer-auditor',\n  'system-design-reviewer',\n  'test-generator',\n  'ux-researcher',\n  'workflow-architect',\n]);\n\n// Pipeline mappings\nconst NEXT_AGENT_MAP: Record<string, string> = {\n  // Product thinking pipeline\n  'market-intelligence': 'product-strategist',\n  'product-strategist': 'prioritization-analyst',\n  'prioritization-analyst': 'business-case-builder',\n  'business-case-builder': 'requirements-translator',\n  'requirements-translator': 'metrics-architect',\n  'metrics-architect': 'backend-system-architect',\n  // Full-stack pipeline\n  'backend-system-architect': 'frontend-ui-developer',\n  'frontend-ui-developer': 'test-generator',\n  'test-generator': 'code-quality-reviewer',\n  'code-quality-reviewer': 'security-auditor',\n  // AI integration pipeline\n  'workflow-architect': 'llm-integrator',\n  'llm-integrator': 'data-pipeline-engineer',\n  'data-pipeline-engineer': 'code-quality-reviewer',\n  // Database pipeline\n  'database-engineer': 'backend-system-architect',\n  // UI pipeline\n  'rapid-ui-designer': 'frontend-ui-developer',\n  'ux-researcher': 'rapid-ui-designer',\n  // Terminal agents\n  'security-auditor': 'none',\n  'security-layer-auditor': 'none',\n  'debug-investigator': 'none',\n  'system-design-reviewer': 'none',\n};\n\n// Handoff suggestions\nconst SUGGESTIONS_MAP: Record<string, string> = {\n  'market-intelligence': 'Next: product-strategist should define product vision based on market analysis',\n  'product-strategist': 'Next: prioritization-analyst should rank features from strategy',\n  'prioritization-analyst': 'Next: business-case-builder should create ROI justification',\n  'business-case-builder': 'Next: requirements-translator should convert to technical specs',\n  'requirements-translator': 'Next: metrics-architect should define success criteria',\n  'metrics-architect': 'Next: backend-system-architect should design API endpoints',\n  'backend-system-architect': 'Next: frontend-ui-developer should build UI components',\n  'frontend-ui-developer': 'Next: test-generator should create test coverage',\n  'test-generator': 'Next: code-quality-reviewer should validate implementation',\n  'code-quality-reviewer': 'Next: security-auditor should perform security scan',\n  'workflow-architect': 'Next: llm-integrator should configure LLM providers',\n  'llm-integrator': 'Next: data-pipeline-engineer should set up embeddings',\n  'data-pipeline-engineer': 'Next: code-quality-reviewer should validate data pipeline',\n  'database-engineer': 'Next: backend-system-architect should integrate schema',\n  'rapid-ui-designer': 'Next: frontend-ui-developer should implement designs',\n  'ux-researcher': 'Next: rapid-ui-designer should create mockups',\n};\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction getNextAgent(agentName: string): string {\n  return NEXT_AGENT_MAP[agentName] || 'none';\n}\n\nfunction getSuggestions(agentName: string): string {\n  return SUGGESTIONS_MAP[agentName] || 'Pipeline complete';\n}\n\ninterface HandoffContext {\n  from_agent: string;\n  to_agent: string;\n  timestamp: string;\n  summary: string;\n  suggestions: string;\n  status: string;\n}\n\nfunction writeHandoffFile(\n  agentName: string,\n  nextAgent: string,\n  timestamp: string,\n  summary: string,\n  suggestions: string\n): string {\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const handoffFile = `${handoffDir}/${agentName}_to_${nextAgent}_${dateStr}.json`;\n\n  const handoff: HandoffContext = {\n    from_agent: agentName,\n    to_agent: nextAgent,\n    timestamp,\n    summary,\n    suggestions,\n    status: 'ready_for_handoff',\n  };\n\n  try {\n    writeFileSync(handoffFile, JSON.stringify(handoff, null, 2));\n  } catch {\n    // Ignore\n  }\n\n  return handoffFile;\n}\n\nfunction writeLogFile(\n  agentName: string,\n  nextAgent: string,\n  timestamp: string,\n  summary: string,\n  suggestions: string,\n  handoffFile: string\n): void {\n  const logDir = `${getProjectDir()}/.claude/logs/agent-handoffs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== HANDOFF PREPARATION ===\nFrom: ${agentName}\nTo: ${nextAgent}\nTimestamp: ${timestamp}\nHandoff file: ${handoffFile}\n\nSummary: ${summary}\n\nNext Steps: ${suggestions}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function handoffPreparer(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentName =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n\n  // Skip if not a valid pipeline agent\n  if (!VALID_AGENTS.has(agentName)) {\n    // Silent exit for non-pipeline agents (general-purpose, Explore, etc.)\n    return outputSilentSuccess();\n  }\n\n  const nextAgent = getNextAgent(agentName);\n\n  // Extract agent output\n  const agentOutput = input.agent_output || input.output || '';\n\n  // Generate handoff summary\n  const outputLength = agentOutput.length;\n  let summary: string;\n  if (outputLength > 0) {\n    summary = agentOutput.substring(0, 300);\n    if (outputLength > 300) {\n      summary += '...';\n    }\n  } else {\n    summary = `Agent ${agentName} completed`;\n  }\n\n  // Get suggestions\n  const suggestions = getSuggestions(agentName);\n\n  // Create handoff context file\n  const handoffFile = writeHandoffFile(agentName, nextAgent, timestamp, summary, suggestions);\n\n  // Log to file\n  writeLogFile(agentName, nextAgent, timestamp, summary, suggestions, handoffFile);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Multi-Claude Verifier - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Purpose:\n * 1. Auto-spawn code-quality-reviewer after test-generator completes\n * 2. Auto-spawn security-auditor on sensitive file changes\n * 3. Enable parallel verification for comprehensive coverage\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync, appendFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst SENSITIVE_PATTERNS = [\n  '\\\\.env',\n  'auth',\n  'secret',\n  'credential',\n  'password',\n  'token',\n  'api[_-]?key',\n  'jwt',\n  'session',\n  'oauth',\n  'permission',\n  '\\\\.pem$',\n  '\\\\.key$',\n  'config.*prod',\n];\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getLogDir(): string {\n  const logDir = `${getProjectDir()}/.claude/logs/multi-claude`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return logDir;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logAction(agentName: string, action: string, details: string): void {\n  const logDir = getLogDir();\n  const date = new Date().toISOString().substring(0, 10).replace(/-/g, '');\n  const logFile = `${logDir}/verifier_${date}.log`;\n  const timestamp = new Date().toISOString();\n\n  try {\n    appendFileSync(logFile, `[${timestamp}] [${agentName}] ${action}: ${details}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\nfunction containsSensitiveFiles(output: string): boolean {\n  for (const pattern of SENSITIVE_PATTERNS) {\n    const regex = new RegExp(pattern, 'i');\n    if (regex.test(output)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface VerificationAction {\n  agent: string;\n  reason: string;\n}\n\ninterface VerificationQueue {\n  triggered_by: string;\n  timestamp: string;\n  verifications: Array<{\n    agent: string;\n    reason: string;\n    status: string;\n  }>;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function multiClaudeVerifier(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n  const projectDir = getProjectDir();\n\n  const toolInput = input.tool_input || {};\n  const agentName =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const agentOutput = input.agent_output || input.output || '';\n\n  const verificationActions: VerificationAction[] = [];\n\n  // Rule 1: After test-generator, spawn code-quality-reviewer\n  if (agentName === 'test-generator') {\n    verificationActions.push({\n      agent: 'code-quality-reviewer',\n      reason: 'Test generation complete - quality review recommended',\n    });\n    logAction(agentName, 'TRIGGER', 'test-generator completion triggers code-quality-reviewer');\n  }\n\n  // Rule 2: After frontend-ui-developer with form/auth components, spawn security review\n  if (agentName === 'frontend-ui-developer') {\n    if (/form|input|validation|submit|auth|login/i.test(agentOutput)) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Frontend auth/form components - security review recommended',\n      });\n      logAction(agentName, 'TRIGGER', 'frontend auth components trigger security-auditor');\n    }\n  }\n\n  // Rule 3: After backend-system-architect with API endpoints, spawn security review\n  if (agentName === 'backend-system-architect') {\n    if (/endpoint|route|api|auth|jwt|session/i.test(agentOutput)) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Backend API endpoints - security review recommended',\n      });\n      logAction(agentName, 'TRIGGER', 'backend API endpoints trigger security-auditor');\n    }\n  }\n\n  // Rule 4: Any agent touching sensitive files triggers security-auditor\n  if (containsSensitiveFiles(agentOutput)) {\n    // Avoid duplicate\n    const hasSecurityAuditor = verificationActions.some((v) => v.agent === 'security-auditor');\n    if (!hasSecurityAuditor) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Sensitive files modified - security review required',\n      });\n      logAction(agentName, 'TRIGGER', 'sensitive file patterns detected');\n    }\n  }\n\n  // Rule 5: After database-engineer with schema changes, spawn code-quality-reviewer\n  if (agentName === 'database-engineer') {\n    verificationActions.push({\n      agent: 'code-quality-reviewer',\n      reason: 'Database schema changes - review for consistency',\n    });\n    logAction(agentName, 'TRIGGER', 'database changes trigger code-quality-reviewer');\n  }\n\n  // Rule 6: After workflow-architect, spawn security-layer-auditor\n  if (agentName === 'workflow-architect') {\n    verificationActions.push({\n      agent: 'security-layer-auditor',\n      reason: 'LangGraph workflow created - layer audit recommended',\n    });\n    logAction(agentName, 'TRIGGER', 'workflow-architect triggers security-layer-auditor');\n  }\n\n  // Create verification queue file for orchestrator to pick up\n  if (verificationActions.length > 0) {\n    const queueDir = `${projectDir}/.claude/context/verification-queue`;\n    try {\n      mkdirSync(queueDir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n\n    const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n    const queueFile = `${queueDir}/pending_${dateStr}_${agentName}.json`;\n\n    const verificationsQueue: VerificationQueue = {\n      triggered_by: agentName,\n      timestamp,\n      verifications: verificationActions.map((v) => ({\n        agent: v.agent,\n        reason: v.reason,\n        status: 'pending',\n      })),\n    };\n\n    try {\n      writeFileSync(queueFile, JSON.stringify(verificationsQueue, null, 2));\n    } catch {\n      // Ignore\n    }\n\n    // Create system message with recommendations\n    const recommendationMsg =\n      'Multi-Claude Verification Triggered: ' +\n      verificationActions.map((v) => `${v.agent} (${v.reason})`).join('; ');\n\n    logAction(agentName, 'QUEUE', `Created verification queue: ${queueFile}`);\n\n    return {\n      continue: true,\n      systemMessage: recommendationMsg,\n    };\n  }\n\n  logAction(agentName, 'SKIP', 'No verification triggers matched');\n  return outputSilentSuccess();\n}\n", "/**\n * Output Validator - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Validates agent output quality and completeness.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getLogDir(): string {\n  const logDir = `${getProjectDir()}/.claude/logs/agent-validation`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return logDir;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function outputValidator(input: HookInput): HookResult {\n  const agentName = process.env.CLAUDE_AGENT_NAME || 'unknown';\n  const timestamp = new Date().toISOString();\n\n  // Read agent output\n  const output = input.agent_output || input.output || '';\n\n  const validationErrors: string[] = [];\n  const validationWarnings: string[] = [];\n\n  // Check 1: Output is not empty\n  if (!output) {\n    validationErrors.push('Agent produced empty output');\n  }\n\n  // Check 2: Minimum length check\n  const outputLength = output.length;\n  if (outputLength < 50) {\n    validationWarnings.push(`Output seems very short (${outputLength} chars)`);\n  }\n\n  // Check 3: Check for common error patterns\n  if (/error|failed|exception/i.test(output)) {\n    validationWarnings.push('Output contains error-related keywords');\n  }\n\n  // Check 4: For backend architect, validate JSON structure if present\n  if (agentName === 'backend-system-architect') {\n    if (output.includes('{')) {\n      // Try to extract and validate JSON\n      const jsonMatch = output.match(/\\{[^}]*\\}/);\n      if (jsonMatch) {\n        try {\n          JSON.parse(jsonMatch[0]);\n        } catch {\n          validationWarnings.push('JSON structure may be malformed');\n        }\n      }\n    }\n  }\n\n  // Build validation result\n  const validationStatus = validationErrors.length > 0 ? 'failed' : 'passed';\n\n  // Create system message\n  let systemMessage = `Output Validation [${validationStatus}] - Agent: ${agentName}, Timestamp: ${timestamp}, Output length: ${outputLength} chars`;\n\n  if (validationErrors.length > 0) {\n    systemMessage += ' | Errors: ' + validationErrors.join('; ');\n  }\n\n  if (validationWarnings.length > 0) {\n    systemMessage += ' | Warnings: ' + validationWarnings.join('; ');\n  }\n\n  // Log to file\n  const logDir = getLogDir();\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== OUTPUT VALIDATION ===\n${systemMessage}\n\n=== AGENT OUTPUT ===\n${output}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n\n  // CC 2.1.7 compliant output\n  if (validationStatus === 'failed') {\n    return {\n      continue: false,\n      systemMessage,\n      hookSpecificOutput: {\n        hookEventName: 'SubagentStop' as any,\n      },\n    };\n  }\n\n  // Silent success for passed validation\n  return {\n    continue: true,\n    suppressOutput: true,\n    systemMessage,\n  };\n}\n", "/**\n * Subagent Completion Tracker - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * LIMITATION: Claude Code SubagentStop does NOT provide subagent_type.\n * Available fields: session_id, transcript_path, permission_mode, hook_event_name\n *\n * Subagent TYPE tracking is done in PreToolUse (subagent-validator.ts)\n * This hook only logs completion events for session correlation.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getSessionId } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentCompletionTracker(input: HookInput): HookResult {\n  const sessionId = input.session_id || getSessionId();\n  logHook('subagent-completion-tracker', `Subagent completed (session: ${sessionId})`);\n  return outputSilentSuccess();\n}\n", "/**\n * Subagent Quality Gate - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Validates subagent output quality.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, writeFileSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWarning, logHook } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst METRICS_FILE = '/tmp/claude-session-metrics.json';\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\ninterface Metrics {\n  errors: number;\n  [key: string]: unknown;\n}\n\nfunction incrementErrorCount(): void {\n  if (!existsSync(METRICS_FILE)) {\n    return;\n  }\n\n  try {\n    const metrics: Metrics = JSON.parse(readFileSync(METRICS_FILE, 'utf8'));\n    metrics.errors = (metrics.errors || 0) + 1;\n    writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentQualityGate(input: HookInput): HookResult {\n  const agentId = input.agent_id || '';\n  const subagentType = input.subagent_type || '';\n  const error = input.error || '';\n\n  logHook('subagent-quality-gate', `Quality gate check: ${subagentType} (${agentId})`);\n\n  // Check if subagent had errors\n  if (error && error !== 'null') {\n    logHook('subagent-quality-gate', `ERROR: Subagent failed - ${error}`);\n\n    // Track error count\n    incrementErrorCount();\n\n    return outputWarning(`Subagent ${subagentType} failed: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Task Completer - SubagentStop Hook for CC 2.1.16 Task Integration\n * Issue #197: Agent Orchestration Layer\n *\n * Handles agent completion for task management:\n * 1. Marks associated task as completed (or failed)\n * 2. Checks for newly unblocked tasks\n * 3. Handles pipeline progression\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport {\n  getTaskByAgent,\n  updateTaskStatus,\n  getPipelineTasks,\n  completePipelineStep,\n  formatTaskUpdateForClaude,\n} from '../lib/task-integration.js';\nimport { updateAgentStatus, removeAgent } from '../lib/orchestration-state.js';\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Determine if agent completed successfully\n */\nfunction isSuccessfulCompletion(input: HookInput): boolean {\n  const error = input.error || input.tool_error;\n  const exitCode = input.exit_code;\n\n  // Explicit error\n  if (error && error !== 'null' && error !== '') {\n    return false;\n  }\n\n  // Non-zero exit code\n  if (exitCode !== undefined && exitCode !== 0) {\n    return false;\n  }\n\n  // Check for error patterns in output\n  const output = input.agent_output || input.output || '';\n  const errorPatterns = [\n    /\\bfailed\\b/i,\n    /\\berror:\\s/i,\n    /\\bexception\\b/i,\n    /\\bcould not\\b/i,\n    /\\bunable to\\b/i,\n  ];\n\n  // Only check first 500 chars to avoid false positives in long outputs\n  const outputSample = output.slice(0, 500);\n  for (const pattern of errorPatterns) {\n    if (pattern.test(outputSample)) {\n      // Weak signal - don't treat as failure unless explicit error\n      logHook('task-completer', `Warning: possible error in output: ${pattern}`);\n    }\n  }\n\n  return true;\n}\n\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Task completer hook - handles agent completion for task management\n *\n * When an agent completes, this hook:\n * 1. Finds the associated task\n * 2. Marks it completed or failed based on outcome\n * 3. For pipelines, checks for newly unblocked tasks\n * 4. Outputs instructions for next steps\n */\nexport function taskCompleter(input: HookInput): HookResult {\n  // Get agent type from input\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    '';\n\n  if (!agentType) {\n    logHook('task-completer', 'No agent type found, skipping');\n    return outputSilentSuccess();\n  }\n\n  logHook('task-completer', `Processing SubagentStop for: ${agentType}`);\n\n  // Look up task for this agent\n  const task = getTaskByAgent(agentType);\n\n  if (!task) {\n    logHook('task-completer', `No orchestration task found for agent: ${agentType}`);\n    // Still clean up agent state\n    removeAgent(agentType);\n    return outputSilentSuccess();\n  }\n\n  // Determine outcome\n  const success = isSuccessfulCompletion(input);\n  const newStatus = success ? 'completed' : 'failed';\n\n  logHook('task-completer', `Agent ${agentType} completed with status: ${newStatus}`);\n\n  // Update task status\n  updateTaskStatus(task.taskId, newStatus);\n\n  // Update orchestration state\n  updateAgentStatus(agentType, newStatus);\n\n  // Handle pipeline progression\n  let contextMessage = `## Orchestration: Task ${success ? 'Completed' : 'Failed'}\n\nAgent \\`${agentType}\\` has finished with status: **${newStatus}**\n\n${formatTaskUpdateForClaude({\n    taskId: task.taskId,\n    status: success ? 'completed' : 'pending', // CC 2.1.16 tasks don't have 'failed' status\n  })}\n`;\n\n  // Check for pipeline progression\n  if (success && task.pipelineId && task.pipelineStep !== undefined) {\n    const nextStep = completePipelineStep(task.pipelineId, task.pipelineStep);\n\n    if (nextStep !== null) {\n      const nextTasks = getPipelineTasks(task.pipelineId).filter(\n        t => t.pipelineStep === nextStep && t.status === 'pending'\n      );\n\n      if (nextTasks.length > 0) {\n        contextMessage += `\n### Pipeline Progress\n\nPipeline \\`${task.pipelineId}\\` step ${task.pipelineStep} complete.\nNext step (${nextStep}) is now unblocked.\n\n**Next agent(s) to spawn:**\n${nextTasks.map(t => `- \\`${t.agent}\\` (task: ${t.taskId})`).join('\\n')}\n\nConsider spawning the next agent to continue the pipeline.`;\n      }\n    } else {\n      // Pipeline complete\n      contextMessage += `\n### Pipeline Complete\n\nPipeline \\`${task.pipelineId}\\` has completed all steps.`;\n    }\n  }\n\n  // Handle failure\n  if (!success) {\n    const error = input.error || input.tool_error || 'Unknown error';\n    contextMessage += `\n### Error Details\n\nThe agent encountered an issue:\n\\`\\`\\`\n${error.slice(0, 500)}\n\\`\\`\\`\n\nConsider:\n1. Retrying with more specific instructions\n2. Using an alternative agent\n3. Breaking down the task further`;\n  }\n\n  // Clean up agent tracking if complete\n  if (newStatus === 'completed') {\n    removeAgent(agentType);\n  }\n\n  logHook('task-completer', `Completed task ${task.taskId} with status ${newStatus}`);\n\n  return outputWithContext(contextMessage);\n}\n", "/**\n * Retry Handler - SubagentStop Hook for Failed Agent Retry Logic\n * Issue #197: Agent Orchestration Layer\n *\n * Handles agent failures by:\n * 1. Evaluating if retry is appropriate\n * 2. Suggesting alternative agents when needed\n * 3. Tracking retry history\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport {\n  makeRetryDecision,\n  formatRetryDecision,\n  createAttempt,\n  completeAttempt,\n} from '../lib/retry-manager.js';\nimport { loadConfig, loadState, updateAgentStatus } from '../lib/orchestration-state.js';\nimport { updateTaskStatus, getTaskByAgent } from '../lib/task-integration.js';\nimport type { AgentOutcome, ExecutionAttempt } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Execution History Storage\n// -----------------------------------------------------------------------------\n\n/** In-memory execution history (per session) */\nconst executionHistory: Map<string, ExecutionAttempt[]> = new Map();\n\n/**\n * Add attempt to history\n */\nfunction addToHistory(agent: string, attempt: ExecutionAttempt): void {\n  const history = executionHistory.get(agent) || [];\n  history.push(attempt);\n  // Keep only last 10 attempts per agent\n  if (history.length > 10) {\n    history.shift();\n  }\n  executionHistory.set(agent, history);\n}\n\n/**\n * Get tried agents (those with failed attempts)\n */\nfunction getTriedAgents(): string[] {\n  const tried: string[] = [];\n  for (const [agent, attempts] of executionHistory) {\n    if (attempts.some(a => a.outcome === 'failure')) {\n      tried.push(agent);\n    }\n  }\n  return tried;\n}\n\n// -----------------------------------------------------------------------------\n// Outcome Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect outcome from hook input\n */\nfunction detectOutcome(input: HookInput): { outcome: AgentOutcome; error?: string } {\n  const error = input.error || input.tool_error;\n  const exitCode = input.exit_code;\n  const output = input.agent_output || input.output || '';\n\n  // Explicit error\n  if (error && error !== 'null' && error !== '') {\n    return { outcome: 'failure', error };\n  }\n\n  // Non-zero exit code\n  if (exitCode !== undefined && exitCode !== 0) {\n    return { outcome: 'failure', error: `Exit code: ${exitCode}` };\n  }\n\n  // Check output for rejection patterns\n  const rejectionPatterns = [\n    /i cannot|i can't|i am unable/i,\n    /outside my scope/i,\n    /not appropriate/i,\n    /i refuse/i,\n  ];\n\n  for (const pattern of rejectionPatterns) {\n    if (pattern.test(output.slice(0, 500))) {\n      return { outcome: 'rejected', error: 'Agent rejected the task' };\n    }\n  }\n\n  // Check for partial success patterns\n  const partialPatterns = [\n    /partial(?:ly)?/i,\n    /incomplete/i,\n    /some.*failed/i,\n    /couldn't finish/i,\n  ];\n\n  for (const pattern of partialPatterns) {\n    if (pattern.test(output.slice(0, 500))) {\n      return { outcome: 'partial' };\n    }\n  }\n\n  return { outcome: 'success' };\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Retry handler hook - handles agent failures and retry decisions\n *\n * When an agent fails, this hook:\n * 1. Records the attempt in history\n * 2. Evaluates whether to retry\n * 3. Suggests alternatives if retry not recommended\n */\nexport function retryHandler(input: HookInput): HookResult {\n  // Get agent type\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    '';\n\n  if (!agentType) {\n    return outputSilentSuccess();\n  }\n\n  // Detect outcome\n  const { outcome, error } = detectOutcome(input);\n\n  // Skip retry logic for successful completions\n  if (outcome === 'success') {\n    return outputSilentSuccess();\n  }\n\n  logHook('retry-handler', `Agent ${agentType} completed with outcome: ${outcome}`);\n\n  // Load config and state\n  const config = loadConfig();\n  const state = loadState();\n\n  // Find dispatched agent in state\n  const dispatchedAgent = state.activeAgents.find(a => a.agent === agentType);\n  const currentRetryCount = dispatchedAgent?.retryCount || 0;\n\n  // Record attempt\n  const attempt = createAttempt(agentType, currentRetryCount + 1, dispatchedAgent?.taskId);\n  const completedAttempt = completeAttempt(\n    attempt,\n    outcome,\n    error || undefined\n  );\n  addToHistory(agentType, completedAttempt);\n\n  // Get tried agents for alternative suggestions\n  const triedAgents = getTriedAgents();\n\n  // Make retry decision\n  const decision = makeRetryDecision(\n    agentType,\n    currentRetryCount + 1,\n    error || 'Unknown failure',\n    triedAgents,\n    config.maxRetries\n  );\n\n  logHook(\n    'retry-handler',\n    `Retry decision for ${agentType}: shouldRetry=${decision.shouldRetry}, ` +\n    `alternative=${decision.alternativeAgent || 'none'}`\n  );\n\n  // Update agent status based on decision\n  if (decision.shouldRetry) {\n    updateAgentStatus(agentType, 'retrying');\n  } else {\n    updateAgentStatus(agentType, 'failed');\n\n    // Update task status if exists\n    const task = getTaskByAgent(agentType);\n    if (task) {\n      updateTaskStatus(task.taskId, 'failed');\n    }\n  }\n\n  // Format message for user\n  const message = formatRetryDecision(decision, agentType);\n\n  return outputWithContext(message);\n}\n", "/**\n * Subagent Hooks Entry Point\n *\n * Hooks that run on subagent start/stop (SubagentStart, SubagentStop)\n * Bundle: subagent.mjs (~30 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\n\n// Re-export orchestration modules needed by subagent hooks\nexport * from '../lib/orchestration-types.js';\nexport * from '../lib/orchestration-state.js';\nexport * from '../lib/retry-manager.js';\nexport * from '../lib/calibration-engine.js';\n\n// SubagentStart hooks (5)\nimport { agentMemoryInject } from '../subagent-start/agent-memory-inject.js';\nimport { contextGate } from '../subagent-start/context-gate.js';\nimport { subagentContextStager } from '../subagent-start/subagent-context-stager.js';\nimport { subagentValidator } from '../subagent-start/subagent-validator.js';\nimport { taskLinker } from '../subagent-start/task-linker.js';\n\n// SubagentStop hooks (11)\nimport { agentMemoryStore } from '../subagent-stop/agent-memory-store.js';\nimport { autoSpawnQuality } from '../subagent-stop/auto-spawn-quality.js';\nimport { contextPublisher } from '../subagent-stop/context-publisher.js';\nimport { feedbackLoop } from '../subagent-stop/feedback-loop.js';\nimport { handoffPreparer } from '../subagent-stop/handoff-preparer.js';\nimport { multiClaudeVerifier } from '../subagent-stop/multi-claude-verifier.js';\nimport { outputValidator } from '../subagent-stop/output-validator.js';\nimport { subagentCompletionTracker } from '../subagent-stop/subagent-completion-tracker.js';\nimport { subagentQualityGate } from '../subagent-stop/subagent-quality-gate.js';\nimport { taskCompleter } from '../subagent-stop/task-completer.js';\nimport { retryHandler } from '../subagent-stop/retry-handler.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Subagent hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  // SubagentStart hooks (5)\n  'subagent-start/agent-memory-inject': agentMemoryInject,\n  'subagent-start/context-gate': contextGate,\n  'subagent-start/subagent-context-stager': subagentContextStager,\n  'subagent-start/subagent-validator': subagentValidator,\n  'subagent-start/task-linker': taskLinker,\n\n  // SubagentStop hooks (11)\n  'subagent-stop/agent-memory-store': agentMemoryStore,\n  'subagent-stop/auto-spawn-quality': autoSpawnQuality,\n  'subagent-stop/context-publisher': contextPublisher,\n  'subagent-stop/feedback-loop': feedbackLoop,\n  'subagent-stop/handoff-preparer': handoffPreparer,\n  'subagent-stop/multi-claude-verifier': multiClaudeVerifier,\n  'subagent-stop/output-validator': outputValidator,\n  'subagent-stop/subagent-completion-tracker': subagentCompletionTracker,\n  'subagent-stop/subagent-quality-gate': subagentQualityGate,\n  'subagent-stop/task-completer': taskCompleter,\n  'subagent-stop/retry-handler': retryHandler,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "appendFileSync", "existsSync", "statSync", "renameSync", "mkdirSync", "getLogDir", "getProjectDir", "getPluginRoot", "getSessionId", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputAllowWithContext", "systemMessage", "result", "outputError", "message", "outputWarning", "outputDeny", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "rotated", "ensureDir", "dir", "logHook", "hookName", "logDir", "timestamp", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "normalizeCommand", "command", "escapeRegex", "str", "THRESHOLDS", "DEFAULT_CONFIG", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "ensureStateDir", "dir", "existsSync", "mkdirSync", "logHook", "loadState", "stateFile", "data", "readFileSync", "err", "saveState", "state", "writeFileSync", "updateState", "mutate", "trackDispatchedAgent", "agent", "confidence", "taskId", "dispatched", "a", "updateAgentStatus", "status", "entry", "removeAgent", "getActiveAgent", "isAgentDispatched", "trackInjectedSkill", "skill", "isSkillInjected", "getInjectedSkills", "addToPromptHistory", "prompt", "getPromptHistory", "cacheClassification", "result", "getLastClassification", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "saveConfig", "config", "merged", "clearSessionState", "unlinkSync", "cleanupOldStates", "readdirSync", "statSync", "files", "f", "b", "file", "DEFAULT_MAX_RETRIES", "DEFAULT_BASE_DELAY_MS", "MAX_DELAY_MS", "ALTERNATIVE_AGENTS", "NON_RETRYABLE_ERRORS", "ALTERNATIVE_SUGGESTING_ERRORS", "calculateBackoffDelay", "attemptNumber", "baseDelayMs", "exponentialDelay", "jitter", "isRetryableError", "error", "pattern", "suggestsAlternative", "getAlternativeAgent", "agent", "triedAgents", "alternatives", "alt", "makeRetryDecision", "maxRetries", "logHook", "alternative", "delayMs", "createAttempt", "taskId", "completeAttempt", "attempt", "outcome", "completedAt", "durationMs", "analyzeAttemptHistory", "attempts", "successRate", "durations", "avgDuration", "b", "errorCounts", "normalized", "commonErrors", "prepareForRetry", "decision", "formatRetryDecision", "message", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MIN_SAMPLES_FOR_ADJUSTMENT", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "DECAY_FACTOR", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "keyword", "existing", "applyDecay", "now", "dayMs", "adj", "age", "a", "records", "successful", "r", "avgConf", "sum", "agentStats", "stat", "b", "getAdjustments", "getAgentSuccessRate", "agentRecords", "getCalibrationStats", "hasMinimalCalibrationData", "MAX_MEMORIES", "MEM0_SCOPE_AGENTS", "MEM0_SCOPE_DECISIONS", "AGENT_DOMAINS", "RELATED_AGENTS", "getAgentDomain", "agentType", "getRelatedAgents", "getProjectId", "getProjectDir", "mem0UserId", "scope", "mem0GlobalUserId", "isMem0Available", "existsSync", "homeDir", "configPaths", "configPath", "readFileSync", "agentMemoryInject", "input", "logHook", "toolInput", "prompt", "knownAgents", "agent", "outputSilentSuccess", "agentId", "projectId", "agentUserId", "decisionsUserId", "globalUserId", "domainKeywords", "searchQuery", "relatedAgents", "mem0AgentQuery", "mem0DecisionsQuery", "mem0GlobalQuery", "memoryLoadMsg", "relatedAgentsStr", "agentFilters", "a", "crossAgentQuery", "relatedStr", "systemMsg", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "MAX_CONCURRENT_BACKGROUND", "MAX_AGENTS_PER_RESPONSE", "WARNING_THRESHOLD", "EXPENSIVE_TYPES", "getStateFile", "getProjectDir", "getSpawnLog", "initState", "stateFile", "dir", "mkdirSync", "existsSync", "initialState", "writeFileSync", "countActiveBackground", "spawnLog", "recentLines", "readFileSync", "fiveMinutesAgo", "count", "line", "entry", "countCurrentResponseAgents", "twoSecondsAgo", "incrementBlockedCount", "state", "incrementSessionTotal", "contextGate", "input", "toolInput", "subagentType", "description", "runInBackground", "logHook", "activeCount", "responseCount", "outputDeny", "outputWarning", "outputSilentSuccess", "existsSync", "readFileSync", "readdirSync", "getSessionState", "getProjectDir", "getDecisionsFile", "getIssueDir", "extractPendingTasks", "sessionState", "existsSync", "tasksPending", "readFileSync", "count", "summary", "t", "extractRelevantDecisions", "taskDescription", "category", "decisionsFile", "d", "findIssueDoc", "issueNum", "issueDir", "match", "readdirSync", "entry", "subagentContextStager", "input", "toolInput", "subagentType", "logHook", "stagedContext", "pendingCount", "taskSummary", "taskLower", "backendDecisions", "frontendDecisions", "issueMatch", "issueDoc", "systemMessage", "lineCount", "outputSilentSuccess", "existsSync", "readFileSync", "mkdirSync", "appendFileSync", "readdirSync", "BUILTIN_TYPES", "getTrackingLog", "getProjectDir", "getPluginJson", "getAgentsDir", "getClaudeAgentsDir", "getSkillsDir", "getValidAgentTypes", "validTypes", "pluginJson", "existsSync", "agents", "readFileSync", "agent", "agentsDirs", "agentsDir", "files", "readdirSync", "file", "extractAgentSkills", "agentType", "skills", "agentFiles", "agentFile", "lines", "inFrontmatter", "inSkills", "line", "match", "skillName", "validateAgentSkills", "missingSkills", "skillsDir", "skill", "skillPath", "logSpawn", "subagentType", "description", "sessionId", "trackingLog", "dir", "mkdirSync", "entry", "appendFileSync", "subagentValidator", "input", "toolInput", "getSessionId", "logHook", "agentTypeOnly", "missingList", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadRegistry", "file", "readFileSync", "saveRegistry", "registry", "writeFileSync", "err", "logHook", "formatTaskUpdateForClaude", "instruction", "md", "updateTaskStatus", "taskId", "status", "registry", "loadRegistry", "task", "t", "saveRegistry", "logHook", "getTaskByAgent", "agent", "getPipelineTasks", "pipelineId", "loadRegistry", "t", "a", "b", "getActivePipeline", "loadRegistry", "p", "completePipelineStep", "pipelineId", "step", "registry", "pipeline", "a", "b", "tasks", "getPipelineTasks", "task", "taskStep", "saveRegistry", "taskLinker", "input", "agentType", "logHook", "outputSilentSuccess", "task", "getTaskByAgent", "updateTaskStatus", "updateAgentStatus", "updateInstruction", "formatTaskUpdateForClaude", "contextMessage", "outputWithContext", "existsSync", "mkdirSync", "appendFileSync", "unlinkSync", "DECISION_PATTERNS", "MEM0_SCOPE_DECISIONS", "getPatternsLog", "getProjectDir", "getAgentTrackingDir", "getProjectId", "mem0UserId", "scope", "detectPatternCategory", "text", "textLower", "extractPatterns", "output", "patterns", "pattern", "DECISION_PATTERNS", "regex", "matches", "match", "cleaned", "agentMemoryStore", "input", "logHook", "toolInput", "agentType", "agentOutput", "success", "outputSilentSuccess", "agentId", "trackingFile", "existsSync", "unlinkSync", "extractedPatterns", "patternsLog", "logDir", "mkdirSync", "projectId", "timestamp", "decisionsUserId", "MEM0_SCOPE_DECISIONS", "category", "entry", "appendFileSync", "existsSync", "writeFileSync", "mkdirSync", "appendFileSync", "readFileSync", "SENSITIVE_PATTERNS", "getSpawnLog", "logDir", "getProjectDir", "mkdirSync", "getSpawnQueue", "logSpawn", "message", "logFile", "timestamp", "appendFileSync", "containsSensitiveFiles", "output", "lowerOutput", "pattern", "queueSpawn", "agentType", "targetAgent", "triggerReason", "priority", "sessionId", "spawnId", "spawnQueue", "queueDir", "queue", "existsSync", "readFileSync", "request", "writeFileSync", "writeSpawnSuggestion", "handoffDir", "suggestionFile", "suggestion", "checkAutoSpawnConditions", "agentOutput", "error", "autoSpawnQuality", "input", "getSessionId", "outputSilentSuccess", "spawnInfo", "existsSync", "writeFileSync", "mkdirSync", "readFileSync", "getDecisionsFile", "getProjectDir", "getSessionState", "getLogDir", "ensureDir", "dirPath", "mkdirSync", "readJsonFile", "filePath", "defaultValue", "existsSync", "readFileSync", "writeJsonFile", "data", "dir", "writeFileSync", "contextPublisher", "input", "agentName", "timestamp", "output", "summary", "agentKey", "decisionsFile", "decisionsDir", "decisions", "decisionEntry", "sessionStateFile", "sessionDir", "sessionState", "taskEntry", "logDir", "dateStr", "logFile", "logContent", "outputSilentSuccess", "existsSync", "writeFileSync", "mkdirSync", "readFileSync", "appendFileSync", "PIPELINES", "getDecisionLog", "getProjectDir", "getFeedbackLog", "logDir", "mkdirSync", "logFeedback", "message", "logFile", "timestamp", "appendFileSync", "getDownstreamAgents", "agent", "activePipeline", "getActivePipeline", "pipelineDef", "PIPELINES", "p", "currentStepIdx", "s", "nextAgents", "idx", "getFeedbackCategory", "getInstanceId", "extractFindingsSummary", "output", "summary", "writeDecision", "decisionId", "agentType", "category", "downstreamAgents", "status", "taskId", "decisionLog", "log", "existsSync", "readFileSync", "decisionEntry", "writeFileSync", "createHandoffContext", "sessionId", "handoffDir", "agents", "dateStr", "downstream", "handoffFile", "handoff", "feedbackLoop", "input", "getSessionId", "agentOutput", "error", "outputSilentSuccess", "randomNum", "getTaskByAgent", "updateTaskStatus", "writeFileSync", "mkdirSync", "VALID_AGENTS", "NEXT_AGENT_MAP", "SUGGESTIONS_MAP", "getNextAgent", "agentName", "getSuggestions", "writeHandoffFile", "nextAgent", "timestamp", "summary", "suggestions", "handoffDir", "getProjectDir", "mkdirSync", "dateStr", "handoffFile", "handoff", "writeFileSync", "writeLogFile", "logDir", "logFile", "logContent", "handoffPreparer", "input", "outputSilentSuccess", "agentOutput", "outputLength", "writeFileSync", "mkdirSync", "appendFileSync", "SENSITIVE_PATTERNS", "getLogDir", "logDir", "getProjectDir", "mkdirSync", "logAction", "agentName", "action", "details", "date", "logFile", "timestamp", "appendFileSync", "containsSensitiveFiles", "output", "pattern", "multiClaudeVerifier", "input", "projectDir", "agentOutput", "verificationActions", "v", "queueDir", "dateStr", "queueFile", "verificationsQueue", "writeFileSync", "recommendationMsg", "outputSilentSuccess", "writeFileSync", "mkdirSync", "getLogDir", "logDir", "getProjectDir", "mkdirSync", "outputValidator", "input", "agentName", "timestamp", "output", "validationErrors", "validationWarnings", "outputLength", "jsonMatch", "validationStatus", "systemMessage", "dateStr", "logFile", "logContent", "writeFileSync", "subagentCompletionTracker", "input", "sessionId", "getSessionId", "logHook", "outputSilentSuccess", "existsSync", "writeFileSync", "readFileSync", "METRICS_FILE", "incrementErrorCount", "existsSync", "metrics", "readFileSync", "writeFileSync", "subagentQualityGate", "input", "agentId", "subagentType", "error", "logHook", "outputWarning", "outputSilentSuccess", "isSuccessfulCompletion", "input", "error", "exitCode", "output", "errorPatterns", "outputSample", "pattern", "logHook", "taskCompleter", "agentType", "outputSilentSuccess", "task", "getTaskByAgent", "removeAgent", "success", "newStatus", "updateTaskStatus", "updateAgentStatus", "contextMessage", "formatTaskUpdateForClaude", "nextStep", "completePipelineStep", "nextTasks", "getPipelineTasks", "t", "outputWithContext", "executionHistory", "addToHistory", "agent", "attempt", "history", "getTriedAgents", "tried", "attempts", "a", "detectOutcome", "input", "error", "exitCode", "output", "rejectionPatterns", "pattern", "partialPatterns", "retryHandler", "agentType", "outputSilentSuccess", "outcome", "logHook", "config", "loadConfig", "dispatchedAgent", "loadState", "currentRetryCount", "createAttempt", "completedAttempt", "completeAttempt", "triedAgents", "decision", "makeRetryDecision", "updateAgentStatus", "task", "getTaskByAgent", "updateTaskStatus", "message", "formatRetryDecision", "outputWithContext", "hooks", "agentMemoryInject", "contextGate", "subagentContextStager", "subagentValidator", "taskLinker", "agentMemoryStore", "autoSpawnQuality", "contextPublisher", "feedbackLoop", "handoffPreparer", "multiClaudeVerifier", "outputValidator", "subagentCompletionTracker", "subagentQualityGate", "taskCompleter", "retryHandler", "getHook", "name", "listHooks"]
}
